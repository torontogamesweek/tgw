<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toronto Games Week - Interactive Background Tests</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #f0f0f0;
            touch-action: none;
            font-family: 'Courier New', Courier, monospace, sans-serif;
        }
        canvas { display: block; background: #fff; }
        #nav {
            position: fixed;
            top: 0; left: 0; right: 0;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(3, 1fr);
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 2px rgba(0,0,0,0.1);
            z-index: 100;
        }
        .nav-item {
            padding: 8px 8px;
            text-align: center;
            cursor: pointer;
            border-right: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
            font-size: 3rem;
            font-weight: 600;
            transition: all 0.2s;
            user-select: none;
            position: relative;
        }
        .nav-item:nth-child(5n) { border-right: none; }
        .nav-item:nth-child(n+11) { border-bottom: none; }
        .nav-item:hover { background: rgba(0, 0, 0, 0.05); }
        .nav-item.active { background: rgba(0, 0, 0, 0.1); color: #000; }
        .nav-item .tooltip {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: normal;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 200;
            margin-top: 5px;
        }
        .nav-item .tooltip::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: rgba(0, 0, 0, 0.85);
        }
        .nav-item:hover .tooltip { opacity: 1; }
        @media (max-width: 768px) {
            #nav { grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(5, 1fr); }
            .nav-item { font-size: 11px; padding: 10px 5px; }
            .nav-item:nth-child(5n) { border-right: 1px solid #ddd; }
            .nav-item:nth-child(3n) { border-right: none; }
            .nav-item:nth-child(n+11) { border-bottom: 1px solid #ddd; }
            .nav-item:nth-child(n+13) { border-bottom: none; }
            .nav-item .tooltip { font-size: 10px; padding: 6px 10px; }
        }
    </style>
</head>
<body>
    <div id="nav">
        <div class="nav-item" data-game="1">Fling<span class="tooltip">Collect gold âœ¦ but avoid the catchers!</span></div>
        <div class="nav-item" data-game="2">Paddle<span class="tooltip">Keep the balls bouncing! They fade if they rest.</span></div>
        <div class="nav-item" data-game="3">Pop<span class="tooltip">Pop them all! Smaller = harder to click.</span></div>
        <div class="nav-item" data-game="4">Vacuum<span class="tooltip">Hold to vacuum, release to explode!</span></div>
        <div class="nav-item" data-game="5">Gravity Flip<span class="tooltip">Click to reverse gravity</span></div>
        <div class="nav-item" data-game="6">Draw Barriers<span class="tooltip">Draw platforms to bounce falling balls!</span></div>
        <div class="nav-item" data-game="7">Magnet Zones<span class="tooltip">Click = attract, SHIFT+click = repel</span></div>
        <div class="nav-item" data-game="8">Explode<span class="tooltip">Hold to charge, release to burst!</span></div>
        <div class="nav-item" data-game="9">Orbital<span class="tooltip">Balls orbit you. Click to release!</span></div>
        <div class="nav-item" data-game="10">Transform<span class="tooltip">Click balls to make guards. Protect the moving zone</span></div>
        <div class="nav-item" data-game="11">Connections<span class="tooltip">Connect peopleâ†”balls only! Same types explode</span></div>
        <div class="nav-item" data-game="12">Merge & Split<span class="tooltip">Unite all the walkers onto one world!</span></div>
        <div class="nav-item" data-game="13">Inflate/Pop<span class="tooltip">Click balls to pop them</span></div>
        <div class="nav-item" data-game="14">Brush<span class="tooltip">Paint paths for balls to follow</span></div>
        <div class="nav-item" data-game="15">Portals<span class="tooltip">Move all balls to the golden quadrant!</span></div>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        let currentGame = 1;
        let balls = [];
        let gameState = {};
        let mouseX = 0, mouseY = 0;
        const MAX_SPEED = 25;
        let screenShake = { x: 0, y: 0, intensity: 0 };
        
        function capSpeed(ball) { const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy); if (speed > MAX_SPEED) { const scale = MAX_SPEED / speed; ball.vx *= scale; ball.vy *= scale; } }
        function addScreenShake(intensity) { screenShake.intensity = Math.min(Math.max(screenShake.intensity, intensity * 0.4), 8); }
        function updateScreenShake() { if (screenShake.intensity > 0) { screenShake.x = (Math.random() - 0.5) * screenShake.intensity; screenShake.y = (Math.random() - 0.5) * screenShake.intensity; screenShake.intensity *= 0.85; if (screenShake.intensity < 0.3) screenShake.intensity = 0; } else { screenShake.x = 0; screenShake.y = 0; } }
        
        function drawBallWithSquash(ball, opacity = 1.0, rotation = 0, squashX = 1, squashY = 1) {
            const img = ballImages[ball.ballImage - 1];
            ctx.save(); ctx.globalAlpha = opacity; ctx.translate(ball.x, ball.y); ctx.rotate(rotation); ctx.scale(squashX, squashY);
            if (img && img.complete && img.naturalWidth > 0) ctx.drawImage(img, -ball.radius, -ball.radius, ball.radius * 2, ball.radius * 2);
            else { ctx.beginPath(); ctx.arc(0, 0, ball.radius, 0, Math.PI * 2); ctx.fillStyle = '#333'; ctx.fill(); }
            ctx.restore();
        }
        
        const ballImages = [], peopleImages = [];
        const numBallImages = 29, numPeopleImages = 19;
        for (let i = 1; i <= numBallImages; i++) { const img = new Image(); img.src = 'balls/ball_' + i + '.png'; ballImages.push(img); }
        for (let i = 1; i <= numPeopleImages; i++) { const img = new Image(); img.src = 'ppl/ppl_' + i + '.png'; peopleImages.push(img); }
        
        function drawPerson(x, y, height, imageIndex, opacity = 1.0, rotation = 0) {
            const img = peopleImages[imageIndex % numPeopleImages];
            if (img && img.complete && img.naturalWidth > 0) {
                const aspectRatio = img.naturalWidth / img.naturalHeight, width = height * aspectRatio;
                ctx.save(); ctx.globalAlpha = opacity; ctx.translate(x, y); ctx.rotate(rotation);
                ctx.drawImage(img, -width/2, -height, width, height); ctx.restore();
            }
        }
        
        let ballImageCounter = 0, personImageCounter = 0;
        function getNextBallImage() { ballImageCounter = (ballImageCounter + 1) % numBallImages; return ballImageCounter + 1; }
        function getNextPersonImage() { const idx = personImageCounter; personImageCounter = (personImageCounter + 1) % numPeopleImages; return idx; }
        
        function drawStarburst(x, y, innerRadius, outerRadius, points, color) {
            ctx.beginPath();
            for (let i = 0; i < points * 2; i++) {
                const angle = (Math.PI * 2 / (points * 2)) * i - Math.PI / 2;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                if (i === 0) ctx.moveTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
                else ctx.lineTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
            }
            ctx.closePath(); ctx.fillStyle = color; ctx.fill();
        }
        
        const games = {
            1: { name: "Fling", init: initFling, update: updateFling, draw: drawFling, onPointerDown: flingPointerDown, onPointerMove: flingPointerMove, onPointerUp: flingPointerUp },
            2: { name: "Paddle", init: initPaddle, update: updatePaddle, draw: drawPaddle, onPointerMove: paddlePointerMove },
            3: { name: "Pop", init: initPop, update: updatePop, draw: drawPop, onPointerDown: popPointerDown },
            4: { name: "Vacuum", init: initVacuum, update: updateVacuum, draw: drawVacuum, onPointerDown: vacuumPointerDown, onPointerMove: vacuumPointerMove, onPointerUp: vacuumPointerUp },
            5: { name: "Gravity Flip", init: initGravityFlip, update: updateGravityFlip, draw: drawGravityFlip, onPointerDown: gravityFlipPointerDown },
            6: { name: "Draw Barriers", init: initDrawBarriers, update: updateDrawBarriers, draw: drawDrawBarriers, onPointerDown: barrierPointerDown, onPointerMove: barrierPointerMove, onPointerUp: barrierPointerUp },
            7: { name: "Magnet Zones", init: initMagnetZones, update: updateMagnetZones, draw: drawMagnetZones, onPointerDown: magnetPointerDown },
            8: { name: "Explode", init: initExplode, update: updateExplode, draw: drawExplode, onPointerDown: explodePointerDown, onPointerUp: explodePointerUp },
            9: { name: "Orbital", init: initOrbital, update: updateOrbital, draw: drawOrbital, onPointerMove: orbitalPointerMove, onPointerDown: orbitalPointerDown },
            10: { name: "Transform", init: initTransform, update: updateTransform, draw: drawTransform, onPointerDown: transformPointerDown },
            11: { name: "Connections", init: initConnections, update: updateConnections, draw: drawConnections, onPointerDown: connectionsPointerDown, onPointerMove: connectionsPointerMove },
            12: { name: "Merge & Split", init: initMergeSplit, update: updateMergeSplit, draw: drawMergeSplit, onPointerDown: mergeSplitPointerDown },
            13: { name: "Inflate/Pop", init: initInflate, update: updateInflate, draw: drawInflate, onPointerDown: inflatePointerDown },
            14: { name: "Brush", init: initBrush, update: updateBrush, draw: drawBrush, onPointerDown: brushPointerDown, onPointerMove: brushPointerMove, onPointerUp: brushPointerUp },
            15: { name: "Portals", init: initPortals, update: updatePortals, draw: drawPortals, onPointerDown: portalPointerDown }
        };
        
        // GAME 1: FLING - starts with 1 ball, starburst catchers, slower spawn
        function initFling() {
            balls = [];
            gameState = { draggedBall: null, goldenOrbs: [], catchers: [], score: 0, lives: 5, particles: [], gameTime: 0, lastCatcherSpawn: 0 };
            spawnFlingBall(); // Just 1 ball
            for (let i = 0; i < 6; i++) gameState.goldenOrbs.push({ x: 150 + Math.random() * (canvas.width - 300), y: 200 + Math.random() * (canvas.height - 400), radius: 10, pulse: Math.random() * Math.PI * 2 });
            spawnCatcher(); spawnCatcher();
        }
        
        function spawnFlingBall(animated = false) {
            const angle = Math.random() * Math.PI * 2;
            balls.push({ x: canvas.width / 2 + (Math.random() - 0.5) * 200, y: canvas.height / 2 + (Math.random() - 0.5) * 200, vx: Math.cos(angle) * 0.5, vy: Math.sin(angle) * 0.5, radius: 30 + Math.random() * 20, isDragging: false, dragStartX: 0, dragStartY: 0, ballImage: getNextBallImage(), rotation: 0, trail: [], glowTimer: 0, dying: false, deathProgress: 0, deathType: 'explode', spawnProgress: animated ? 0 : 1, squashX: 1, squashY: 1 });
        }
        
        function spawnCatcher() {
            let x, y;
            do { x = 100 + Math.random() * (canvas.width - 200); y = 100 + Math.random() * (canvas.height - 200); } while (Math.abs(x - canvas.width/2) < 200 && Math.abs(y - canvas.height/2) < 200);
            gameState.catchers.push({ x, y, personIndex: getNextPersonImage(), radius: 35, spawnProgress: 0 });
        }
        
        function updateFling() {
            gameState.gameTime++;
            if (gameState.catchers.length < 12 && gameState.gameTime - gameState.lastCatcherSpawn > 1200) { spawnCatcher(); gameState.lastCatcherSpawn = gameState.gameTime; } // Even slower: 20 seconds
            gameState.goldenOrbs.forEach(orb => { orb.pulse += 0.1; });
            gameState.catchers.forEach(c => { if (c.spawnProgress < 1) c.spawnProgress += 0.01; }); // Slower appear
            gameState.particles = gameState.particles.filter(p => { p.x += p.vx; p.y += p.vy; p.vy += p.gravity || 0; p.life--; p.rotation = (p.rotation || 0) + (p.spin || 0); return p.life > 0; });
            
            for (let i = balls.length - 1; i >= 0; i--) {
                const ball = balls[i];
                if (ball.spawnProgress < 1) { ball.spawnProgress += 0.05; ball.squashX = 0.3 + ball.spawnProgress * 0.7 + Math.sin(ball.spawnProgress * Math.PI) * 0.3; ball.squashY = 0.3 + ball.spawnProgress * 0.7 + Math.sin(ball.spawnProgress * Math.PI + Math.PI/2) * 0.2; continue; }
                if (ball.dying) { ball.deathProgress += 0.06; ball.squashX = ball.deathType === 'explode' ? 1 + ball.deathProgress * 1.5 : 1 + ball.deathProgress * 0.8; ball.squashY = ball.deathType === 'explode' ? 1 - ball.deathProgress * 0.8 : 1 - ball.deathProgress * 0.9; if (ball.deathProgress >= 1) { balls.splice(i, 1); spawnFlingBall(true); } continue; }
                if (ball.isDragging) continue;
                if (ball.glowTimer > 0) ball.glowTimer--;
                ball.squashX += (1 - ball.squashX) * 0.15; ball.squashY += (1 - ball.squashY) * 0.15;
                const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (speed < 0.3) { const a = Math.atan2(ball.vy, ball.vx); ball.vx = Math.cos(a) * 0.5; ball.vy = Math.sin(a) * 0.5; }
                ball.vx *= 0.99; ball.vy *= 0.99; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); ball.rotation += speed * 0.05;
                if (speed > 3) ball.trail.push({ x: ball.x, y: ball.y, life: 20 }); ball.trail = ball.trail.filter(p => p.life-- > 0);
                
                if (speed > 4) {
                    for (let j = gameState.goldenOrbs.length - 1; j >= 0; j--) {
                        const orb = gameState.goldenOrbs[j], dx = ball.x - orb.x, dy = ball.y - orb.y;
                        if (Math.sqrt(dx*dx + dy*dy) < ball.radius + orb.radius + 5) { ball.glowTimer = 60; gameState.score++; for (let k = 0; k < 8; k++) { const a = (Math.PI * 2 / 8) * k; gameState.particles.push({ x: orb.x, y: orb.y, vx: Math.cos(a) * 3, vy: Math.sin(a) * 3, life: 20, color: '#FFD700' }); } orb.x = 150 + Math.random() * (canvas.width - 300); orb.y = 200 + Math.random() * (canvas.height - 400); }
                    }
                    gameState.catchers.forEach(catcher => {
                        if (catcher.spawnProgress < 0.8) return;
                        const dx = ball.x - catcher.x, dy = ball.y - catcher.y;
                        if (Math.sqrt(dx*dx + dy*dy) < ball.radius + catcher.radius && !ball.dying) { ball.dying = true; ball.deathProgress = 0; ball.deathType = Math.random() > 0.5 ? 'explode' : 'squish'; gameState.lives--; addScreenShake(10); for (let k = 0; k < 12; k++) { const a = (Math.PI * 2 / 12) * k; gameState.particles.push({ x: ball.x, y: ball.y, vx: Math.cos(a) * (3 + Math.random() * 3), vy: Math.sin(a) * (3 + Math.random() * 3), life: 35, ballImage: ball.ballImage, radius: ball.radius * 0.2, rotation: Math.random() * Math.PI * 2, spin: (Math.random() - 0.5) * 0.3, gravity: 0.15 }); } }
                    });
                }
                if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.8; ball.squashX = 0.7; ball.squashY = 1.2; }
                if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.8; ball.squashX = 0.7; ball.squashY = 1.2; }
                if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.8; ball.squashX = 1.2; ball.squashY = 0.7; }
                if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.8; ball.squashX = 1.2; ball.squashY = 0.7; }
            }
            ballCollisions();
        }
        
        function drawFling() {
            gameState.catchers.forEach(c => {
                const op = Math.min(1, c.spawnProgress), scale = 0.5 + c.spawnProgress * 0.5;
                ctx.save(); ctx.globalAlpha = op; ctx.translate(c.x, c.y); ctx.scale(scale, scale); ctx.translate(-c.x, -c.y);
                drawStarburst(c.x, c.y, c.radius * 0.5, c.radius + 18, 8, 'rgba(255, 60, 60, 0.3)');
                drawPerson(c.x, c.y + 20, 50, c.personIndex, 1); ctx.restore();
            });
            gameState.goldenOrbs.forEach(orb => { const ps = 1 + Math.sin(orb.pulse) * 0.2; const g = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, orb.radius * ps * 3); g.addColorStop(0, 'rgba(255, 215, 0, 0.6)'); g.addColorStop(1, 'rgba(255, 150, 0, 0)'); ctx.beginPath(); ctx.arc(orb.x, orb.y, orb.radius * ps * 3, 0, Math.PI * 2); ctx.fillStyle = g; ctx.fill(); ctx.beginPath(); ctx.arc(orb.x, orb.y, orb.radius * ps, 0, Math.PI * 2); ctx.fillStyle = '#FFD700'; ctx.fill(); });
            gameState.particles.forEach(p => { if (p.ballImage) { const img = ballImages[p.ballImage - 1]; if (img && img.complete) { ctx.save(); ctx.globalAlpha = p.life / 35; ctx.translate(p.x, p.y); ctx.rotate(p.rotation); ctx.drawImage(img, -p.radius, -p.radius, p.radius * 2, p.radius * 2); ctx.restore(); } } else { ctx.beginPath(); ctx.arc(p.x, p.y, 3 * (p.life / 25), 0, Math.PI * 2); ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 25; ctx.fill(); ctx.globalAlpha = 1; } });
            balls.forEach(ball => { ball.trail.forEach(p => { const a = p.life / 25; ctx.beginPath(); ctx.arc(p.x, p.y, ball.radius * a * 0.5, 0, Math.PI * 2); ctx.fillStyle = ball.glowTimer > 0 ? 'rgba(255, 215, 0, ' + (a * 0.3) + ')' : 'rgba(200, 150, 150, ' + (a * 0.2) + ')'; ctx.fill(); }); if (ball.glowTimer > 0) { const g = ctx.createRadialGradient(ball.x, ball.y, ball.radius * 0.5, ball.x, ball.y, ball.radius * 1.8); g.addColorStop(0, 'rgba(255, 215, 0, ' + (ball.glowTimer / 120) + ')'); g.addColorStop(1, 'rgba(255, 215, 0, 0)'); ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius * 1.8, 0, Math.PI * 2); ctx.fillStyle = g; ctx.fill(); } const op = ball.dying ? (1 - ball.deathProgress) : (ball.spawnProgress < 1 ? ball.spawnProgress : (ball.isDragging ? 0.7 : 1.0)); drawBallWithSquash(ball, op, ball.rotation, ball.squashX, ball.squashY); if (ball.isDragging) { ctx.beginPath(); ctx.moveTo(ball.dragStartX, ball.dragStartY); ctx.lineTo(ball.x, ball.y); ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)'; ctx.lineWidth = 3; ctx.stroke(); } });
            ctx.fillStyle = '#FFD700'; ctx.font = 'bold 24px Arial'; ctx.textAlign = 'left'; ctx.fillText('âœ¦ ' + gameState.score, 20, canvas.height - 80);
            ctx.fillStyle = '#FF6666'; ctx.fillText('â™¥ ' + gameState.lives, 120, canvas.height - 80);
        }
        function flingPointerDown(x, y) { for (let i = balls.length - 1; i >= 0; i--) { if (contains(balls[i], x, y) && !balls[i].dying && balls[i].spawnProgress >= 1) { gameState.draggedBall = balls[i]; balls[i].isDragging = true; balls[i].dragStartX = x; balls[i].dragStartY = y; break; } } }
        function flingPointerMove(x, y) { if (!gameState.draggedBall) return; const ball = gameState.draggedBall, pad = ball.radius + 10; ball.x = Math.max(pad, Math.min(canvas.width - pad, x)); ball.y = Math.max(pad, Math.min(canvas.height - pad, y)); }
        function flingPointerUp() { if (!gameState.draggedBall) return; const ball = gameState.draggedBall; ball.vx = (ball.dragStartX - ball.x) * 0.3; ball.vy = (ball.dragStartY - ball.y) * 0.3; capSpeed(ball); ball.isDragging = false; gameState.draggedBall = null; }
        
        // GAME 2: PADDLE - toned down squash/stretch
        function initPaddle() {
            balls = []; gameState = { mouseX: canvas.width/2, mouseY: canvas.height/2, lastMouseX: canvas.width/2, lastMouseY: canvas.height/2, personIndex: getNextPersonImage(), energy: 100 };
            for (let i = 0; i < 15; i++) { const a = Math.random() * Math.PI * 2, s = 2 + Math.random() * 2; balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a) * s, vy: Math.sin(a) * s, radius: 35 + Math.random() * 20, rotation: Math.random() * Math.PI * 2, ballImage: getNextBallImage(), lastHitTime: Date.now(), sleepy: false, fadeProgress: 0, squashX: 1, squashY: 1 }); }
        }
        function updatePaddle() {
            const mVx = gameState.mouseX - gameState.lastMouseX, mVy = gameState.mouseY - gameState.lastMouseY;
            let sleepyCount = 0;
            for (let i = balls.length - 1; i >= 0; i--) {
                const ball = balls[i]; ball.vy += 0.05; const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                ball.vx *= 0.995; ball.vy *= 0.995; ball.x += ball.vx; ball.y += ball.vy; ball.rotation += speed * 0.02; capSpeed(ball);
                ball.squashX += (1 - ball.squashX) * 0.06; ball.squashY += (1 - ball.squashY) * 0.06; // Slower recovery
                if (speed < 1.5 && Date.now() - ball.lastHitTime > 3000) { ball.sleepy = true; ball.fadeProgress += 0.008; sleepyCount++; if (ball.fadeProgress >= 1) { balls.splice(i, 1); const a = Math.random() * Math.PI * 2, ns = 3 + Math.random() * 2; balls.push({ x: Math.random() * canvas.width, y: 100, vx: Math.cos(a) * ns, vy: Math.sin(a) * ns, radius: 35 + Math.random() * 20, rotation: 0, ballImage: getNextBallImage(), lastHitTime: Date.now(), sleepy: false, fadeProgress: 0, squashX: 1, squashY: 1 }); continue; } }
                else { ball.sleepy = false; ball.fadeProgress = Math.max(0, ball.fadeProgress - 0.02); ball.lastHitTime = Date.now(); }
                if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.9; ball.squashX = 0.9; ball.squashY = 1.1; }
                if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.9; ball.squashX = 0.9; ball.squashY = 1.1; }
                if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.9; ball.squashX = 1.1; ball.squashY = 0.9; }
                if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.9; ball.squashX = 1.1; ball.squashY = 0.9; }
                const dx = ball.x - gameState.mouseX, dy = ball.y - gameState.mouseY, dist = Math.sqrt(dx * dx + dy * dy), padR = 45;
                if (dist < ball.radius + padR) { const mSpeed = Math.sqrt(mVx * mVx + mVy * mVy), force = Math.min(mSpeed * 0.5, 15), ang = Math.atan2(dy, dx); ball.vx += Math.cos(ang) * force; ball.vy += Math.sin(ang) * force; ball.squashX = 0.88; ball.squashY = 1.08; const overlap = (ball.radius + padR) - dist; ball.x += Math.cos(ang) * overlap; ball.y += Math.sin(ang) * overlap; ball.lastHitTime = Date.now(); ball.sleepy = false; if (force > 3) addScreenShake(force * 0.3); capSpeed(ball); }
            }
            gameState.energy = Math.max(0, 100 - sleepyCount * 15);
            for (let i = 0; i < balls.length; i++) { for (let j = i + 1; j < balls.length; j++) { const b1 = balls[i], b2 = balls[j], dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), minDist = b1.radius + b2.radius; if (dist < minDist) { const ang = Math.atan2(dy, dx), tx = b1.x + Math.cos(ang) * minDist, ty = b1.y + Math.sin(ang) * minDist, ax = (tx - b2.x) * 0.05, ay = (ty - b2.y) * 0.05; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; b1.squashX = 0.95; b1.squashY = 1.05; b2.squashX = 0.95; b2.squashY = 1.05; } } }
            gameState.lastMouseX = gameState.mouseX; gameState.lastMouseY = gameState.mouseY;
        }
        function drawPaddle() { balls.forEach(ball => { const op = 1 - ball.fadeProgress; if (ball.sleepy) { ctx.fillStyle = 'rgba(100, 100, 200, ' + (0.3 * op) + ')'; ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.fillText('ðŸ’¤', ball.x, ball.y - ball.radius - 10); } drawBallWithSquash(ball, op, ball.rotation, ball.squashX, ball.squashY); }); drawPerson(gameState.mouseX, gameState.mouseY + 25, 60, gameState.personIndex); ctx.beginPath(); ctx.arc(gameState.mouseX, gameState.mouseY, 45, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)'; ctx.lineWidth = 3; ctx.stroke(); const bW = 150, bH = 12, bX = 20, bY = canvas.height - 85; ctx.fillStyle = '#ddd'; ctx.fillRect(bX, bY, bW, bH); ctx.fillStyle = gameState.energy > 50 ? '#4CAF50' : gameState.energy > 25 ? '#FFC107' : '#F44336'; ctx.fillRect(bX, bY, bW * (gameState.energy / 100), bH); ctx.strokeStyle = '#999'; ctx.lineWidth = 2; ctx.strokeRect(bX, bY, bW, bH); ctx.fillStyle = '#666'; ctx.font = '14px Arial'; ctx.textAlign = 'left'; ctx.fillText('Energy', bX, bY - 5); }
        function paddlePointerMove(x, y) { gameState.mouseX = x; gameState.mouseY = y; }
        
        // GAME 3: POP - no score
        function initPop() { balls = []; gameState = { particles: [] }; for (let i = 0; i < 8; i++) { const a = Math.random() * Math.PI * 2, s = 0.8 + Math.random() * 0.8; balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a) * s, vy: Math.sin(a) * s, radius: 90 + Math.random() * 30, popping: false, popProgress: 0, opacity: 1, rotation: Math.random() * Math.PI * 2, ballImage: getNextBallImage() }); } }
        function updatePop() { gameState.particles = gameState.particles.filter(p => { p.x += p.vx; p.y += p.vy; p.vy += p.gravity || 0.1; p.life--; p.rotation = (p.rotation || 0) + (p.spin || 0); return p.life > 0; }); for (let i = balls.length - 1; i >= 0; i--) { const ball = balls[i]; if (ball.popping) { ball.popProgress += 0.12; ball.opacity = 1 - ball.popProgress; if (ball.popProgress >= 1) balls.splice(i, 1); continue; } const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy); if (speed < 0.5) { const a = Math.atan2(ball.vy, ball.vx); ball.vx = Math.cos(a) * 0.8; ball.vy = Math.sin(a) * 0.8; } ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; ball.rotation += speed * 0.01; capSpeed(ball); if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.9; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.9; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.9; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.9; } } ballCollisions(); }
        function drawPop() { gameState.particles.forEach(p => { const img = ballImages[p.ballImage - 1]; if (img && img.complete) { ctx.save(); ctx.globalAlpha = p.life / p.maxLife; ctx.translate(p.x, p.y); ctx.rotate(p.rotation); ctx.drawImage(img, -p.size/2, -p.size/2, p.size, p.size); ctx.restore(); } }); balls.forEach(ball => { ctx.save(); ctx.globalAlpha = ball.opacity; if (ball.popping) { const sc = 1 + ball.popProgress * 0.8; ctx.translate(ball.x, ball.y); ctx.scale(sc, sc); ctx.rotate(ball.popProgress * 0.5); ctx.translate(-ball.x, -ball.y); } drawBall(ball, 1.0, ball.rotation); ctx.restore(); }); }
        function popPointerDown(x, y) { for (let i = balls.length - 1; i >= 0; i--) { if (!balls[i].popping && contains(balls[i], x, y)) { const ball = balls[i]; ball.popping = true; addScreenShake(ball.radius * 0.08); const nP = Math.floor(ball.radius * 0.25); for (let j = 0; j < nP; j++) { const a = Math.random() * Math.PI * 2, sp = 3 + Math.random() * 5; gameState.particles.push({ x: ball.x, y: ball.y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 2, size: 8 + Math.random() * 15, life: 40, maxLife: 40, rotation: Math.random() * Math.PI, spin: (Math.random() - 0.5) * 0.2, gravity: 0.15, ballImage: ball.ballImage }); } if (ball.radius > 25) { const cR = ball.radius * 0.55, nC = 2 + Math.floor(Math.random() * 2); for (let j = 0; j < nC; j++) { const a = (Math.PI * 2 / nC) * j + Math.random() * 0.5, sp = 4 + Math.random() * 4; balls.push({ x: ball.x, y: ball.y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp, radius: cR, popping: false, popProgress: 0, opacity: 1, rotation: Math.random() * Math.PI * 2, ballImage: getNextBallImage() }); } } break; } } }
        
        // GAME 4: VACUUM - tiny squash/stretch
        function initVacuum() { balls = []; gameState = { mouseX: canvas.width/2, mouseY: canvas.height/2, isVacuuming: false, vacuumStrength: 0 }; for (let i = 0; i < 25; i++) balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3, radius: 30 + Math.random() * 25, ballImage: getNextBallImage(), squashX: 1, squashY: 1 }); }
        function updateVacuum() {
            if (gameState.isVacuuming) gameState.vacuumStrength = Math.min(gameState.vacuumStrength + 3, 100);
            balls.forEach(ball => {
                if (gameState.isVacuuming) { const dx = gameState.mouseX - ball.x, dy = gameState.mouseY - ball.y, dist = Math.sqrt(dx * dx + dy * dy), force = Math.min(gameState.vacuumStrength / (dist + 30), 4); ball.vx += (dx / dist) * force; ball.vy += (dy / dist) * force; }
                if (ball.x < canvas.width / 2) ball.vx -= 0.15; else ball.vx += 0.15;
                ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball);
                ball.squashX += (1 - ball.squashX) * 0.1; ball.squashY += (1 - ball.squashY) * 0.1;
                if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.9; ball.squashX = 0.92; ball.squashY = 1.08; }
                if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.9; ball.squashX = 0.92; ball.squashY = 1.08; }
                if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.9; ball.squashX = 1.08; ball.squashY = 0.92; }
                if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.9; ball.squashX = 1.08; ball.squashY = 0.92; }
            });
            for (let i = 0; i < balls.length; i++) { for (let j = i + 1; j < balls.length; j++) { const b1 = balls[i], b2 = balls[j], dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), minDist = b1.radius + b2.radius; if (dist < minDist) { const ang = Math.atan2(dy, dx), ax = (minDist - dist) * Math.cos(ang) * 0.05, ay = (minDist - dist) * Math.sin(ang) * 0.05; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; b1.squashX = 0.94; b1.squashY = 1.06; b2.squashX = 0.94; b2.squashY = 1.06; } } }
        }
        function drawVacuum() { if (gameState.isVacuuming) { const maxR = 150; for (let i = 0; i < 3; i++) { ctx.beginPath(); const r = maxR * (1 - i * 0.3) * (gameState.vacuumStrength / 100); ctx.arc(gameState.mouseX, gameState.mouseY, r, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(100, 100, 100, ' + (0.3 - i * 0.1) + ')'; ctx.lineWidth = 3; ctx.stroke(); } ctx.beginPath(); ctx.arc(gameState.mouseX, gameState.mouseY, 10, 0, Math.PI * 2); ctx.fillStyle = '#666'; ctx.fill(); } balls.forEach(ball => drawBallWithSquash(ball, 1, 0, ball.squashX, ball.squashY)); }
        function vacuumPointerDown(x, y) { gameState.mouseX = x; gameState.mouseY = y; gameState.isVacuuming = true; gameState.vacuumStrength = 0; }
        function vacuumPointerMove(x, y) { gameState.mouseX = x; gameState.mouseY = y; }
        function vacuumPointerUp() { if (gameState.isVacuuming) { addScreenShake(gameState.vacuumStrength * 0.1); balls.forEach(ball => { const dx = ball.x - gameState.mouseX, dy = ball.y - gameState.mouseY, dist = Math.sqrt(dx * dx + dy * dy), force = Math.min(5000 / (dist + 50), 20); ball.vx += (dx / dist) * force; ball.vy += (dy / dist) * force; ball.squashX = 0.85; ball.squashY = 1.15; capSpeed(ball); }); gameState.isVacuuming = false; gameState.vacuumStrength = 0; } }
        
        // GAME 5: GRAVITY FLIP - tiny squash/stretch
        function initGravityFlip() { balls = []; gameState = { gravityDir: 1 }; for (let i = 0; i < 18; i++) balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, radius: 25 + Math.random() * 20, ballImage: getNextBallImage(), squashX: 1, squashY: 1 }); }
        function updateGravityFlip() {
            balls.forEach(ball => {
                ball.vy += 0.25 * gameState.gravityDir; ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball);
                ball.squashX += (1 - ball.squashX) * 0.1; ball.squashY += (1 - ball.squashY) * 0.1;
                if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.75; ball.squashX = 0.92; ball.squashY = 1.08; }
                if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.75; ball.squashX = 0.92; ball.squashY = 1.08; }
                if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.75; ball.squashX = 1.08; ball.squashY = 0.92; }
                if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.75; ball.squashX = 1.08; ball.squashY = 0.92; }
            });
            for (let i = 0; i < balls.length; i++) { for (let j = i + 1; j < balls.length; j++) { const b1 = balls[i], b2 = balls[j], dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), minDist = b1.radius + b2.radius; if (dist < minDist) { const ang = Math.atan2(dy, dx), ax = (minDist - dist) * Math.cos(ang) * 0.05, ay = (minDist - dist) * Math.sin(ang) * 0.05; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; b1.squashX = 0.94; b1.squashY = 1.06; b2.squashX = 0.94; b2.squashY = 1.06; } } }
        }
        function drawGravityFlip() { balls.forEach(ball => drawBallWithSquash(ball, 1, 0, ball.squashX, ball.squashY)); const aY = gameState.gravityDir === 1 ? canvas.height - 30 : 30; ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; ctx.font = 'bold 24px Arial'; ctx.textAlign = 'center'; ctx.fillText(gameState.gravityDir === 1 ? 'â†“' : 'â†‘', canvas.width / 2, aY); }
        function gravityFlipPointerDown() { gameState.gravityDir *= -1; addScreenShake(4); }
        
        // GAME 6: DRAW BARRIERS
        function initDrawBarriers() { balls = []; gameState = { barriers: [], drawing: false, drawStart: null, drawEnd: null, splats: [], saved: 0, lost: 0, maxBarriers: 5, maxLineLength: 250, barrierLifetime: 12000 }; for (let i = 0; i < 4; i++) spawnBarrierBall(); }
        function spawnBarrierBall() { balls.push({ x: 100 + Math.random() * (canvas.width - 200), y: -50, vx: (Math.random() - 0.5) * 2, vy: 0.8 + Math.random() * 0.5, radius: 25 + Math.random() * 20, ballImage: getNextBallImage(), dying: false, deathProgress: 0 }); }
        function updateDrawBarriers() {
            gameState.barriers = gameState.barriers.filter(b => Date.now() - b.created < gameState.barrierLifetime);
            gameState.splats = gameState.splats.filter(s => s.life > 0); gameState.splats.forEach(s => s.life--);
            for (let i = balls.length - 1; i >= 0; i--) { const ball = balls[i]; if (ball.dying) { ball.deathProgress += 0.08; if (ball.deathProgress >= 1) { balls.splice(i, 1); spawnBarrierBall(); gameState.lost++; } continue; } ball.vy += 0.06; ball.vx *= 0.99; ball.vy *= 0.99; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (ball.y + ball.radius >= canvas.height - 5 && !ball.dying) { ball.dying = true; ball.deathProgress = 0; addScreenShake(5); gameState.splats.push({ x: ball.x, y: canvas.height, radius: ball.radius, life: 120, color: 'hsl(' + (Math.random() * 360) + ', 60%, 50%)' }); continue; } if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -1; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -1; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -1; } gameState.barriers.forEach(barrier => { const result = lineCircleCollision(barrier.x1, barrier.y1, barrier.x2, barrier.y2, ball.x, ball.y, ball.radius); if (result.collides) { ball.x = result.newX; ball.y = result.newY; const ang = Math.atan2(barrier.y2 - barrier.y1, barrier.x2 - barrier.x1), nAng = ang + Math.PI / 2, dot = ball.vx * Math.cos(nAng) + ball.vy * Math.sin(nAng); ball.vx -= 2 * dot * Math.cos(nAng) * 1.1; ball.vy -= 2 * dot * Math.sin(nAng) * 1.1; capSpeed(ball); gameState.saved++; } }); }
            ballCollisions();
        }
        function drawDrawBarriers() {
            gameState.splats.forEach(splat => { const a = splat.life / 120, sq = 1 + (1 - a) * 2; ctx.save(); ctx.globalAlpha = a * 0.6; ctx.translate(splat.x, splat.y); ctx.scale(sq, 0.3); ctx.beginPath(); ctx.arc(0, 0, splat.radius, 0, Math.PI * 2); ctx.fillStyle = splat.color; ctx.fill(); ctx.restore(); });
            balls.forEach(ball => { if (ball.dying) { ctx.save(); const sqY = 1 - ball.deathProgress * 0.8, sqX = 1 + ball.deathProgress * 0.5; ctx.translate(ball.x, canvas.height); ctx.scale(sqX, sqY); ctx.translate(-ball.x, -canvas.height); ctx.globalAlpha = 1 - ball.deathProgress; drawBall({...ball, y: canvas.height - ball.radius * sqY}); ctx.restore(); } else drawBall(ball); });
            gameState.barriers.forEach(barrier => { const age = Date.now() - barrier.created, op = Math.max(0, 1 - age / gameState.barrierLifetime); ctx.save(); ctx.shadowColor = 'rgba(100, 180, 255, 0.8)'; ctx.shadowBlur = 15 * op; ctx.beginPath(); ctx.moveTo(barrier.x1, barrier.y1); ctx.lineTo(barrier.x2, barrier.y2); ctx.strokeStyle = 'rgba(80, 150, 220, ' + op + ')'; ctx.lineWidth = 8; ctx.lineCap = 'round'; ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.moveTo(barrier.x1, barrier.y1); ctx.lineTo(barrier.x2, barrier.y2); ctx.strokeStyle = 'rgba(255, 255, 255, ' + (op * 0.9) + ')'; ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.stroke(); });
            if (gameState.drawing && gameState.drawStart) { let dx = gameState.drawEnd.x - gameState.drawStart.x, dy = gameState.drawEnd.y - gameState.drawStart.y, len = Math.sqrt(dx * dx + dy * dy); if (len > gameState.maxLineLength) { dx = (dx / len) * gameState.maxLineLength; dy = (dy / len) * gameState.maxLineLength; } const endX = gameState.drawStart.x + dx, endY = gameState.drawStart.y + dy; ctx.save(); ctx.shadowColor = 'rgba(100, 180, 255, 0.5)'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.moveTo(gameState.drawStart.x, gameState.drawStart.y); ctx.lineTo(endX, endY); ctx.strokeStyle = len > gameState.maxLineLength ? 'rgba(255, 100, 100, 0.5)' : 'rgba(80, 150, 220, 0.5)'; ctx.lineWidth = 8; ctx.lineCap = 'round'; ctx.stroke(); ctx.restore(); }
            ctx.fillStyle = '#666'; ctx.font = 'bold 18px Arial'; ctx.textAlign = 'left'; ctx.fillText('Saved: ' + gameState.saved + '  Lost: ' + gameState.lost, 20, canvas.height - 85);
            const rem = gameState.maxBarriers - gameState.barriers.length; ctx.fillStyle = rem > 0 ? '#4A4' : '#A44'; ctx.fillText('Lines: ' + rem + '/' + gameState.maxBarriers, 20, canvas.height - 60);
        }
        function barrierPointerDown(x, y) { if (gameState.barriers.length >= gameState.maxBarriers) return; gameState.drawing = true; gameState.drawStart = { x, y }; gameState.drawEnd = { x, y }; }
        function barrierPointerMove(x, y) { if (gameState.drawing) gameState.drawEnd = { x, y }; }
        function barrierPointerUp() { if (gameState.drawing && gameState.drawStart && gameState.drawEnd) { let dx = gameState.drawEnd.x - gameState.drawStart.x, dy = gameState.drawEnd.y - gameState.drawStart.y, len = Math.sqrt(dx * dx + dy * dy); if (len > 20) { if (len > gameState.maxLineLength) { dx = (dx / len) * gameState.maxLineLength; dy = (dy / len) * gameState.maxLineLength; } gameState.barriers.push({ x1: gameState.drawStart.x, y1: gameState.drawStart.y, x2: gameState.drawStart.x + dx, y2: gameState.drawStart.y + dy, created: Date.now() }); } } gameState.drawing = false; gameState.drawStart = null; gameState.drawEnd = null; }
        
        // GAME 7: MAGNET ZONES - slower rotation
        function initMagnetZones() { balls = []; gameState = { magnets: [], shiftPressed: false }; for (let i = 0; i < 20; i++) balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3, radius: 18 + Math.random() * 15, ballImage: getNextBallImage() }); }
        function updateMagnetZones() { gameState.magnets = gameState.magnets.filter(m => Date.now() - m.created < 10000); balls.forEach(ball => { ball.vy += 0.15; gameState.magnets.forEach(magnet => { const dx = magnet.x - ball.x, dy = magnet.y - ball.y, dist = Math.sqrt(dx * dx + dy * dy), force = (magnet.type === 'attract' ? 1 : -1) * Math.min(200 / (dist + 20), 4); ball.vx += (dx / dist) * force; ball.vy += (dy / dist) * force; }); ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.7; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.7; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.7; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.7; } }); ballCollisions(); }
        function drawMagnetZones() {
            gameState.magnets.forEach(magnet => {
                const age = Date.now() - magnet.created, op = Math.max(0, 1 - age / 10000), isAttr = magnet.type === 'attract', time = Date.now() * 0.0015; // Slower rotation
                if (isAttr) { for (let i = 0; i < 4; i++) { const bR = 100 - ((time * 30 + i * 25) % 100); ctx.beginPath(); ctx.arc(magnet.x, magnet.y, bR, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(50, 150, 255, ' + (op * (0.5 - i * 0.1)) + ')'; ctx.lineWidth = 3; ctx.stroke(); } const g = ctx.createRadialGradient(magnet.x, magnet.y, 0, magnet.x, magnet.y, 60); g.addColorStop(0, 'rgba(50, 150, 255, ' + (op * 0.4) + ')'); g.addColorStop(1, 'rgba(50, 150, 255, 0)'); ctx.beginPath(); ctx.arc(magnet.x, magnet.y, 60, 0, Math.PI * 2); ctx.fillStyle = g; ctx.fill(); }
                else { for (let i = 0; i < 4; i++) { const bR = 20 + ((time * 30 + i * 25) % 100); ctx.beginPath(); ctx.arc(magnet.x, magnet.y, bR, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(255, 80, 80, ' + (op * (0.5 - i * 0.1)) + ')'; ctx.lineWidth = 3; ctx.stroke(); } const g = ctx.createRadialGradient(magnet.x, magnet.y, 0, magnet.x, magnet.y, 60); g.addColorStop(0, 'rgba(255, 80, 80, ' + (op * 0.4) + ')'); g.addColorStop(1, 'rgba(255, 80, 80, 0)'); ctx.beginPath(); ctx.arc(magnet.x, magnet.y, 60, 0, Math.PI * 2); ctx.fillStyle = g; ctx.fill(); }
                drawPerson(magnet.x, magnet.y + 80, 55, magnet.personIndex, op);
                ctx.font = 'bold 28px Arial'; ctx.textAlign = 'center'; ctx.fillStyle = isAttr ? 'rgba(50, 150, 255, ' + op + ')' : 'rgba(255, 80, 80, ' + op + ')'; ctx.fillText(isAttr ? 'âŠ•' : 'âŠ–', magnet.x, magnet.y - 5);
            });
            balls.forEach(ball => drawBall(ball));
            ctx.fillStyle = '#666'; ctx.font = '14px Arial'; ctx.textAlign = 'left'; ctx.fillText(gameState.shiftPressed ? 'Mode: REPEL (red)' : 'Mode: ATTRACT (blue) [hold SHIFT for repel]', 20, canvas.height - 80);
        }
        function magnetPointerDown(x, y) { gameState.magnets.push({ x, y, type: gameState.shiftPressed ? 'repel' : 'attract', created: Date.now(), personIndex: getNextPersonImage() }); }
        
        // GAME 8: EXPLODE
        function initExplode() { balls = []; gameState = { chargeStart: 0, charging: false, chargeX: 0, chargeY: 0, totalBalls: 0 }; }
        function updateExplode() { for (let i = balls.length - 1; i >= 0; i--) { const ball = balls[i]; ball.vy += 0.2; ball.vx *= 0.99; ball.vy *= 0.99; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); ball.life--; ball.opacity = Math.min(1, ball.life / 60); if (ball.life <= 0 || ball.y > canvas.height + 50) { balls.splice(i, 1); continue; } if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.7; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.7; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.7; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.7; } } ballCollisions(); }
        function drawExplode() { if (gameState.charging) { const cT = Date.now() - gameState.chargeStart, cA = Math.min(cT / 1000, 1), r = 20 + cA * 60, pulse = Math.sin(Date.now() * 0.02) * 5; ctx.beginPath(); ctx.arc(gameState.chargeX, gameState.chargeY, r + pulse, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(100, 100, 100, ' + (0.3 + cA * 0.4) + ')'; ctx.lineWidth = 3 + cA * 3; ctx.stroke(); ctx.beginPath(); ctx.arc(gameState.chargeX, gameState.chargeY, r * 0.3, 0, Math.PI * 2); ctx.fillStyle = 'rgba(80, 80, 80, ' + (0.3 + cA * 0.5) + ')'; ctx.fill(); ctx.fillStyle = '#666'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.fillText(Math.floor(cA * 100) + '%', gameState.chargeX, gameState.chargeY + r + 25); } balls.forEach(ball => { ctx.save(); ctx.globalAlpha = ball.opacity; drawBall(ball); ctx.restore(); }); ctx.fillStyle = '#666'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'left'; ctx.fillText('Balls launched: ' + gameState.totalBalls, 20, canvas.height - 80); }
        function explodePointerDown(x, y) { gameState.charging = true; gameState.chargeStart = Date.now(); gameState.chargeX = x; gameState.chargeY = y; }
        function explodePointerUp() { if (!gameState.charging) return; const cT = Date.now() - gameState.chargeStart, cA = Math.min(cT / 1000, 1), power = 5 + cA * 12, numBalls = Math.floor(8 + cA * 12); addScreenShake(cA * 10); for (let i = 0; i < numBalls; i++) { const ang = (Math.PI * 2 / numBalls) * i + Math.random() * 0.2, sV = 0.7 + Math.random() * 0.6; balls.push({ x: gameState.chargeX, y: gameState.chargeY, vx: Math.cos(ang) * power * sV, vy: Math.sin(ang) * power * sV, radius: 12 + Math.random() * 18, life: 150 + Math.random() * 100, opacity: 1, ballImage: getNextBallImage() }); gameState.totalBalls++; } gameState.charging = false; }
        
        // GAME 9: ORBITAL
        function initOrbital() { balls = []; gameState = { mouseX: canvas.width/2, mouseY: canvas.height/2 }; for (let i = 0; i < 40; i++) { const ang = (Math.PI * 2 / 40) * i, dist = 60 + Math.random() * 180; balls.push({ angle: ang, distance: dist, angleSpeed: (0.02 + Math.random() * 0.04) * (Math.random() > 0.5 ? 1 : -1), radius: 15 + Math.random() * 18, orbiting: true, vx: 0, vy: 0, x: 0, y: 0, ballImage: getNextBallImage() }); } }
        function updateOrbital() { balls.forEach(ball => { if (ball.orbiting) { ball.angle += ball.angleSpeed; ball.x = gameState.mouseX + Math.cos(ball.angle) * ball.distance; ball.y = gameState.mouseY + Math.sin(ball.angle) * ball.distance; } else { ball.vy += 0.2; ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.7; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.7; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.7; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.7; } } }); const freeBalls = balls.filter(b => !b.orbiting); for (let i = 0; i < freeBalls.length; i++) { for (let j = i + 1; j < freeBalls.length; j++) { const b1 = freeBalls[i], b2 = freeBalls[j], dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), minDist = b1.radius + b2.radius; if (dist < minDist) { const ang = Math.atan2(dy, dx), ax = (minDist - dist) * Math.cos(ang) * 0.05, ay = (minDist - dist) * Math.sin(ang) * 0.05; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; } } } }
        function drawOrbital() { balls.filter(b => b.orbiting).forEach(ball => { ctx.beginPath(); ctx.arc(gameState.mouseX, gameState.mouseY, ball.distance, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(200, 200, 200, 0.2)'; ctx.lineWidth = 1; ctx.stroke(); }); balls.forEach(ball => drawBall(ball, ball.orbiting ? 0.8 : 1.0)); ctx.beginPath(); ctx.arc(gameState.mouseX, gameState.mouseY, 5, 0, Math.PI * 2); ctx.fillStyle = '#999'; ctx.fill(); }
        function orbitalPointerMove(x, y) { gameState.mouseX = x; gameState.mouseY = y; }
        function orbitalPointerDown() { balls.forEach(ball => { if (ball.orbiting) { ball.orbiting = false; const tS = Math.abs(ball.angleSpeed) * ball.distance * 2; ball.vx = Math.cos(ball.angle + Math.PI / 2) * tS + Math.cos(ball.angle) * 8; ball.vy = Math.sin(ball.angle + Math.PI / 2) * tS + Math.sin(ball.angle) * 8; capSpeed(ball); } }); }
        
        // GAME 10: TRANSFORM
        function initTransform() { balls = []; gameState = { score: 0, breaches: 0, centerRadius: 120, centerX: canvas.width / 2, centerY: canvas.height / 2, centerVx: 0.5, centerVy: 0.3, boredomThreshold: 300 }; for (let i = 0; i < 15; i++) spawnTransformBall(); }
        function spawnTransformBall() { const side = Math.floor(Math.random() * 4); let x, y, vx, vy; switch(side) { case 0: x = Math.random() * canvas.width; y = -30; vx = (Math.random() - 0.5) * 2; vy = 1.5 + Math.random(); break; case 1: x = canvas.width + 30; y = Math.random() * canvas.height; vx = -1.5 - Math.random(); vy = (Math.random() - 0.5) * 2; break; case 2: x = Math.random() * canvas.width; y = canvas.height + 30; vx = (Math.random() - 0.5) * 2; vy = -1.5 - Math.random(); break; case 3: x = -30; y = Math.random() * canvas.height; vx = 1.5 + Math.random(); vy = (Math.random() - 0.5) * 2; break; } balls.push({ x, y, vx, vy, radius: 25 + Math.random() * 20, ballImage: getNextBallImage(), peopleImage: getNextPersonImage(), isGuard: false, breached: false, guardTime: 0, boredom: 0 }); }
        function updateTransform() { gameState.centerX += gameState.centerVx; gameState.centerY += gameState.centerVy; const margin = gameState.centerRadius + 50; if (gameState.centerX < margin || gameState.centerX > canvas.width - margin) gameState.centerVx *= -1; if (gameState.centerY < margin || gameState.centerY > canvas.height - margin) gameState.centerVy *= -1; for (let i = balls.length - 1; i >= 0; i--) { const ball = balls[i]; if (ball.isGuard) { ball.guardTime++; ball.boredom += 0.5; if (ball.boredom > gameState.boredomThreshold && Math.random() < 0.01) { ball.isGuard = false; ball.boredom = 0; ball.vx = (Math.random() - 0.5) * 4; ball.vy = (Math.random() - 0.5) * 4; continue; } const dx = gameState.centerX - ball.x, dy = gameState.centerY - ball.y, dist = Math.sqrt(dx * dx + dy * dy), patrolDist = gameState.centerRadius + 80; if (dist < patrolDist - 10) { ball.vx -= dx / dist * 0.12; ball.vy -= dy / dist * 0.12; } else if (dist > patrolDist + 10) { ball.vx += dx / dist * 0.12; ball.vy += dy / dist * 0.12; } const perpX = -dy / dist, perpY = dx / dist; ball.vx += perpX * 0.06; ball.vy += perpY * 0.06; ball.vx *= 0.97; ball.vy *= 0.97; ball.x += ball.vx; ball.y += ball.vy; for (let j = balls.length - 1; j >= 0; j--) { if (i === j || balls[j].isGuard) continue; const enemy = balls[j], edx = enemy.x - ball.x, edy = enemy.y - ball.y, eDist = Math.sqrt(edx * edx + edy * edy); if (eDist < ball.radius + enemy.radius + 15) { const ang = Math.atan2(edy, edx); enemy.vx = Math.cos(ang) * 6; enemy.vy = Math.sin(ang) * 6; gameState.score++; ball.boredom = Math.max(0, ball.boredom - 50); addScreenShake(4); } } } else { const dx = gameState.centerX - ball.x, dy = gameState.centerY - ball.y, dist = Math.sqrt(dx * dx + dy * dy); ball.vx += dx / dist * 0.03; ball.vy += dy / dist * 0.03; ball.vx *= 0.99; ball.vy *= 0.99; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (dist < gameState.centerRadius && !ball.breached) { ball.breached = true; gameState.breaches++; addScreenShake(8); } if (ball.x < -100 || ball.x > canvas.width + 100 || ball.y < -100 || ball.y > canvas.height + 100) { balls.splice(i, 1); spawnTransformBall(); } } if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.8; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.8; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.8; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.8; } } }
        function drawTransform() { ctx.beginPath(); ctx.arc(gameState.centerX, gameState.centerY, gameState.centerRadius, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 215, 100, 0.2)'; ctx.fill(); ctx.strokeStyle = 'rgba(255, 180, 50, 0.5)'; ctx.lineWidth = 3; ctx.stroke(); ctx.beginPath(); ctx.arc(gameState.centerX, gameState.centerY, gameState.centerRadius + 80, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(100, 200, 100, 0.2)'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]); balls.forEach(ball => { if (ball.isGuard) { drawPerson(ball.x, ball.y + ball.radius, ball.radius * 2.5, ball.peopleImage); const bR = ball.boredom / gameState.boredomThreshold; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius + 20, 0, Math.PI * 2); ctx.strokeStyle = bR > 0.7 ? 'rgba(200, 200, 100, 0.4)' : 'rgba(100, 200, 100, 0.4)'; ctx.lineWidth = 2; ctx.stroke(); if (bR > 0.5) { ctx.fillStyle = 'rgba(200, 200, 100, ' + bR + ')'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.fillText('ðŸ˜´', ball.x, ball.y - ball.radius - 15); } } else drawBall(ball, ball.breached ? 0.5 : 1.0); }); ctx.fillStyle = '#4A4'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'left'; ctx.fillText('Deflected: ' + gameState.score, 20, canvas.height - 85); ctx.fillStyle = '#A44'; ctx.fillText('Breached: ' + gameState.breaches, 20, canvas.height - 60); ctx.fillStyle = '#666'; ctx.fillText('Guards: ' + balls.filter(b => b.isGuard).length, 200, canvas.height - 85); }
        function transformPointerDown(x, y) { for (let i = balls.length - 1; i >= 0; i--) { if (contains(balls[i], x, y)) { balls[i].isGuard = !balls[i].isGuard; balls[i].boredom = 0; break; } } }
        
        // GAME 11: CONNECTIONS - bigger click radius, hover effect, more explosion juice
        function initConnections() { balls = []; gameState = { connections: [], firstEntity: null, hoveredEntity: null, score: 0, exploded: 0, particles: [] }; for (let i = 0; i < 8; i++) { const a = Math.random() * Math.PI * 2, s = 1.5 + Math.random() * 1.5; balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a) * s, vy: Math.sin(a) * s, radius: 25 + Math.random() * 15, ballImage: getNextBallImage(), type: 'ball' }); } for (let i = 0; i < 8; i++) { const a = Math.random() * Math.PI * 2, s = 1 + Math.random(); balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a) * s, vy: Math.sin(a) * s, radius: 35, clickRadius: 50, personImage: getNextPersonImage(), type: 'person' }); } }
        function updateConnections() {
            gameState.particles = gameState.particles.filter(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.15; p.life--; p.rotation += p.spin || 0; p.scale *= 0.98; return p.life > 0; });
            gameState.connections.forEach(conn => { const b1 = conn.entity1, b2 = conn.entity2; if (!balls.includes(b1) || !balls.includes(b2)) return; const dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), stretch = dist - conn.restLength, force = stretch * 0.02, fx = (dx / dist) * force, fy = (dy / dist) * force; b1.vx += fx; b1.vy += fy; b2.vx -= fx; b2.vy -= fy; });
            balls.forEach(ball => { const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy); if (speed < 0.3) { const a = Math.atan2(ball.vy, ball.vx); ball.vx = Math.cos(a) * 0.8; ball.vy = Math.sin(a) * 0.8; } ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.8; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.8; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.8; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.8; } });
            for (let i = 0; i < balls.length; i++) { for (let j = i + 1; j < balls.length; j++) { const b1 = balls[i], b2 = balls[j], dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), minDist = b1.radius + b2.radius; if (dist < minDist && dist > 0) { const ang = Math.atan2(dy, dx), ax = (minDist - dist) * Math.cos(ang) * 0.05, ay = (minDist - dist) * Math.sin(ang) * 0.05; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; } } }
        }
        function drawConnections() {
            gameState.particles.forEach(p => { ctx.save(); ctx.globalAlpha = p.life / p.maxLife; ctx.translate(p.x, p.y); ctx.rotate(p.rotation); ctx.scale(p.scale, p.scale); if (p.type === 'circle') { ctx.beginPath(); ctx.arc(0, 0, p.size, 0, Math.PI * 2); ctx.fillStyle = p.color; ctx.fill(); } else { ctx.fillStyle = p.color; ctx.font = p.size + 'px Arial'; ctx.textAlign = 'center'; ctx.fillText(p.emoji, 0, 0); } ctx.restore(); });
            gameState.connections.forEach(conn => { if (!balls.includes(conn.entity1) || !balls.includes(conn.entity2)) return; ctx.beginPath(); ctx.moveTo(conn.entity1.x, conn.entity1.y); ctx.lineTo(conn.entity2.x, conn.entity2.y); ctx.strokeStyle = 'rgba(100, 200, 100, 0.6)'; ctx.lineWidth = 3; ctx.stroke(); });
            balls.forEach(entity => {
                const isSel = gameState.firstEntity === entity, isHov = gameState.hoveredEntity === entity;
                if (entity.type === 'person') {
                    if (isSel || isHov) { ctx.beginPath(); ctx.arc(entity.x, entity.y, entity.clickRadius + 5, 0, Math.PI * 2); ctx.strokeStyle = isSel ? 'rgba(100, 200, 255, 0.8)' : 'rgba(200, 200, 200, 0.5)'; ctx.lineWidth = isSel ? 4 : 2; ctx.stroke(); }
                    drawPerson(entity.x, entity.y + 10, 55, entity.personImage);
                } else {
                    if (isSel || isHov) { ctx.beginPath(); ctx.arc(entity.x, entity.y, entity.radius + 8, 0, Math.PI * 2); ctx.strokeStyle = isSel ? 'rgba(100, 200, 255, 0.8)' : 'rgba(200, 200, 200, 0.5)'; ctx.lineWidth = isSel ? 4 : 2; ctx.stroke(); }
                    drawBall(entity);
                }
            });
            ctx.fillStyle = '#4A4'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'left'; ctx.fillText('Connections: ' + gameState.score, 20, canvas.height - 85);
            ctx.fillStyle = '#A44'; ctx.fillText('Exploded: ' + gameState.exploded, 20, canvas.height - 60);
            if (gameState.firstEntity) { ctx.fillStyle = '#666'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; const tT = gameState.firstEntity.type === 'person' ? 'person' : 'ball'; ctx.fillText('Selected: ' + tT + ' - click a ' + (tT === 'person' ? 'ball' : 'person') + ' to connect!', canvas.width / 2, 160); }
        }
        function connectionsPointerMove(x, y) { mouseX = x; mouseY = y; gameState.hoveredEntity = null; for (let i = balls.length - 1; i >= 0; i--) { const entity = balls[i], clickR = entity.clickRadius || entity.radius; const dx = x - entity.x, dy = y - entity.y; if (Math.sqrt(dx*dx + dy*dy) < clickR + 10) { gameState.hoveredEntity = entity; break; } } }
        function connectionsPointerDown(x, y) {
            for (let i = balls.length - 1; i >= 0; i--) { const entity = balls[i], clickR = entity.clickRadius || entity.radius; const dx = x - entity.x, dy = y - entity.y; if (Math.sqrt(dx*dx + dy*dy) < clickR + 10) {
                const clicked = entity;
                if (!gameState.firstEntity) gameState.firstEntity = clicked;
                else if (gameState.firstEntity !== clicked) {
                    if (gameState.firstEntity.type === clicked.type) {
                        // EXPLOSION with more juice!
                        addScreenShake(20);
                        gameState.exploded++;
                        // Spawn lots of particles
                        const cx = (gameState.firstEntity.x + clicked.x) / 2, cy = (gameState.firstEntity.y + clicked.y) / 2;
                        for (let j = 0; j < 20; j++) { const a = Math.random() * Math.PI * 2, sp = 5 + Math.random() * 8; gameState.particles.push({ x: cx, y: cy, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 3, size: 15 + Math.random() * 20, life: 50, maxLife: 50, rotation: Math.random() * Math.PI * 2, spin: (Math.random() - 0.5) * 0.4, scale: 1, type: 'circle', color: 'hsl(' + Math.random() * 360 + ', 80%, 60%)' }); }
                        for (let j = 0; j < 8; j++) { const a = Math.random() * Math.PI * 2, sp = 3 + Math.random() * 5; gameState.particles.push({ x: cx, y: cy, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 2, size: 30 + Math.random() * 20, life: 40, maxLife: 40, rotation: 0, spin: 0, scale: 1, type: 'emoji', emoji: ['ðŸ’¥', 'âœ¨', 'â­', 'ðŸ”¥'][Math.floor(Math.random() * 4)] }); }
                        gameState.connections = gameState.connections.filter(c => c.entity1 !== gameState.firstEntity && c.entity2 !== gameState.firstEntity && c.entity1 !== clicked && c.entity2 !== clicked);
                        const idx1 = balls.indexOf(gameState.firstEntity), idx2 = balls.indexOf(clicked);
                        if (idx1 > idx2) { balls.splice(idx1, 1); balls.splice(idx2, 1); } else { balls.splice(idx2, 1); balls.splice(idx1, 1); }
                        setTimeout(() => { const a1 = Math.random() * Math.PI * 2, a2 = Math.random() * Math.PI * 2; balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a1) * 2, vy: Math.sin(a1) * 2, radius: 25 + Math.random() * 15, ballImage: getNextBallImage(), type: 'ball' }); balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a2) * 1.5, vy: Math.sin(a2) * 1.5, radius: 35, clickRadius: 50, personImage: getNextPersonImage(), type: 'person' }); }, 500);
                    } else {
                        const existingConn = gameState.connections.find(c => (c.entity1 === gameState.firstEntity && c.entity2 === clicked) || (c.entity2 === gameState.firstEntity && c.entity1 === clicked));
                        if (!existingConn) { const dx = clicked.x - gameState.firstEntity.x, dy = clicked.y - gameState.firstEntity.y, dist = Math.sqrt(dx * dx + dy * dy); gameState.connections.push({ entity1: gameState.firstEntity, entity2: clicked, restLength: Math.min(dist, 150) }); gameState.score++; }
                    }
                    gameState.firstEntity = null;
                }
                return;
            } }
            gameState.firstEntity = null;
        }
        
        // GAME 12: MERGE & SPLIT - bigger people
        function initMergeSplit() { balls = []; gameState = { mergingPairs: [], victory: false }; for (let i = 0; i < 12; i++) { const a = Math.random() * Math.PI * 2, s = 1 + Math.random() * 1.5, ball = { x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a) * s, vy: Math.sin(a) * s, radius: 35 + Math.random() * 15, mass: 1, id: Date.now() + Math.random(), ballImage: getNextBallImage(), spinAngle: 0, merging: false, walkers: [] }; ball.walkers.push({ angle: Math.random() * Math.PI * 2, walkSpeed: 0.015 + Math.random() * 0.015, direction: Math.random() > 0.5 ? 1 : -1, personIndex: getNextPersonImage() }); balls.push(ball); } }
        function updateMergeSplit() {
            if (balls.length === 1 && !gameState.victory) { gameState.victory = true; addScreenShake(15); }
            for (let p = gameState.mergingPairs.length - 1; p >= 0; p--) { const pair = gameState.mergingPairs[p]; pair.progress += 0.025; const b1 = pair.ball1, b2 = pair.ball2; if (!balls.includes(b1) || !balls.includes(b2)) { gameState.mergingPairs.splice(p, 1); continue; } const dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), pullF = 0.4; b1.vx += (dx / dist) * pullF; b1.vy += (dy / dist) * pullF; b2.vx -= (dx / dist) * pullF; b2.vy -= (dy / dist) * pullF; b1.spinAngle += 0.15; b2.spinAngle -= 0.15; if (pair.progress >= 1 || dist < 20) { const tM = b1.mass + b2.mass, nR = Math.sqrt(b1.radius * b1.radius + b2.radius * b2.radius), cW = [...b1.walkers, ...b2.walkers]; cW.forEach((w, idx) => { w.angle = (Math.PI * 2 / cW.length) * idx; }); const newBall = { x: (b1.x * b1.mass + b2.x * b2.mass) / tM, y: (b1.y * b1.mass + b2.y * b2.mass) / tM, vx: (b1.vx * b1.mass + b2.vx * b2.mass) / tM, vy: (b1.vy * b1.mass + b2.vy * b2.mass) / tM, radius: nR, mass: tM, id: Date.now() + Math.random(), ballImage: getNextBallImage(), spinAngle: 0, merging: false, walkers: cW }; const i1 = balls.indexOf(b1), i2 = balls.indexOf(b2); if (i1 > i2) { balls.splice(i1, 1); balls.splice(i2, 1); } else { balls.splice(i2, 1); balls.splice(i1, 1); } balls.push(newBall); addScreenShake(6); gameState.mergingPairs.splice(p, 1); } }
            balls.forEach(ball => { if (ball.merging) return; ball.walkers.forEach(w => { w.angle += w.walkSpeed * w.direction; }); const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy); if (speed < 0.4) { const a = Math.atan2(ball.vy, ball.vx); ball.vx = Math.cos(a) * 0.8; ball.vy = Math.sin(a) * 0.8; } ball.vx *= 0.99; ball.vy *= 0.99; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.8; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.8; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.8; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.8; } });
            for (let i = balls.length - 1; i >= 0; i--) { for (let j = i - 1; j >= 0; j--) { const b1 = balls[i], b2 = balls[j]; if (b1.merging || b2.merging) continue; const dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), minDist = b1.radius + b2.radius; if (dist < minDist * 0.9) { const rVx = b2.vx - b1.vx, rVy = b2.vy - b1.vy, rS = Math.sqrt(rVx * rVx + rVy * rVy); if (rS < 2.5) { b1.merging = true; b2.merging = true; gameState.mergingPairs.push({ ball1: b1, ball2: b2, progress: 0 }); } else { const ang = Math.atan2(dy, dx), ax = (minDist - dist) * Math.cos(ang) * 0.1, ay = (minDist - dist) * Math.sin(ang) * 0.1; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; } } } }
        }
        function drawMergeSplit() {
            balls.forEach(ball => {
                ctx.save(); if (ball.merging) { ctx.translate(ball.x, ball.y); ctx.rotate(ball.spinAngle); ctx.translate(-ball.x, -ball.y); }
                drawBall(ball); ctx.restore();
                // Bigger people - base 40, scales with sqrt(mass), max 70% of radius
                const basePersonH = 40, sF = Math.sqrt(ball.mass), pH = Math.min(basePersonH * sF, ball.radius * 0.7);
                ball.walkers.forEach(w => { const wX = ball.x + Math.cos(w.angle) * ball.radius, wY = ball.y + Math.sin(w.angle) * ball.radius, rot = w.angle + Math.PI / 2; drawPerson(wX, wY, pH, w.personIndex, 1.0, rot); });
                if (ball.mass > 1) { ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(ball.mass, ball.x, ball.y); }
            });
            ctx.fillStyle = '#666'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'left'; ctx.fillText('Worlds: ' + balls.length, 20, canvas.height - 80);
            if (gameState.victory) { ctx.fillStyle = '#4A4'; ctx.font = 'bold 32px Arial'; ctx.textAlign = 'center'; ctx.fillText('ðŸŒ One World! ðŸŒ', canvas.width / 2, 160); }
        }
        function mergeSplitPointerDown(x, y) { for (let i = balls.length - 1; i >= 0; i--) { if (contains(balls[i], x, y) && balls[i].mass > 1 && !balls[i].merging) { const ball = balls[i], numS = Math.min(ball.mass, 4), wPN = Math.floor(ball.walkers.length / numS); for (let j = 0; j < numS; j++) { const ang = (Math.PI * 2 / numS) * j, sp = 3 + Math.random() * 2, nB = { x: ball.x, y: ball.y, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp, radius: ball.radius / Math.sqrt(numS), mass: 1, id: Date.now() + Math.random() + j, ballImage: getNextBallImage(), spinAngle: 0, merging: false, walkers: ball.walkers.slice(j * wPN, (j + 1) * wPN) }; if (nB.walkers.length === 0) nB.walkers.push({ angle: Math.random() * Math.PI * 2, walkSpeed: 0.015 + Math.random() * 0.015, direction: Math.random() > 0.5 ? 1 : -1, personIndex: getNextPersonImage() }); balls.push(nB); } balls.splice(i, 1); gameState.victory = false; addScreenShake(5); break; } } }
        
        // GAME 13: INFLATE/POP - more pop effect, no people
        function initInflate() { balls = []; gameState = { poppedCount: 0, popEffects: [] }; for (let i = 0; i < 8; i++) balls.push({ x: 100 + Math.random() * (canvas.width - 200), y: 100 + Math.random() * (canvas.height - 200), vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5, radius: 40, baseRadius: 40, maxRadius: 100, inflateProgress: 0, inflateSpeed: 0.2 + Math.random() * 0.4, ballImage: getNextBallImage(), rotation: 0 }); }
        function updateInflate() {
            gameState.popEffects = gameState.popEffects.filter(e => { e.progress += 0.08; e.rotation += e.spinSpeed; return e.progress < 1; });
            for (let i = balls.length - 1; i >= 0; i--) { const ball = balls[i]; ball.inflateProgress += ball.inflateSpeed * 0.003; const tR = ball.baseRadius + ball.inflateProgress * (ball.maxRadius - ball.baseRadius); ball.radius = Math.min(tR, ball.maxRadius); ball.vx *= 0.98; ball.vy *= 0.98; let newX = ball.x + ball.vx, newY = ball.y + ball.vy; if (newX - ball.radius < 0) { newX = ball.radius; ball.vx = Math.abs(ball.vx) * 0.3; } if (newX + ball.radius > canvas.width) { newX = canvas.width - ball.radius; ball.vx = -Math.abs(ball.vx) * 0.3; } if (newY - ball.radius < 0) { newY = ball.radius; ball.vy = Math.abs(ball.vy) * 0.3; } if (newY + ball.radius > canvas.height) { newY = canvas.height - ball.radius; ball.vy = -Math.abs(ball.vy) * 0.3; } ball.x = newX; ball.y = newY; capSpeed(ball); if (ball.radius >= ball.maxRadius * 0.95) { gameState.popEffects.push({ x: ball.x, y: ball.y, radius: ball.radius, ballImage: ball.ballImage, progress: 0, rotation: 0, spinSpeed: (Math.random() - 0.5) * 0.5 }); ball.radius = ball.baseRadius; ball.inflateProgress = 0; ball.x = 100 + Math.random() * (canvas.width - 200); ball.y = 100 + Math.random() * (canvas.height - 200); gameState.poppedCount++; addScreenShake(6); } }
            for (let i = 0; i < balls.length; i++) { for (let j = i + 1; j < balls.length; j++) { const b1 = balls[i], b2 = balls[j], dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), minDist = b1.radius + b2.radius; if (dist < minDist && dist > 0) { const overlap = minDist - dist, pushF = overlap * 0.1, ang = Math.atan2(dy, dx); b1.x -= Math.cos(ang) * pushF; b1.y -= Math.sin(ang) * pushF; b2.x += Math.cos(ang) * pushF; b2.y += Math.sin(ang) * pushF; b1.vx -= Math.cos(ang) * pushF * 0.2; b1.vy -= Math.sin(ang) * pushF * 0.2; b2.vx += Math.cos(ang) * pushF * 0.2; b2.vy += Math.sin(ang) * pushF * 0.2; } } }
        }
        function drawInflate() {
            // Pop effects with spin and scale
            gameState.popEffects.forEach(e => {
                const img = ballImages[e.ballImage - 1];
                if (img && img.complete) {
                    ctx.save();
                    ctx.globalAlpha = 1 - e.progress;
                    ctx.translate(e.x, e.y);
                    ctx.rotate(e.rotation);
                    const scale = 1 + e.progress * 1.5;
                    ctx.scale(scale, scale);
                    ctx.drawImage(img, -e.radius, -e.radius, e.radius * 2, e.radius * 2);
                    ctx.restore();
                }
                // Ring effect
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.radius * (1 + e.progress * 2), 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 200, 100, ' + (1 - e.progress) * 0.5 + ')';
                ctx.lineWidth = 4 * (1 - e.progress);
                ctx.stroke();
            });
            balls.forEach(ball => { const pr = ball.radius / ball.maxRadius, hue = 60 - pr * 60; ctx.save(); if (pr > 0.7) { ctx.shadowBlur = pr * 20; ctx.shadowColor = 'hsla(' + hue + ', 80%, 50%, 0.5)'; } drawBall(ball); ctx.restore(); });
            ctx.fillStyle = '#666'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'left'; ctx.fillText('Auto-popped: ' + gameState.poppedCount, 20, canvas.height - 80);
        }
        function inflatePointerDown(x, y) { for (let i = balls.length - 1; i >= 0; i--) { if (contains(balls[i], x, y)) { const ball = balls[i]; gameState.popEffects.push({ x: ball.x, y: ball.y, radius: ball.radius, ballImage: ball.ballImage, progress: 0, rotation: 0, spinSpeed: (Math.random() - 0.5) * 0.6 }); ball.radius = ball.baseRadius; ball.inflateProgress = 0; ball.x = 100 + Math.random() * (canvas.width - 200); ball.y = 100 + Math.random() * (canvas.height - 200); addScreenShake(4); break; } } }
        
        // GAME 14: BRUSH - follow line if it intersects anywhere
        function initBrush() { balls = []; gameState = { paths: [], drawing: false, currentPath: [] }; for (let i = 0; i < 15; i++) balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, radius: 20 + Math.random() * 15, ballImage: getNextBallImage(), followingPath: null, pathProgress: 0, pathStartIndex: 0 }); }
        function updateBrush() {
            gameState.paths = gameState.paths.filter(path => Date.now() - path.created < 6000);
            balls.forEach(ball => {
                if (ball.followingPath && ball.followingPath.points) {
                    const path = ball.followingPath;
                    ball.pathProgress += 0.02;
                    const totalProgress = ball.pathStartIndex / (path.points.length - 1) + ball.pathProgress * (1 - ball.pathStartIndex / (path.points.length - 1));
                    if (totalProgress >= 1 || !gameState.paths.includes(path)) { ball.followingPath = null; ball.pathProgress = 0; ball.pathStartIndex = 0; }
                    else {
                        const idx = Math.floor(totalProgress * (path.points.length - 1)), nextIdx = Math.min(idx + 1, path.points.length - 1);
                        const t = (totalProgress * (path.points.length - 1)) - idx;
                        const targetX = path.points[idx].x + (path.points[nextIdx].x - path.points[idx].x) * t;
                        const targetY = path.points[idx].y + (path.points[nextIdx].y - path.points[idx].y) * t;
                        ball.vx = (targetX - ball.x) * 0.15; ball.vy = (targetY - ball.y) * 0.15;
                    }
                } else {
                    // Check if ball intersects ANY part of any path
                    for (const path of gameState.paths) {
                        if (path.points.length < 2) continue;
                        for (let i = 0; i < path.points.length; i++) {
                            const pt = path.points[i];
                            const dx = ball.x - pt.x, dy = ball.y - pt.y, dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < ball.radius + 20) {
                                ball.followingPath = path;
                                ball.pathStartIndex = i;
                                ball.pathProgress = 0;
                                break;
                            }
                        }
                        if (ball.followingPath) break;
                    }
                    ball.vx *= 0.95; ball.vy *= 0.95;
                }
                ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball);
                if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.8; }
                if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.8; }
                if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.8; }
                if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.8; }
            });
            ballCollisions();
        }
        function drawBrush() {
            gameState.paths.forEach(path => {
                if (path.points.length < 2) return;
                const age = Date.now() - path.created, op = Math.max(0, 1 - age / 6000);
                ctx.save();
                ctx.beginPath(); ctx.moveTo(path.points[0].x, path.points[0].y);
                for (let i = 1; i < path.points.length; i++) ctx.lineTo(path.points[i].x, path.points[i].y);
                ctx.strokeStyle = 'rgba(100, 180, 255, ' + (op * 0.6) + ')'; ctx.lineWidth = 8; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.stroke();
                // Start dot (green)
                ctx.beginPath(); ctx.arc(path.points[0].x, path.points[0].y, 10, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(100, 255, 150, ' + (op * 0.8) + ')'; ctx.fill();
                // End dot (orange)
                if (path.points.length > 1) { const endPt = path.points[path.points.length - 1]; ctx.beginPath(); ctx.arc(endPt.x, endPt.y, 8, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 150, 100, ' + (op * 0.8) + ')'; ctx.fill(); }
                ctx.restore();
            });
            if (gameState.drawing && gameState.currentPath.length > 1) { ctx.save(); ctx.globalAlpha = 0.7; ctx.beginPath(); ctx.moveTo(gameState.currentPath[0].x, gameState.currentPath[0].y); for (let i = 1; i < gameState.currentPath.length; i++) ctx.lineTo(gameState.currentPath[i].x, gameState.currentPath[i].y); ctx.strokeStyle = 'rgba(100, 180, 255, 0.9)'; ctx.lineWidth = 6; ctx.lineCap = 'round'; ctx.stroke(); ctx.restore(); }
            balls.forEach(ball => { if (ball.followingPath) { ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius + 8, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)'; ctx.lineWidth = 3; ctx.stroke(); } drawBall(ball); });
            ctx.fillStyle = '#666'; ctx.font = '16px Arial'; ctx.textAlign = 'left'; ctx.fillText('Draw paths - balls follow when they touch the line', 20, canvas.height - 80);
        }
        function brushPointerDown(x, y) { gameState.drawing = true; gameState.currentPath = [{ x, y }]; }
        function brushPointerMove(x, y) { if (gameState.drawing) { const lastPt = gameState.currentPath[gameState.currentPath.length - 1]; if (Math.abs(x - lastPt.x) > 5 || Math.abs(y - lastPt.y) > 5) gameState.currentPath.push({ x, y }); } }
        function brushPointerUp() { if (gameState.drawing && gameState.currentPath.length > 3) gameState.paths.push({ points: [...gameState.currentPath], created: Date.now() }); gameState.drawing = false; gameState.currentPath = []; }
        
        // GAME 15: PORTALS - original golden quadrant version
        function initPortals() {
            balls = []; gameState = { portals: [], nextPortalIsExit: false };
            for (let i = 0; i < 20; i++) balls.push({ x: Math.random() * canvas.width * 0.6, y: Math.random() * canvas.height, vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3, radius: 20 + Math.random() * 15, ballImage: getNextBallImage(), portalCooldown: 0 });
        }
        function updatePortals() {
            balls.forEach(ball => {
                const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (speed < 0.5) { const a = Math.atan2(ball.vy, ball.vx); ball.vx = Math.cos(a) * 1; ball.vy = Math.sin(a) * 1; }
                ball.vx *= 0.99; ball.vy *= 0.99; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball);
                if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.9; }
                if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.9; }
                if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.9; }
                if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.9; }
                if (ball.portalCooldown > 0) ball.portalCooldown--;
                gameState.portals.forEach(portal => {
                    if (!portal.exit) return;
                    const dx = ball.x - portal.entrance.x, dy = ball.y - portal.entrance.y, dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 35 && ball.portalCooldown === 0) { ball.x = portal.exit.x; ball.y = portal.exit.y; ball.portalCooldown = 60; addScreenShake(3); }
                });
            });
            ballCollisions();
        }
        function drawPortals() {
            // Golden quadrant (right side)
            const gx = canvas.width * 0.7, gy = 0, gw = canvas.width * 0.3, gh = canvas.height;
            const grad = ctx.createLinearGradient(gx, 0, canvas.width, 0);
            grad.addColorStop(0, 'rgba(255, 215, 0, 0)'); grad.addColorStop(0.3, 'rgba(255, 215, 0, 0.15)'); grad.addColorStop(1, 'rgba(255, 215, 0, 0.3)');
            ctx.fillStyle = grad; ctx.fillRect(gx, gy, gw, gh);
            ctx.strokeStyle = 'rgba(255, 180, 0, 0.5)'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, canvas.height); ctx.stroke();
            
            gameState.portals.forEach(portal => {
                const ent = portal.entrance, time = Date.now() * 0.003;
                // Entrance (orange)
                ctx.save(); ctx.translate(ent.x, ent.y);
                for (let i = 0; i < 3; i++) { ctx.beginPath(); ctx.arc(0, 0, 35 - i * 8, time + i * 0.5, time + i * 0.5 + Math.PI * 1.6); ctx.strokeStyle = 'rgba(255, ' + (150 - i * 40) + ', 50, ' + (0.8 - i * 0.2) + ')'; ctx.lineWidth = 5 - i; ctx.stroke(); }
                ctx.restore();
                // Exit (blue)
                if (portal.exit) {
                    const exit = portal.exit;
                    ctx.save(); ctx.translate(exit.x, exit.y);
                    for (let i = 0; i < 3; i++) { ctx.beginPath(); ctx.arc(0, 0, 35 - i * 8, -time + i * 0.5, -time + i * 0.5 + Math.PI * 1.6); ctx.strokeStyle = 'rgba(50, ' + (150 - i * 40) + ', 255, ' + (0.8 - i * 0.2) + ')'; ctx.lineWidth = 5 - i; ctx.stroke(); }
                    ctx.restore();
                }
            });
            
            balls.forEach(ball => { const inGold = ball.x > gx; drawBall(ball, inGold ? 1.0 : 0.8); });
            
            // Count balls in golden zone
            const ballsInZone = balls.filter(b => b.x > gx).length;
            const allIn = ballsInZone === balls.length;
            ctx.fillStyle = allIn ? '#4A4' : '#666'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'left';
            ctx.fillText('In golden zone: ' + ballsInZone + '/' + balls.length, 20, canvas.height - 80);
            if (allIn) { ctx.fillStyle = '#FFD700'; ctx.font = 'bold 32px Arial'; ctx.textAlign = 'center'; ctx.fillText('ðŸŽ¯ All Safe! ðŸŽ¯', canvas.width / 2, 160); }
            if (gameState.nextPortalIsExit) { ctx.fillStyle = '#666'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.fillText('Click to place exit (blue)', canvas.width / 2, canvas.height - 100); }
        }
        function portalPointerDown(x, y) {
            if (!gameState.nextPortalIsExit) { gameState.portals.push({ entrance: { x, y }, exit: null }); gameState.nextPortalIsExit = true; }
            else { const lastP = gameState.portals[gameState.portals.length - 1]; if (lastP && !lastP.exit) { lastP.exit = { x, y }; gameState.nextPortalIsExit = false; } }
        }
        
        // HELPERS
        function contains(ball, x, y) { const dx = x - ball.x, dy = y - ball.y; return Math.sqrt(dx * dx + dy * dy) < ball.radius; }
        function drawBall(ball, opacity = 1.0, rotation = 0) { const img = ballImages[ball.ballImage - 1]; if (img && img.complete && img.naturalWidth > 0) { ctx.save(); ctx.globalAlpha = opacity; ctx.translate(ball.x, ball.y); ctx.rotate(rotation); ctx.drawImage(img, -ball.radius, -ball.radius, ball.radius * 2, ball.radius * 2); ctx.restore(); } else { ctx.save(); ctx.globalAlpha = opacity; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2); ctx.fillStyle = '#333'; ctx.fill(); ctx.restore(); } }
        function ballCollisions() { for (let i = 0; i < balls.length; i++) { for (let j = i + 1; j < balls.length; j++) { const b1 = balls[i], b2 = balls[j]; if (b1.popping || b2.popping || b1.orbiting || b2.orbiting || b1.frozen || b2.frozen || b1.merging || b2.merging) continue; const dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), minDist = b1.radius + b2.radius; if (dist < minDist) { const ang = Math.atan2(dy, dx), ax = (minDist - dist) * Math.cos(ang) * 0.05, ay = (minDist - dist) * Math.sin(ang) * 0.05; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; } } } }
        function lineCircleCollision(x1, y1, x2, y2, cx, cy, radius) { const dx = x2 - x1, dy = y2 - y1, fx = x1 - cx, fy = y1 - cy, a = dx * dx + dy * dy, b = 2 * (fx * dx + fy * dy), c = (fx * fx + fy * fy) - radius * radius; let disc = b * b - 4 * a * c; if (disc < 0) return { collides: false }; disc = Math.sqrt(disc); const t1 = (-b - disc) / (2 * a), t2 = (-b + disc) / (2 * a); if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) { const t = Math.max(0, Math.min(1, -b / (2 * a))), closestX = x1 + t * dx, closestY = y1 + t * dy, distX = cx - closestX, distY = cy - closestY, dist = Math.sqrt(distX * distX + distY * distY); if (dist < radius) { const pushDist = radius - dist; return { collides: true, newX: cx + (distX / dist) * pushDist, newY: cy + (distY / dist) * pushDist }; } } return { collides: false }; }
        
        // GAME MANAGEMENT
        function switchGame(gameNum) { if (gameNum < 1 || gameNum > 15) return; currentGame = gameNum; screenShake = { x: 0, y: 0, intensity: 0 }; document.querySelectorAll('.nav-item').forEach(item => { item.classList.remove('active'); if (parseInt(item.dataset.game) === currentGame) item.classList.add('active'); }); games[currentGame].init(); }
        document.querySelectorAll('.nav-item').forEach(item => { item.addEventListener('click', () => { switchGame(parseInt(item.dataset.game)); }); });
        
        // INPUT
        function getPointer(e) { const touch = e.touches ? e.touches[0] : e; return { x: touch.clientX, y: touch.clientY }; }
        canvas.addEventListener('mousedown', (e) => { e.preventDefault(); const { x, y } = getPointer(e), game = games[currentGame]; if (game.onPointerDown) game.onPointerDown(x, y); });
        canvas.addEventListener('mousemove', (e) => { const { x, y } = getPointer(e); mouseX = x; mouseY = y; const game = games[currentGame]; if (game.onPointerMove) game.onPointerMove(x, y); });
        canvas.addEventListener('mouseup', (e) => { e.preventDefault(); const game = games[currentGame]; if (game.onPointerUp) game.onPointerUp(); });
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); const { x, y } = getPointer(e), game = games[currentGame]; if (game.onPointerDown) game.onPointerDown(x, y); });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); const { x, y } = getPointer(e); mouseX = x; mouseY = y; const game = games[currentGame]; if (game.onPointerMove) game.onPointerMove(x, y); });
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); const game = games[currentGame]; if (game.onPointerUp) game.onPointerUp(); });
        document.addEventListener('keydown', (e) => { const num = parseInt(e.key); if (num >= 1 && num <= 9) switchGame(num); if (e.key === '0') switchGame(10); if (e.key === 'Shift' && gameState && gameState.shiftPressed !== undefined) gameState.shiftPressed = true; });
        document.addEventListener('keyup', (e) => { if (e.key === 'Shift' && gameState && gameState.shiftPressed !== undefined) gameState.shiftPressed = false; });
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
        
        // LOOP
        function animate() { updateScreenShake(); ctx.save(); ctx.translate(screenShake.x, screenShake.y); ctx.clearRect(-10, -10, canvas.width + 20, canvas.height + 20); const game = games[currentGame]; game.update(); game.draw(); ctx.restore(); requestAnimationFrame(animate); }
        switchGame(1);
        animate();
    </script>
</body>
</html>