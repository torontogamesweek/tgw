<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toronto Games Week - Interactive Background Tests</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #f0f0f0;
            touch-action: none;
            font-family: Arial, sans-serif;
        }
        canvas { display: block; background: #fff; }
        #nav {
            position: fixed;
            top: 0; left: 0; right: 0;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(3, 1fr);
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 100;
        }
        .nav-item {
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            border-right: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
            user-select: none;
            position: relative;
        }
        .nav-item:nth-child(5n) { border-right: none; }
        .nav-item:nth-child(n+11) { border-bottom: none; }
        .nav-item:hover { background: rgba(0, 0, 0, 0.05); }
        .nav-item.active { background: rgba(0, 0, 0, 0.1); color: #000; }
        .nav-item .tooltip {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: normal;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 200;
            margin-top: 5px;
        }
        .nav-item .tooltip::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: rgba(0, 0, 0, 0.85);
        }
        .nav-item:hover .tooltip { opacity: 1; }
        @media (max-width: 768px) {
            #nav { grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(5, 1fr); }
            .nav-item { font-size: 11px; padding: 10px 5px; }
            .nav-item:nth-child(5n) { border-right: 1px solid #ddd; }
            .nav-item:nth-child(3n) { border-right: none; }
            .nav-item:nth-child(n+11) { border-bottom: 1px solid #ddd; }
            .nav-item:nth-child(n+13) { border-bottom: none; }
            .nav-item .tooltip { font-size: 10px; padding: 6px 10px; }
        }
    </style>
</head>
<body>
    <div id="nav">
        <div class="nav-item" data-game="1">Fling<span class="tooltip">Collect gold âœ¦ but avoid the catchers!</span></div>
        <div class="nav-item" data-game="2">Paddle<span class="tooltip">Keep the balls bouncing! They fade if they rest.</span></div>
        <div class="nav-item" data-game="3">Pop<span class="tooltip">Pop them all! Smaller = more points.</span></div>
        <div class="nav-item" data-game="4">Vacuum<span class="tooltip">Hold to vacuum, release to explode!</span></div>
        <div class="nav-item" data-game="5">Gravity Flip<span class="tooltip">Click to reverse gravity</span></div>
        <div class="nav-item" data-game="6">Draw Barriers<span class="tooltip">Draw platforms to bounce falling balls!</span></div>
        <div class="nav-item" data-game="7">Magnet Zones<span class="tooltip">Click = attract, SHIFT+click = repel</span></div>
        <div class="nav-item" data-game="8">Explode<span class="tooltip">Hold to charge, release to burst!</span></div>
        <div class="nav-item" data-game="9">Orbital<span class="tooltip">Balls orbit you. Click to release!</span></div>
        <div class="nav-item" data-game="10">Transform<span class="tooltip">Click balls to make guards. Protect the moving zone!</span></div>
        <div class="nav-item" data-game="11">Connections<span class="tooltip">Connect peopleâ†”balls only! Same types explode!</span></div>
        <div class="nav-item" data-game="12">Merge & Split<span class="tooltip">Unite all the walkers onto one world!</span></div>
        <div class="nav-item" data-game="13">Inflate/Pop<span class="tooltip">Click people to push balls! Don't let them crowd!</span></div>
        <div class="nav-item" data-game="14">Brush<span class="tooltip">Paint paths for balls to follow</span></div>
        <div class="nav-item" data-game="15">Portals<span class="tooltip">Get all balls to the golden zone before they shrink!</span></div>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        let currentGame = 1;
        let balls = [];
        let gameState = {};
        const MAX_SPEED = 25;
        let screenShake = { x: 0, y: 0, intensity: 0 };
        
        function capSpeed(ball) {
            const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            if (speed > MAX_SPEED) {
                const scale = MAX_SPEED / speed;
                ball.vx *= scale;
                ball.vy *= scale;
            }
        }
        
        function addScreenShake(intensity) {
            screenShake.intensity = Math.min(Math.max(screenShake.intensity, intensity * 0.4), 8);
        }
        
        function updateScreenShake() {
            if (screenShake.intensity > 0) {
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.intensity *= 0.85;
                if (screenShake.intensity < 0.3) screenShake.intensity = 0;
            } else {
                screenShake.x = 0;
                screenShake.y = 0;
            }
        }
        
        function drawBallWithSquash(ball, opacity = 1.0, rotation = 0, squashX = 1, squashY = 1) {
            const img = ballImages[ball.ballImage - 1];
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.translate(ball.x, ball.y);
            ctx.rotate(rotation);
            ctx.scale(squashX, squashY);
            if (img && img.complete && img.naturalWidth > 0) {
                ctx.drawImage(img, -ball.radius, -ball.radius, ball.radius * 2, ball.radius * 2);
            } else {
                ctx.beginPath();
                ctx.arc(0, 0, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#333';
                ctx.fill();
            }
            ctx.restore();
        }
        
        const ballImages = [];
        const peopleImages = [];
        const numBallImages = 29;
        const numPeopleImages = 19;
        
        for (let i = 1; i <= numBallImages; i++) {
            const img = new Image();
            img.src = 'balls/ball_' + i + '.png';
            ballImages.push(img);
        }
        
        for (let i = 1; i <= numPeopleImages; i++) {
            const img = new Image();
            img.src = 'ppl/ppl_' + i + '.png';
            peopleImages.push(img);
        }
        
        function drawPerson(x, y, height, imageIndex, opacity = 1.0, rotation = 0) {
            const img = peopleImages[imageIndex % numPeopleImages];
            if (img && img.complete && img.naturalWidth > 0) {
                const aspectRatio = img.naturalWidth / img.naturalHeight;
                const width = height * aspectRatio;
                ctx.save();
                ctx.globalAlpha = opacity;
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.drawImage(img, -width/2, -height, width, height);
                ctx.restore();
            }
        }
        
        let ballImageCounter = 0;
        function getNextBallImage() {
            ballImageCounter = (ballImageCounter + 1) % numBallImages;
            return ballImageCounter + 1;
        }
        
        let personImageCounter = 0;
        function getNextPersonImage() {
            const index = personImageCounter;
            personImageCounter = (personImageCounter + 1) % numPeopleImages;
            return index;
        }
        
        const games = {
            1: { name: "Fling", init: initFling, update: updateFling, draw: drawFling, onPointerDown: flingPointerDown, onPointerMove: flingPointerMove, onPointerUp: flingPointerUp },
            2: { name: "Paddle", init: initPaddle, update: updatePaddle, draw: drawPaddle, onPointerMove: paddlePointerMove },
            3: { name: "Pop", init: initPopSpawn, update: updatePopSpawn, draw: drawPopSpawn, onPointerDown: popSpawnPointerDown },
            4: { name: "Vacuum", init: initVacuum, update: updateVacuum, draw: drawVacuum, onPointerDown: vacuumPointerDown, onPointerMove: vacuumPointerMove, onPointerUp: vacuumPointerUp },
            5: { name: "Gravity Flip", init: initGravityFlip, update: updateGravityFlip, draw: drawGravityFlip, onPointerDown: gravityFlipPointerDown },
            6: { name: "Draw Barriers", init: initDrawBarriers, update: updateDrawBarriers, draw: drawDrawBarriers, onPointerDown: barrierPointerDown, onPointerMove: barrierPointerMove, onPointerUp: barrierPointerUp },
            7: { name: "Magnet Zones", init: initMagnetZones, update: updateMagnetZones, draw: drawMagnetZones, onPointerDown: magnetPointerDown },
            8: { name: "Explode", init: initBallCannon, update: updateBallCannon, draw: drawBallCannon, onPointerDown: cannonPointerDown, onPointerUp: cannonPointerUp },
            9: { name: "Orbital", init: initOrbital, update: updateOrbital, draw: drawOrbital, onPointerMove: orbitalPointerMove, onPointerDown: orbitalPointerDown },
            10: { name: "Transform", init: initFreezeFrame, update: updateFreezeFrame, draw: drawFreezeFrame, onPointerDown: freezePointerDown },
            11: { name: "Connections", init: initRubberBands, update: updateRubberBands, draw: drawRubberBands, onPointerDown: rubberBandPointerDown },
            12: { name: "Merge & Split", init: initMergeSplit, update: updateMergeSplit, draw: drawMergeSplit, onPointerDown: mergeSplitPointerDown },
            13: { name: "Inflate/Pop", init: initInflate, update: updateInflate, draw: drawInflate, onPointerDown: inflatePointerDown },
            14: { name: "Brush", init: initWindBrush, update: updateWindBrush, draw: drawWindBrush, onPointerDown: windBrushPointerDown, onPointerMove: windBrushPointerMove, onPointerUp: windBrushPointerUp },
            15: { name: "Portals", init: initPortals, update: updatePortals, draw: drawPortals, onPointerDown: portalPointerDown }
        };
        
        // GAME 1: FLING
        function initFling() {
            balls = [];
            gameState = { draggedBall: null, goldenOrbs: [], catchers: [], score: 0, lives: 5, particles: [], gameTime: 0, lastCatcherSpawn: 0 };
            for (let i = 0; i < 10; i++) spawnFlingBall();
            for (let i = 0; i < 6; i++) {
                gameState.goldenOrbs.push({ x: 150 + Math.random() * (canvas.width - 300), y: 200 + Math.random() * (canvas.height - 400), radius: 10, pulse: Math.random() * Math.PI * 2 });
            }
            for (let i = 0; i < 2; i++) spawnCatcher();
        }
        
        function spawnFlingBall(animated = false) {
            const angle = Math.random() * Math.PI * 2;
            balls.push({
                x: canvas.width / 2 + (Math.random() - 0.5) * 200,
                y: canvas.height / 2 + (Math.random() - 0.5) * 200,
                vx: Math.cos(angle) * 0.5, vy: Math.sin(angle) * 0.5,
                radius: 30 + Math.random() * 20,
                isDragging: false, dragStartX: 0, dragStartY: 0,
                ballImage: getNextBallImage(), rotation: 0, trail: [], glowTimer: 0,
                dying: false, deathProgress: 0, deathType: 'explode',
                spawnProgress: animated ? 0 : 1, squashX: 1, squashY: 1
            });
        }
        
        function spawnCatcher() {
            let x, y;
            do {
                x = 100 + Math.random() * (canvas.width - 200);
                y = 100 + Math.random() * (canvas.height - 200);
            } while (Math.abs(x - canvas.width/2) < 200 && Math.abs(y - canvas.height/2) < 200);
            gameState.catchers.push({ x, y, personIndex: getNextPersonImage(), radius: 35 });
        }
        
        function updateFling() {
            gameState.gameTime++;
            if (gameState.catchers.length < 12 && gameState.gameTime - gameState.lastCatcherSpawn > 600) {
                spawnCatcher();
                gameState.lastCatcherSpawn = gameState.gameTime;
            }
            gameState.goldenOrbs.forEach(orb => { orb.pulse += 0.1; });
            gameState.particles = gameState.particles.filter(p => { p.x += p.vx; p.y += p.vy; p.vy += p.gravity || 0; p.life--; p.rotation = (p.rotation || 0) + (p.spin || 0); return p.life > 0; });
            
            for (let i = balls.length - 1; i >= 0; i--) {
                const ball = balls[i];
                if (ball.spawnProgress < 1) {
                    ball.spawnProgress += 0.05;
                    ball.squashX = 0.3 + ball.spawnProgress * 0.7 + Math.sin(ball.spawnProgress * Math.PI) * 0.3;
                    ball.squashY = 0.3 + ball.spawnProgress * 0.7 + Math.sin(ball.spawnProgress * Math.PI + Math.PI/2) * 0.2;
                    continue;
                }
                if (ball.dying) {
                    ball.deathProgress += 0.06;
                    ball.squashX = ball.deathType === 'explode' ? 1 + ball.deathProgress * 1.5 : 1 + ball.deathProgress * 0.8;
                    ball.squashY = ball.deathType === 'explode' ? 1 - ball.deathProgress * 0.8 : 1 - ball.deathProgress * 0.9;
                    if (ball.deathProgress >= 1) { balls.splice(i, 1); spawnFlingBall(true); }
                    continue;
                }
                if (ball.isDragging) continue;
                if (ball.glowTimer > 0) ball.glowTimer--;
                ball.squashX += (1 - ball.squashX) * 0.15;
                ball.squashY += (1 - ball.squashY) * 0.15;
                
                const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                if (speed < 0.3) { const a = Math.atan2(ball.vy, ball.vx); ball.vx = Math.cos(a) * 0.5; ball.vy = Math.sin(a) * 0.5; }
                ball.vx *= 0.99; ball.vy *= 0.99;
                ball.x += ball.vx; ball.y += ball.vy;
                capSpeed(ball);
                ball.rotation += speed * 0.05;
                if (speed > 3) ball.trail.push({ x: ball.x, y: ball.y, life: 20 });
                ball.trail = ball.trail.filter(p => p.life-- > 0);
                
                if (speed > 4) {
                    for (let j = gameState.goldenOrbs.length - 1; j >= 0; j--) {
                        const orb = gameState.goldenOrbs[j];
                        const dx = ball.x - orb.x, dy = ball.y - orb.y;
                        if (Math.sqrt(dx*dx + dy*dy) < ball.radius + orb.radius + 5) {
                            ball.glowTimer = 60; gameState.score++;
                            for (let k = 0; k < 8; k++) { const a = (Math.PI * 2 / 8) * k; gameState.particles.push({ x: orb.x, y: orb.y, vx: Math.cos(a) * 3, vy: Math.sin(a) * 3, life: 20, color: '#FFD700' }); }
                            orb.x = 150 + Math.random() * (canvas.width - 300);
                            orb.y = 200 + Math.random() * (canvas.height - 400);
                        }
                    }
                    gameState.catchers.forEach(catcher => {
                        const dx = ball.x - catcher.x, dy = ball.y - catcher.y;
                        if (Math.sqrt(dx*dx + dy*dy) < ball.radius + catcher.radius && !ball.dying) {
                            ball.dying = true; ball.deathProgress = 0; ball.deathType = Math.random() > 0.5 ? 'explode' : 'squish';
                            gameState.lives--; addScreenShake(10);
                            for (let k = 0; k < 12; k++) { const a = (Math.PI * 2 / 12) * k; gameState.particles.push({ x: ball.x, y: ball.y, vx: Math.cos(a) * (3 + Math.random() * 3), vy: Math.sin(a) * (3 + Math.random() * 3), life: 35, ballImage: ball.ballImage, radius: ball.radius * 0.2, rotation: Math.random() * Math.PI * 2, spin: (Math.random() - 0.5) * 0.3, gravity: 0.15 }); }
                        }
                    });
                }
                if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.8; ball.squashX = 0.7; ball.squashY = 1.2; }
                if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.8; ball.squashX = 0.7; ball.squashY = 1.2; }
                if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.8; ball.squashX = 1.2; ball.squashY = 0.7; }
                if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.8; ball.squashX = 1.2; ball.squashY = 0.7; }
            }
            ballCollisions();
        }
        
        function drawFling() {
            gameState.catchers.forEach(c => { ctx.beginPath(); ctx.arc(c.x, c.y, c.radius + 10, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 100, 100, 0.15)'; ctx.fill(); drawPerson(c.x, c.y + 20, 50, c.personIndex); });
            gameState.goldenOrbs.forEach(orb => {
                const ps = 1 + Math.sin(orb.pulse) * 0.2;
                const g = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, orb.radius * ps * 3);
                g.addColorStop(0, 'rgba(255, 215, 0, 0.6)'); g.addColorStop(1, 'rgba(255, 150, 0, 0)');
                ctx.beginPath(); ctx.arc(orb.x, orb.y, orb.radius * ps * 3, 0, Math.PI * 2); ctx.fillStyle = g; ctx.fill();
                ctx.beginPath(); ctx.arc(orb.x, orb.y, orb.radius * ps, 0, Math.PI * 2); ctx.fillStyle = '#FFD700'; ctx.fill();
            });
            gameState.particles.forEach(p => {
                if (p.ballImage) { const img = ballImages[p.ballImage - 1]; if (img && img.complete) { ctx.save(); ctx.globalAlpha = p.life / 35; ctx.translate(p.x, p.y); ctx.rotate(p.rotation); ctx.drawImage(img, -p.radius, -p.radius, p.radius * 2, p.radius * 2); ctx.restore(); } }
                else { ctx.beginPath(); ctx.arc(p.x, p.y, 3 * (p.life / 25), 0, Math.PI * 2); ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 25; ctx.fill(); ctx.globalAlpha = 1; }
            });
            balls.forEach(ball => {
                ball.trail.forEach(p => { const a = p.life / 25; ctx.beginPath(); ctx.arc(p.x, p.y, ball.radius * a * 0.5, 0, Math.PI * 2); ctx.fillStyle = ball.glowTimer > 0 ? 'rgba(255, 215, 0, ' + (a * 0.3) + ')' : 'rgba(200, 150, 150, ' + (a * 0.2) + ')'; ctx.fill(); });
                if (ball.glowTimer > 0) { const g = ctx.createRadialGradient(ball.x, ball.y, ball.radius * 0.5, ball.x, ball.y, ball.radius * 1.8); g.addColorStop(0, 'rgba(255, 215, 0, ' + (ball.glowTimer / 120) + ')'); g.addColorStop(1, 'rgba(255, 215, 0, 0)'); ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius * 1.8, 0, Math.PI * 2); ctx.fillStyle = g; ctx.fill(); }
                const op = ball.dying ? (1 - ball.deathProgress) : (ball.spawnProgress < 1 ? ball.spawnProgress : (ball.isDragging ? 0.7 : 1.0));
                drawBallWithSquash(ball, op, ball.rotation, ball.squashX, ball.squashY);
                if (ball.isDragging) { ctx.beginPath(); ctx.moveTo(ball.dragStartX, ball.dragStartY); ctx.lineTo(ball.x, ball.y); ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)'; ctx.lineWidth = 3; ctx.stroke(); }
            });
            ctx.fillStyle = '#FFD700'; ctx.font = 'bold 24px Arial'; ctx.textAlign = 'left'; ctx.fillText('âœ¦ ' + gameState.score, 20, canvas.height - 80);
            ctx.fillStyle = '#FF6666'; ctx.fillText('â™¥ ' + gameState.lives, 120, canvas.height - 80);
            ctx.fillStyle = '#666'; ctx.font = '14px Arial'; ctx.fillText('Catchers: ' + gameState.catchers.length + '/12', 20, canvas.height - 55);
        }
        
        function flingPointerDown(x, y) { for (let i = balls.length - 1; i >= 0; i--) { if (contains(balls[i], x, y) && !balls[i].dying && balls[i].spawnProgress >= 1) { gameState.draggedBall = balls[i]; balls[i].isDragging = true; balls[i].dragStartX = x; balls[i].dragStartY = y; break; } } }
        function flingPointerMove(x, y) { if (!gameState.draggedBall) return; const ball = gameState.draggedBall, pad = ball.radius + 10; ball.x = Math.max(pad, Math.min(canvas.width - pad, x)); ball.y = Math.max(pad, Math.min(canvas.height - pad, y)); }
        function flingPointerUp() { if (!gameState.draggedBall) return; const ball = gameState.draggedBall; ball.vx = (ball.dragStartX - ball.x) * 0.3; ball.vy = (ball.dragStartY - ball.y) * 0.3; capSpeed(ball); ball.isDragging = false; gameState.draggedBall = null; }
        
        // GAME 2: PADDLE
        function initPaddle() {
            balls = []; gameState = { mouseX: canvas.width/2, mouseY: canvas.height/2, lastMouseX: canvas.width/2, lastMouseY: canvas.height/2, personIndex: getNextPersonImage(), energy: 100 };
            for (let i = 0; i < 15; i++) { const a = Math.random() * Math.PI * 2, s = 2 + Math.random() * 2; balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a) * s, vy: Math.sin(a) * s, radius: 35 + Math.random() * 20, rotation: Math.random() * Math.PI * 2, ballImage: getNextBallImage(), lastHitTime: Date.now(), sleepy: false, fadeProgress: 0, squashX: 1, squashY: 1 }); }
        }
        
        function updatePaddle() {
            const mVx = gameState.mouseX - gameState.lastMouseX, mVy = gameState.mouseY - gameState.lastMouseY;
            let sleepyCount = 0;
            for (let i = balls.length - 1; i >= 0; i--) {
                const ball = balls[i];
                ball.vy += 0.05;
                const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                ball.vx *= 0.995; ball.vy *= 0.995;
                ball.x += ball.vx; ball.y += ball.vy;
                ball.rotation += speed * 0.02;
                capSpeed(ball);
                ball.squashX += (1 - ball.squashX) * 0.12;
                ball.squashY += (1 - ball.squashY) * 0.12;
                
                if (speed < 1.5 && Date.now() - ball.lastHitTime > 3000) { ball.sleepy = true; ball.fadeProgress += 0.008; sleepyCount++; if (ball.fadeProgress >= 1) { balls.splice(i, 1); const a = Math.random() * Math.PI * 2, ns = 3 + Math.random() * 2; balls.push({ x: Math.random() * canvas.width, y: 100, vx: Math.cos(a) * ns, vy: Math.sin(a) * ns, radius: 35 + Math.random() * 20, rotation: 0, ballImage: getNextBallImage(), lastHitTime: Date.now(), sleepy: false, fadeProgress: 0, squashX: 1, squashY: 1 }); continue; } }
                else { ball.sleepy = false; ball.fadeProgress = Math.max(0, ball.fadeProgress - 0.02); ball.lastHitTime = Date.now(); }
                
                if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.9; ball.squashX = 0.7; ball.squashY = 1.3; }
                if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.9; ball.squashX = 0.7; ball.squashY = 1.3; }
                if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.9; ball.squashX = 1.3; ball.squashY = 0.7; }
                if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.9; ball.squashX = 1.3; ball.squashY = 0.7; }
                
                const dx = ball.x - gameState.mouseX, dy = ball.y - gameState.mouseY, dist = Math.sqrt(dx * dx + dy * dy), padR = 45;
                if (dist < ball.radius + padR) {
                    const mSpeed = Math.sqrt(mVx * mVx + mVy * mVy), force = Math.min(mSpeed * 0.5, 15), ang = Math.atan2(dy, dx);
                    ball.vx += Math.cos(ang) * force; ball.vy += Math.sin(ang) * force;
                    ball.squashX = 0.6 + Math.abs(Math.cos(ang)) * 0.3; ball.squashY = 0.6 + Math.abs(Math.sin(ang)) * 0.3;
                    const overlap = (ball.radius + padR) - dist;
                    ball.x += Math.cos(ang) * overlap; ball.y += Math.sin(ang) * overlap;
                    ball.lastHitTime = Date.now(); ball.sleepy = false;
                    if (force > 3) addScreenShake(force * 0.3);
                    capSpeed(ball);
                }
            }
            gameState.energy = Math.max(0, 100 - sleepyCount * 15);
            ballCollisionsWithSquash();
            gameState.lastMouseX = gameState.mouseX; gameState.lastMouseY = gameState.mouseY;
        }
        
        function ballCollisionsWithSquash() { for (let i = 0; i < balls.length; i++) { for (let j = i + 1; j < balls.length; j++) { const b1 = balls[i], b2 = balls[j]; const dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), minDist = b1.radius + b2.radius; if (dist < minDist) { const ang = Math.atan2(dy, dx), tx = b1.x + Math.cos(ang) * minDist, ty = b1.y + Math.sin(ang) * minDist, ax = (tx - b2.x) * 0.05, ay = (ty - b2.y) * 0.05; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; if (b1.squashX !== undefined) { b1.squashX = 0.85; b1.squashY = 1.15; } if (b2.squashX !== undefined) { b2.squashX = 0.85; b2.squashY = 1.15; } } } } }
        
        function drawPaddle() {
            balls.forEach(ball => { const op = 1 - ball.fadeProgress; if (ball.sleepy) { ctx.fillStyle = 'rgba(100, 100, 200, ' + (0.3 * op) + ')'; ctx.font = '20px Arial'; ctx.textAlign = 'center'; ctx.fillText('ðŸ’¤', ball.x, ball.y - ball.radius - 10); } drawBallWithSquash(ball, op, ball.rotation, ball.squashX || 1, ball.squashY || 1); });
            drawPerson(gameState.mouseX, gameState.mouseY + 25, 60, gameState.personIndex);
            ctx.beginPath(); ctx.arc(gameState.mouseX, gameState.mouseY, 45, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)'; ctx.lineWidth = 3; ctx.stroke();
            const bW = 150, bH = 12, bX = 20, bY = canvas.height - 85;
            ctx.fillStyle = '#ddd'; ctx.fillRect(bX, bY, bW, bH);
            ctx.fillStyle = gameState.energy > 50 ? '#4CAF50' : gameState.energy > 25 ? '#FFC107' : '#F44336'; ctx.fillRect(bX, bY, bW * (gameState.energy / 100), bH);
            ctx.strokeStyle = '#999'; ctx.lineWidth = 2; ctx.strokeRect(bX, bY, bW, bH);
            ctx.fillStyle = '#666'; ctx.font = '14px Arial'; ctx.textAlign = 'left'; ctx.fillText('Energy', bX, bY - 5);
        }
        function paddlePointerMove(x, y) { gameState.mouseX = x; gameState.mouseY = y; }
        
        // GAME 3: POP
        function initPopSpawn() {
            balls = []; gameState = { score: 0, particles: [], multiplier: 1, lastPopTime: 0 };
            for (let i = 0; i < 8; i++) { const a = Math.random() * Math.PI * 2, s = 0.8 + Math.random() * 0.8; balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a) * s, vy: Math.sin(a) * s, radius: 90 + Math.random() * 30, popping: false, popProgress: 0, opacity: 1, rotation: Math.random() * Math.PI * 2, ballImage: getNextBallImage(), hue: Math.random() * 360 }); }
        }
        function updatePopSpawn() {
            if (Date.now() - gameState.lastPopTime > 1500) gameState.multiplier = Math.max(1, gameState.multiplier - 0.02);
            gameState.particles = gameState.particles.filter(p => { p.x += p.vx; p.y += p.vy; p.vy += p.gravity || 0.1; p.life--; p.rotation = (p.rotation || 0) + (p.spin || 0); return p.life > 0; });
            for (let i = balls.length - 1; i >= 0; i--) { const ball = balls[i]; if (ball.popping) { ball.popProgress += 0.12; ball.opacity = 1 - ball.popProgress; if (ball.popProgress >= 1) balls.splice(i, 1); continue; } const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy); if (speed < 0.5) { const a = Math.atan2(ball.vy, ball.vx); ball.vx = Math.cos(a) * 0.8; ball.vy = Math.sin(a) * 0.8; } ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; ball.rotation += speed * 0.01; capSpeed(ball); if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.9; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.9; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.9; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.9; } }
            ballCollisions();
        }
        function drawPopSpawn() {
            gameState.particles.forEach(p => { const img = ballImages[p.ballImage - 1]; if (img && img.complete) { ctx.save(); ctx.globalAlpha = p.life / p.maxLife; ctx.translate(p.x, p.y); ctx.rotate(p.rotation); ctx.drawImage(img, -p.size/2, -p.size/2, p.size, p.size); ctx.restore(); } });
            balls.forEach(ball => { ctx.save(); ctx.globalAlpha = ball.opacity; if (ball.popping) { const sc = 1 + ball.popProgress * 0.8; ctx.translate(ball.x, ball.y); ctx.scale(sc, sc); ctx.rotate(ball.popProgress * 0.5); ctx.translate(-ball.x, -ball.y); } drawBall(ball, 1.0, ball.rotation); ctx.restore(); });
            ctx.fillStyle = '#333'; ctx.font = 'bold 24px Arial'; ctx.textAlign = 'left'; ctx.fillText('Score: ' + gameState.score, 20, canvas.height - 80);
            if (gameState.multiplier > 1) { ctx.fillStyle = 'hsl(' + ((gameState.multiplier - 1) * 60) + ', 80%, 50%)'; ctx.fillText('x' + gameState.multiplier.toFixed(1), 160, canvas.height - 80); }
        }
        function popSpawnPointerDown(x, y) {
            for (let i = balls.length - 1; i >= 0; i--) { if (!balls[i].popping && contains(balls[i], x, y)) { const ball = balls[i]; ball.popping = true; const sB = Math.floor(150 / ball.radius); gameState.score += Math.floor(sB * gameState.multiplier); gameState.multiplier = Math.min(5, gameState.multiplier + 0.3); gameState.lastPopTime = Date.now(); addScreenShake(ball.radius * 0.08); const nP = Math.floor(ball.radius * 0.25); for (let j = 0; j < nP; j++) { const a = Math.random() * Math.PI * 2, sp = 3 + Math.random() * 5; gameState.particles.push({ x: ball.x, y: ball.y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 2, size: 8 + Math.random() * 15, life: 40, maxLife: 40, rotation: Math.random() * Math.PI, spin: (Math.random() - 0.5) * 0.2, gravity: 0.15, ballImage: ball.ballImage }); } if (ball.radius > 25) { const cR = ball.radius * 0.55, nC = 2 + Math.floor(Math.random() * 2); for (let j = 0; j < nC; j++) { const a = (Math.PI * 2 / nC) * j + Math.random() * 0.5, sp = 4 + Math.random() * 4; balls.push({ x: ball.x, y: ball.y, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp, radius: cR, popping: false, popProgress: 0, opacity: 1, rotation: Math.random() * Math.PI * 2, ballImage: getNextBallImage(), hue: ball.hue + Math.random() * 40 - 20 }); } } break; } }
        }
        
        // GAME 4: VACUUM
        function initVacuum() { balls = []; gameState = { mouseX: canvas.width/2, mouseY: canvas.height/2, isVacuuming: false, vacuumStrength: 0 }; for (let i = 0; i < 25; i++) balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3, radius: 30 + Math.random() * 25, ballImage: getNextBallImage() }); }
        function updateVacuum() {
            if (gameState.isVacuuming) gameState.vacuumStrength = Math.min(gameState.vacuumStrength + 3, 100);
            balls.forEach(ball => { if (gameState.isVacuuming) { const dx = gameState.mouseX - ball.x, dy = gameState.mouseY - ball.y, dist = Math.sqrt(dx * dx + dy * dy), force = Math.min(gameState.vacuumStrength / (dist + 30), 4); ball.vx += (dx / dist) * force; ball.vy += (dy / dist) * force; } if (ball.x < canvas.width / 2) ball.vx -= 0.15; else ball.vx += 0.15; ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.9; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.9; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.9; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.9; } });
            ballCollisions();
        }
        function drawVacuum() { if (gameState.isVacuuming) { const maxR = 150; for (let i = 0; i < 3; i++) { ctx.beginPath(); const r = maxR * (1 - i * 0.3) * (gameState.vacuumStrength / 100); ctx.arc(gameState.mouseX, gameState.mouseY, r, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(100, 100, 100, ' + (0.3 - i * 0.1) + ')'; ctx.lineWidth = 3; ctx.stroke(); } ctx.beginPath(); ctx.arc(gameState.mouseX, gameState.mouseY, 10, 0, Math.PI * 2); ctx.fillStyle = '#666'; ctx.fill(); } balls.forEach(ball => drawBall(ball)); }
        function vacuumPointerDown(x, y) { gameState.mouseX = x; gameState.mouseY = y; gameState.isVacuuming = true; gameState.vacuumStrength = 0; }
        function vacuumPointerMove(x, y) { gameState.mouseX = x; gameState.mouseY = y; }
        function vacuumPointerUp() { if (gameState.isVacuuming) { addScreenShake(gameState.vacuumStrength * 0.1); balls.forEach(ball => { const dx = ball.x - gameState.mouseX, dy = ball.y - gameState.mouseY, dist = Math.sqrt(dx * dx + dy * dy), force = Math.min(5000 / (dist + 50), 20); ball.vx += (dx / dist) * force; ball.vy += (dy / dist) * force; capSpeed(ball); }); gameState.isVacuuming = false; gameState.vacuumStrength = 0; } }
        
        // GAME 5: GRAVITY FLIP
        function initGravityFlip() { balls = []; gameState = { gravityDir: 1 }; for (let i = 0; i < 18; i++) balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, radius: 25 + Math.random() * 20, ballImage: getNextBallImage() }); }
        function updateGravityFlip() { balls.forEach(ball => { ball.vy += 0.25 * gameState.gravityDir; ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.75; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.75; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.75; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.75; } }); ballCollisions(); }
        function drawGravityFlip() { balls.forEach(ball => drawBall(ball)); const aY = gameState.gravityDir === 1 ? canvas.height - 30 : 30; ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; ctx.font = 'bold 24px Arial'; ctx.textAlign = 'center'; ctx.fillText(gameState.gravityDir === 1 ? 'â†“' : 'â†‘', canvas.width / 2, aY); }
        function gravityFlipPointerDown() { gameState.gravityDir *= -1; addScreenShake(4); }
        
        // GAME 6: DRAW BARRIERS
        function initDrawBarriers() { balls = []; gameState = { barriers: [], drawing: false, drawStart: null, drawEnd: null, splats: [], saved: 0, lost: 0, maxBarriers: 5, maxLineLength: 250, barrierLifetime: 12000 }; for (let i = 0; i < 4; i++) spawnBarrierBall(); }
        function spawnBarrierBall() { balls.push({ x: 100 + Math.random() * (canvas.width - 200), y: -50, vx: (Math.random() - 0.5) * 2, vy: 0.8 + Math.random() * 0.5, radius: 25 + Math.random() * 20, ballImage: getNextBallImage(), dying: false, deathProgress: 0 }); }
        function updateDrawBarriers() {
            gameState.barriers = gameState.barriers.filter(b => Date.now() - b.created < gameState.barrierLifetime);
            gameState.splats = gameState.splats.filter(s => s.life > 0); gameState.splats.forEach(s => s.life--);
            for (let i = balls.length - 1; i >= 0; i--) { const ball = balls[i]; if (ball.dying) { ball.deathProgress += 0.08; if (ball.deathProgress >= 1) { balls.splice(i, 1); spawnBarrierBall(); gameState.lost++; } continue; } ball.vy += 0.06; ball.vx *= 0.99; ball.vy *= 0.99; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (ball.y + ball.radius >= canvas.height - 5 && !ball.dying) { ball.dying = true; ball.deathProgress = 0; addScreenShake(5); gameState.splats.push({ x: ball.x, y: canvas.height, radius: ball.radius, life: 120, color: 'hsl(' + (Math.random() * 360) + ', 60%, 50%)' }); continue; } if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -1; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -1; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -1; } gameState.barriers.forEach(barrier => { const result = lineCircleCollision(barrier.x1, barrier.y1, barrier.x2, barrier.y2, ball.x, ball.y, ball.radius); if (result.collides) { ball.x = result.newX; ball.y = result.newY; const ang = Math.atan2(barrier.y2 - barrier.y1, barrier.x2 - barrier.x1), nAng = ang + Math.PI / 2, dot = ball.vx * Math.cos(nAng) + ball.vy * Math.sin(nAng); ball.vx -= 2 * dot * Math.cos(nAng) * 1.1; ball.vy -= 2 * dot * Math.sin(nAng) * 1.1; capSpeed(ball); gameState.saved++; } }); }
            ballCollisions();
        }
        function drawDrawBarriers() {
            gameState.splats.forEach(splat => { const a = splat.life / 120, sq = 1 + (1 - a) * 2; ctx.save(); ctx.globalAlpha = a * 0.6; ctx.translate(splat.x, splat.y); ctx.scale(sq, 0.3); ctx.beginPath(); ctx.arc(0, 0, splat.radius, 0, Math.PI * 2); ctx.fillStyle = splat.color; ctx.fill(); ctx.restore(); });
            balls.forEach(ball => { if (ball.dying) { ctx.save(); const sqY = 1 - ball.deathProgress * 0.8, sqX = 1 + ball.deathProgress * 0.5; ctx.translate(ball.x, canvas.height); ctx.scale(sqX, sqY); ctx.translate(-ball.x, -canvas.height); ctx.globalAlpha = 1 - ball.deathProgress; drawBall({...ball, y: canvas.height - ball.radius * sqY}); ctx.restore(); } else drawBall(ball); });
            gameState.barriers.forEach(barrier => { const age = Date.now() - barrier.created, op = Math.max(0, 1 - age / gameState.barrierLifetime); ctx.save(); ctx.shadowColor = 'rgba(100, 180, 255, 0.8)'; ctx.shadowBlur = 15 * op; ctx.beginPath(); ctx.moveTo(barrier.x1, barrier.y1); ctx.lineTo(barrier.x2, barrier.y2); ctx.strokeStyle = 'rgba(80, 150, 220, ' + op + ')'; ctx.lineWidth = 8; ctx.lineCap = 'round'; ctx.stroke(); ctx.restore(); ctx.beginPath(); ctx.moveTo(barrier.x1, barrier.y1); ctx.lineTo(barrier.x2, barrier.y2); ctx.strokeStyle = 'rgba(255, 255, 255, ' + (op * 0.9) + ')'; ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.stroke(); });
            if (gameState.drawing && gameState.drawStart) { let dx = gameState.drawEnd.x - gameState.drawStart.x, dy = gameState.drawEnd.y - gameState.drawStart.y, len = Math.sqrt(dx * dx + dy * dy); if (len > gameState.maxLineLength) { dx = (dx / len) * gameState.maxLineLength; dy = (dy / len) * gameState.maxLineLength; } const endX = gameState.drawStart.x + dx, endY = gameState.drawStart.y + dy; ctx.save(); ctx.shadowColor = 'rgba(100, 180, 255, 0.5)'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.moveTo(gameState.drawStart.x, gameState.drawStart.y); ctx.lineTo(endX, endY); ctx.strokeStyle = len > gameState.maxLineLength ? 'rgba(255, 100, 100, 0.5)' : 'rgba(80, 150, 220, 0.5)'; ctx.lineWidth = 8; ctx.lineCap = 'round'; ctx.stroke(); ctx.restore(); }
            ctx.fillStyle = '#666'; ctx.font = 'bold 18px Arial'; ctx.textAlign = 'left'; ctx.fillText('Saved: ' + gameState.saved + '  Lost: ' + gameState.lost, 20, canvas.height - 85);
            const rem = gameState.maxBarriers - gameState.barriers.length; ctx.fillStyle = rem > 0 ? '#4A4' : '#A44'; ctx.fillText('Lines: ' + rem + '/' + gameState.maxBarriers, 20, canvas.height - 60);
        }
        function barrierPointerDown(x, y) { if (gameState.barriers.length >= gameState.maxBarriers) return; gameState.drawing = true; gameState.drawStart = { x, y }; gameState.drawEnd = { x, y }; }
        function barrierPointerMove(x, y) { if (gameState.drawing) gameState.drawEnd = { x, y }; }
        function barrierPointerUp() { if (gameState.drawing && gameState.drawStart && gameState.drawEnd) { let dx = gameState.drawEnd.x - gameState.drawStart.x, dy = gameState.drawEnd.y - gameState.drawStart.y, len = Math.sqrt(dx * dx + dy * dy); if (len > 20) { if (len > gameState.maxLineLength) { dx = (dx / len) * gameState.maxLineLength; dy = (dy / len) * gameState.maxLineLength; } gameState.barriers.push({ x1: gameState.drawStart.x, y1: gameState.drawStart.y, x2: gameState.drawStart.x + dx, y2: gameState.drawStart.y + dy, created: Date.now() }); } } gameState.drawing = false; gameState.drawStart = null; gameState.drawEnd = null; }
        
        // GAME 7: MAGNET ZONES
        function initMagnetZones() { balls = []; gameState = { magnets: [], shiftPressed: false }; for (let i = 0; i < 20; i++) balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3, radius: 18 + Math.random() * 15, ballImage: getNextBallImage() }); }
        function updateMagnetZones() {
            gameState.magnets = gameState.magnets.filter(m => Date.now() - m.created < 10000);
            balls.forEach(ball => { ball.vy += 0.15; gameState.magnets.forEach(magnet => { const dx = magnet.x - ball.x, dy = magnet.y - ball.y, dist = Math.sqrt(dx * dx + dy * dy), force = (magnet.type === 'attract' ? 1 : -1) * Math.min(200 / (dist + 20), 4); ball.vx += (dx / dist) * force; ball.vy += (dy / dist) * force; }); ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.7; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.7; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.7; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.7; } });
            ballCollisions();
        }
        function drawMagnetZones() {
            gameState.magnets.forEach(magnet => { const age = Date.now() - magnet.created, op = Math.max(0, 1 - age / 10000), isAttr = magnet.type === 'attract', time = Date.now() * 0.003;
                if (isAttr) { for (let i = 0; i < 4; i++) { const bR = 100 - ((time * 30 + i * 25) % 100); ctx.beginPath(); ctx.arc(magnet.x, magnet.y, bR, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(50, 150, 255, ' + (op * (0.5 - i * 0.1)) + ')'; ctx.lineWidth = 3; ctx.stroke(); } const g = ctx.createRadialGradient(magnet.x, magnet.y, 0, magnet.x, magnet.y, 60); g.addColorStop(0, 'rgba(50, 150, 255, ' + (op * 0.4) + ')'); g.addColorStop(1, 'rgba(50, 150, 255, 0)'); ctx.beginPath(); ctx.arc(magnet.x, magnet.y, 60, 0, Math.PI * 2); ctx.fillStyle = g; ctx.fill(); }
                else { for (let i = 0; i < 4; i++) { const bR = 20 + ((time * 30 + i * 25) % 100); ctx.beginPath(); ctx.arc(magnet.x, magnet.y, bR, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(255, 80, 80, ' + (op * (0.5 - i * 0.1)) + ')'; ctx.lineWidth = 3; ctx.stroke(); } const g = ctx.createRadialGradient(magnet.x, magnet.y, 0, magnet.x, magnet.y, 60); g.addColorStop(0, 'rgba(255, 80, 80, ' + (op * 0.4) + ')'); g.addColorStop(1, 'rgba(255, 80, 80, 0)'); ctx.beginPath(); ctx.arc(magnet.x, magnet.y, 60, 0, Math.PI * 2); ctx.fillStyle = g; ctx.fill(); }
                drawPerson(magnet.x, magnet.y + 80, 55, magnet.personIndex, op);
                ctx.font = 'bold 28px Arial'; ctx.textAlign = 'center'; ctx.fillStyle = isAttr ? 'rgba(50, 150, 255, ' + op + ')' : 'rgba(255, 80, 80, ' + op + ')'; ctx.fillText(isAttr ? 'âŠ•' : 'âŠ–', magnet.x, magnet.y - 5);
            });
            balls.forEach(ball => drawBall(ball));
            ctx.fillStyle = '#666'; ctx.font = '14px Arial'; ctx.textAlign = 'left'; ctx.fillText(gameState.shiftPressed ? 'Mode: REPEL (red)' : 'Mode: ATTRACT (blue) [hold SHIFT for repel]', 20, canvas.height - 80);
        }
        function magnetPointerDown(x, y) { gameState.magnets.push({ x, y, type: gameState.shiftPressed ? 'repel' : 'attract', created: Date.now(), personIndex: getNextPersonImage() }); }
        
        // GAME 8: EXPLODE
        function initBallCannon() { balls = []; gameState = { chargeStart: 0, charging: false, chargeX: 0, chargeY: 0, totalBalls: 0 }; }
        function updateBallCannon() { for (let i = balls.length - 1; i >= 0; i--) { const ball = balls[i]; ball.vy += 0.2; ball.vx *= 0.99; ball.vy *= 0.99; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); ball.life--; ball.opacity = Math.min(1, ball.life / 60); if (ball.life <= 0 || ball.y > canvas.height + 50) { balls.splice(i, 1); continue; } if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.7; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.7; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.7; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.7; } } ballCollisions(); }
        function drawBallCannon() { if (gameState.charging) { const cT = Date.now() - gameState.chargeStart, cA = Math.min(cT / 1000, 1), r = 20 + cA * 60, pulse = Math.sin(Date.now() * 0.02) * 5; ctx.beginPath(); ctx.arc(gameState.chargeX, gameState.chargeY, r + pulse, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(100, 100, 100, ' + (0.3 + cA * 0.4) + ')'; ctx.lineWidth = 3 + cA * 3; ctx.stroke(); ctx.beginPath(); ctx.arc(gameState.chargeX, gameState.chargeY, r * 0.3, 0, Math.PI * 2); ctx.fillStyle = 'rgba(80, 80, 80, ' + (0.3 + cA * 0.5) + ')'; ctx.fill(); ctx.fillStyle = '#666'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.fillText(Math.floor(cA * 100) + '%', gameState.chargeX, gameState.chargeY + r + 25); } balls.forEach(ball => { ctx.save(); ctx.globalAlpha = ball.opacity; drawBall(ball); ctx.restore(); }); ctx.fillStyle = '#666'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'left'; ctx.fillText('Balls launched: ' + gameState.totalBalls, 20, canvas.height - 80); }
        function cannonPointerDown(x, y) { gameState.charging = true; gameState.chargeStart = Date.now(); gameState.chargeX = x; gameState.chargeY = y; }
        function cannonPointerUp() { if (!gameState.charging) return; const cT = Date.now() - gameState.chargeStart, cA = Math.min(cT / 1000, 1), power = 5 + cA * 12, numBalls = Math.floor(8 + cA * 12); addScreenShake(cA * 10); for (let i = 0; i < numBalls; i++) { const ang = (Math.PI * 2 / numBalls) * i + Math.random() * 0.2, sV = 0.7 + Math.random() * 0.6; balls.push({ x: gameState.chargeX, y: gameState.chargeY, vx: Math.cos(ang) * power * sV, vy: Math.sin(ang) * power * sV, radius: 12 + Math.random() * 18, life: 150 + Math.random() * 100, opacity: 1, ballImage: getNextBallImage() }); gameState.totalBalls++; } gameState.charging = false; }
        
        // GAME 9: ORBITAL
        function initOrbital() { balls = []; gameState = { mouseX: canvas.width/2, mouseY: canvas.height/2 }; for (let i = 0; i < 40; i++) { const ang = (Math.PI * 2 / 40) * i, dist = 60 + Math.random() * 180; balls.push({ angle: ang, distance: dist, angleSpeed: (0.02 + Math.random() * 0.04) * (Math.random() > 0.5 ? 1 : -1), radius: 15 + Math.random() * 18, orbiting: true, vx: 0, vy: 0, x: 0, y: 0, ballImage: getNextBallImage() }); } }
        function updateOrbital() { balls.forEach(ball => { if (ball.orbiting) { ball.angle += ball.angleSpeed; ball.x = gameState.mouseX + Math.cos(ball.angle) * ball.distance; ball.y = gameState.mouseY + Math.sin(ball.angle) * ball.distance; } else { ball.vy += 0.2; ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.7; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.7; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.7; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.7; } } }); const freeBalls = balls.filter(b => !b.orbiting); for (let i = 0; i < freeBalls.length; i++) { for (let j = i + 1; j < freeBalls.length; j++) { const b1 = freeBalls[i], b2 = freeBalls[j], dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), minDist = b1.radius + b2.radius; if (dist < minDist) { const ang = Math.atan2(dy, dx), tx = b1.x + Math.cos(ang) * minDist, ty = b1.y + Math.sin(ang) * minDist, ax = (tx - b2.x) * 0.05, ay = (ty - b2.y) * 0.05; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; } } } }
        function drawOrbital() { balls.filter(b => b.orbiting).forEach(ball => { ctx.beginPath(); ctx.arc(gameState.mouseX, gameState.mouseY, ball.distance, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(200, 200, 200, 0.2)'; ctx.lineWidth = 1; ctx.stroke(); }); balls.forEach(ball => drawBall(ball, ball.orbiting ? 0.8 : 1.0)); ctx.beginPath(); ctx.arc(gameState.mouseX, gameState.mouseY, 5, 0, Math.PI * 2); ctx.fillStyle = '#999'; ctx.fill(); }
        function orbitalPointerMove(x, y) { gameState.mouseX = x; gameState.mouseY = y; }
        function orbitalPointerDown() { balls.forEach(ball => { if (ball.orbiting) { ball.orbiting = false; const oS = 8 + Math.random() * 4, tS = Math.abs(ball.angleSpeed) * ball.distance * 2; ball.vx = Math.cos(ball.angle + Math.PI / 2) * tS + Math.cos(ball.angle) * oS; ball.vy = Math.sin(ball.angle + Math.PI / 2) * tS + Math.sin(ball.angle) * oS; capSpeed(ball); } }); }
        
        // GAME 10: TRANSFORM
        function initFreezeFrame() { balls = []; gameState = { score: 0, breaches: 0, centerRadius: 120, centerX: canvas.width / 2, centerY: canvas.height / 2, centerVx: 0.5, centerVy: 0.3, boredomThreshold: 300 }; for (let i = 0; i < 15; i++) spawnTransformBall(); }
        function spawnTransformBall() { const side = Math.floor(Math.random() * 4); let x, y, vx, vy; switch(side) { case 0: x = Math.random() * canvas.width; y = -30; vx = (Math.random() - 0.5) * 2; vy = 1.5 + Math.random(); break; case 1: x = canvas.width + 30; y = Math.random() * canvas.height; vx = -1.5 - Math.random(); vy = (Math.random() - 0.5) * 2; break; case 2: x = Math.random() * canvas.width; y = canvas.height + 30; vx = (Math.random() - 0.5) * 2; vy = -1.5 - Math.random(); break; case 3: x = -30; y = Math.random() * canvas.height; vx = 1.5 + Math.random(); vy = (Math.random() - 0.5) * 2; break; } balls.push({ x, y, vx, vy, radius: 25 + Math.random() * 20, ballImage: getNextBallImage(), peopleImage: getNextPersonImage(), isGuard: false, breached: false, guardTime: 0, boredom: 0 }); }
        function updateFreezeFrame() {
            gameState.centerX += gameState.centerVx; gameState.centerY += gameState.centerVy;
            const margin = gameState.centerRadius + 50;
            if (gameState.centerX < margin || gameState.centerX > canvas.width - margin) gameState.centerVx *= -1;
            if (gameState.centerY < margin || gameState.centerY > canvas.height - margin) gameState.centerVy *= -1;
            for (let i = balls.length - 1; i >= 0; i--) { const ball = balls[i];
                if (ball.isGuard) { ball.guardTime++; ball.boredom += 0.5; if (ball.boredom > gameState.boredomThreshold && Math.random() < 0.01) { ball.isGuard = false; ball.boredom = 0; ball.vx = (Math.random() - 0.5) * 4; ball.vy = (Math.random() - 0.5) * 4; continue; } const dx = gameState.centerX - ball.x, dy = gameState.centerY - ball.y, dist = Math.sqrt(dx * dx + dy * dy), patrolDist = gameState.centerRadius + 80; if (dist < patrolDist - 10) { ball.vx -= dx / dist * 0.12; ball.vy -= dy / dist * 0.12; } else if (dist > patrolDist + 10) { ball.vx += dx / dist * 0.12; ball.vy += dy / dist * 0.12; } const perpX = -dy / dist, perpY = dx / dist; ball.vx += perpX * 0.06; ball.vy += perpY * 0.06; ball.vx *= 0.97; ball.vy *= 0.97; ball.x += ball.vx; ball.y += ball.vy; for (let j = balls.length - 1; j >= 0; j--) { if (i === j || balls[j].isGuard) continue; const enemy = balls[j], edx = enemy.x - ball.x, edy = enemy.y - ball.y, eDist = Math.sqrt(edx * edx + edy * edy); if (eDist < ball.radius + enemy.radius + 15) { const ang = Math.atan2(edy, edx); enemy.vx = Math.cos(ang) * 6; enemy.vy = Math.sin(ang) * 6; gameState.score++; ball.boredom = Math.max(0, ball.boredom - 50); addScreenShake(4); } } }
                else { const dx = gameState.centerX - ball.x, dy = gameState.centerY - ball.y, dist = Math.sqrt(dx * dx + dy * dy); ball.vx += dx / dist * 0.03; ball.vy += dy / dist * 0.03; ball.vx *= 0.99; ball.vy *= 0.99; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (dist < gameState.centerRadius && !ball.breached) { ball.breached = true; gameState.breaches++; addScreenShake(8); } if (ball.x < -100 || ball.x > canvas.width + 100 || ball.y < -100 || ball.y > canvas.height + 100) { balls.splice(i, 1); spawnTransformBall(); } }
                if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.8; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.8; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.8; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.8; }
            }
        }
        function drawFreezeFrame() {
            ctx.beginPath(); ctx.arc(gameState.centerX, gameState.centerY, gameState.centerRadius, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 215, 100, 0.2)'; ctx.fill(); ctx.strokeStyle = 'rgba(255, 180, 50, 0.5)'; ctx.lineWidth = 3; ctx.stroke();
            ctx.beginPath(); ctx.arc(gameState.centerX, gameState.centerY, gameState.centerRadius + 80, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(100, 200, 100, 0.2)'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
            balls.forEach(ball => { if (ball.isGuard) { drawPerson(ball.x, ball.y + ball.radius, ball.radius * 2.5, ball.peopleImage); const bR = ball.boredom / gameState.boredomThreshold, aC = bR > 0.7 ? 'rgba(200, 200, 100, 0.4)' : 'rgba(100, 200, 100, 0.4)'; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius + 20, 0, Math.PI * 2); ctx.strokeStyle = aC; ctx.lineWidth = 2; ctx.stroke(); if (bR > 0.5) { ctx.fillStyle = 'rgba(200, 200, 100, ' + bR + ')'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.fillText('ðŸ˜´', ball.x, ball.y - ball.radius - 15); } } else drawBall(ball, ball.breached ? 0.5 : 1.0); });
            ctx.fillStyle = '#4A4'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'left'; ctx.fillText('Deflected: ' + gameState.score, 20, canvas.height - 85);
            ctx.fillStyle = '#A44'; ctx.fillText('Breached: ' + gameState.breaches, 20, canvas.height - 60);
            ctx.fillStyle = '#666'; ctx.fillText('Guards: ' + balls.filter(b => b.isGuard).length, 200, canvas.height - 85);
        }
        function freezePointerDown(x, y) { for (let i = balls.length - 1; i >= 0; i--) { if (contains(balls[i], x, y)) { balls[i].isGuard = !balls[i].isGuard; balls[i].boredom = 0; break; } } }
        
        // GAME 11: CONNECTIONS
        function initRubberBands() { balls = []; gameState = { connections: [], firstEntity: null, score: 0, exploded: 0, timer: 0, pressure: 0 }; for (let i = 0; i < 8; i++) { const a = Math.random() * Math.PI * 2, s = 1.5 + Math.random() * 1.5; balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a) * s, vy: Math.sin(a) * s, radius: 25 + Math.random() * 15, ballImage: getNextBallImage(), type: 'ball' }); } for (let i = 0; i < 8; i++) { const a = Math.random() * Math.PI * 2, s = 1 + Math.random(); balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a) * s, vy: Math.sin(a) * s, radius: 25, personImage: getNextPersonImage(), type: 'person' }); } }
        function updateRubberBands() { gameState.timer++; gameState.pressure = Math.sin(gameState.timer * 0.01) * 0.5 + 0.5; gameState.connections.forEach(conn => { const b1 = conn.entity1, b2 = conn.entity2; if (!balls.includes(b1) || !balls.includes(b2)) return; const dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), stretch = dist - conn.restLength, force = stretch * 0.02, fx = (dx / dist) * force, fy = (dy / dist) * force; b1.vx += fx; b1.vy += fy; b2.vx -= fx; b2.vy -= fy; }); balls.forEach(ball => { const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy); if (speed < 0.3) { const a = Math.atan2(ball.vy, ball.vx); ball.vx = Math.cos(a) * 0.8; ball.vy = Math.sin(a) * 0.8; } ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.8; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.8; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.8; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.8; } }); for (let i = 0; i < balls.length; i++) { for (let j = i + 1; j < balls.length; j++) { const b1 = balls[i], b2 = balls[j], dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), minDist = b1.radius + b2.radius; if (dist < minDist && dist > 0) { const ang = Math.atan2(dy, dx), ax = (minDist - dist) * Math.cos(ang) * 0.05, ay = (minDist - dist) * Math.sin(ang) * 0.05; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; } } } }
        function drawRubberBands() { const pW = 200, pH = 15, pX = canvas.width / 2 - pW / 2, pY = canvas.height - 50; ctx.fillStyle = '#ddd'; ctx.fillRect(pX, pY, pW, pH); ctx.fillStyle = 'hsl(' + (120 - gameState.pressure * 120) + ', 70%, 50%)'; ctx.fillRect(pX, pY, pW * gameState.pressure, pH); ctx.strokeStyle = '#999'; ctx.lineWidth = 2; ctx.strokeRect(pX, pY, pW, pH); ctx.fillStyle = '#666'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('Connection Pressure', canvas.width / 2, pY - 5); gameState.connections.forEach(conn => { if (!balls.includes(conn.entity1) || !balls.includes(conn.entity2)) return; ctx.beginPath(); ctx.moveTo(conn.entity1.x, conn.entity1.y); ctx.lineTo(conn.entity2.x, conn.entity2.y); ctx.strokeStyle = 'rgba(100, 200, 100, 0.6)'; ctx.lineWidth = 3; ctx.stroke(); }); balls.forEach(entity => { const isSel = gameState.firstEntity === entity; if (entity.type === 'person') { if (isSel) { ctx.beginPath(); ctx.arc(entity.x, entity.y, entity.radius + 10, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(100, 200, 255, 0.8)'; ctx.lineWidth = 3; ctx.stroke(); } drawPerson(entity.x, entity.y + 10, 50, entity.personImage); } else { if (isSel) { ctx.beginPath(); ctx.arc(entity.x, entity.y, entity.radius + 10, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(100, 200, 255, 0.8)'; ctx.lineWidth = 3; ctx.stroke(); } drawBall(entity); } }); ctx.fillStyle = '#4A4'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'left'; ctx.fillText('Connections: ' + gameState.score, 20, canvas.height - 85); ctx.fillStyle = '#A44'; ctx.fillText('Exploded: ' + gameState.exploded, 20, canvas.height - 60); if (gameState.firstEntity) { ctx.fillStyle = '#666'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; const tT = gameState.firstEntity.type === 'person' ? 'person' : 'ball'; ctx.fillText('Selected: ' + tT + ' - click a ' + (tT === 'person' ? 'ball' : 'person') + ' to connect!', canvas.width / 2, 160); } }
        function rubberBandPointerDown(x, y) { for (let i = balls.length - 1; i >= 0; i--) { if (contains(balls[i], x, y)) { const clicked = balls[i]; if (!gameState.firstEntity) gameState.firstEntity = clicked; else if (gameState.firstEntity !== clicked) { if (gameState.firstEntity.type === clicked.type) { addScreenShake(15); gameState.exploded++; gameState.connections = gameState.connections.filter(c => c.entity1 !== gameState.firstEntity && c.entity2 !== gameState.firstEntity && c.entity1 !== clicked && c.entity2 !== clicked); const idx1 = balls.indexOf(gameState.firstEntity), idx2 = balls.indexOf(clicked); if (idx1 > idx2) { balls.splice(idx1, 1); balls.splice(idx2, 1); } else { balls.splice(idx2, 1); balls.splice(idx1, 1); } setTimeout(() => { const a1 = Math.random() * Math.PI * 2, a2 = Math.random() * Math.PI * 2; balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a1) * 2, vy: Math.sin(a1) * 2, radius: 25 + Math.random() * 15, ballImage: getNextBallImage(), type: 'ball' }); balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a2) * 1.5, vy: Math.sin(a2) * 1.5, radius: 25, personImage: getNextPersonImage(), type: 'person' }); }, 500); } else { const existingConn = gameState.connections.find(c => (c.entity1 === gameState.firstEntity && c.entity2 === clicked) || (c.entity2 === gameState.firstEntity && c.entity1 === clicked)); if (!existingConn) { const dx = clicked.x - gameState.firstEntity.x, dy = clicked.y - gameState.firstEntity.y, dist = Math.sqrt(dx * dx + dy * dy); gameState.connections.push({ entity1: gameState.firstEntity, entity2: clicked, restLength: Math.min(dist, 150) }); gameState.score++; } } gameState.firstEntity = null; } return; } } gameState.firstEntity = null; }
        
        // GAME 12: MERGE & SPLIT
        function initMergeSplit() { balls = []; gameState = { mergingPairs: [], victory: false }; for (let i = 0; i < 12; i++) { const a = Math.random() * Math.PI * 2, s = 1 + Math.random() * 1.5, ball = { x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a) * s, vy: Math.sin(a) * s, radius: 35 + Math.random() * 15, mass: 1, id: Date.now() + Math.random(), ballImage: getNextBallImage(), spinAngle: 0, merging: false, walkers: [] }; ball.walkers.push({ angle: Math.random() * Math.PI * 2, walkSpeed: 0.015 + Math.random() * 0.015, direction: Math.random() > 0.5 ? 1 : -1, personIndex: getNextPersonImage() }); balls.push(ball); } }
        function updateMergeSplit() {
            if (balls.length === 1 && !gameState.victory) { gameState.victory = true; addScreenShake(15); }
            for (let p = gameState.mergingPairs.length - 1; p >= 0; p--) { const pair = gameState.mergingPairs[p]; pair.progress += 0.025; const b1 = pair.ball1, b2 = pair.ball2; if (!balls.includes(b1) || !balls.includes(b2)) { gameState.mergingPairs.splice(p, 1); continue; } const dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), pullF = 0.4; b1.vx += (dx / dist) * pullF; b1.vy += (dy / dist) * pullF; b2.vx -= (dx / dist) * pullF; b2.vy -= (dy / dist) * pullF; b1.spinAngle += 0.15; b2.spinAngle -= 0.15; if (pair.progress >= 1 || dist < 20) { const tM = b1.mass + b2.mass, nR = Math.sqrt(b1.radius * b1.radius + b2.radius * b2.radius), cW = [...b1.walkers, ...b2.walkers]; cW.forEach((w, idx) => { w.angle = (Math.PI * 2 / cW.length) * idx; }); const newBall = { x: (b1.x * b1.mass + b2.x * b2.mass) / tM, y: (b1.y * b1.mass + b2.y * b2.mass) / tM, vx: (b1.vx * b1.mass + b2.vx * b2.mass) / tM, vy: (b1.vy * b1.mass + b2.vy * b2.mass) / tM, radius: nR, mass: tM, id: Date.now() + Math.random(), ballImage: getNextBallImage(), spinAngle: 0, merging: false, walkers: cW }; const i1 = balls.indexOf(b1), i2 = balls.indexOf(b2); if (i1 > i2) { balls.splice(i1, 1); balls.splice(i2, 1); } else { balls.splice(i2, 1); balls.splice(i1, 1); } balls.push(newBall); addScreenShake(6); gameState.mergingPairs.splice(p, 1); } }
            balls.forEach(ball => { if (ball.merging) return; ball.walkers.forEach(w => { w.angle += w.walkSpeed * w.direction; }); const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy); if (speed < 0.4) { const a = Math.atan2(ball.vy, ball.vx); ball.vx = Math.cos(a) * 0.8; ball.vy = Math.sin(a) * 0.8; } ball.vx *= 0.99; ball.vy *= 0.99; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.8; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.8; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.8; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.8; } });
            for (let i = balls.length - 1; i >= 0; i--) { for (let j = i - 1; j >= 0; j--) { const b1 = balls[i], b2 = balls[j]; if (b1.merging || b2.merging) continue; const dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), minDist = b1.radius + b2.radius; if (dist < minDist * 0.9) { const rVx = b2.vx - b1.vx, rVy = b2.vy - b1.vy, rS = Math.sqrt(rVx * rVx + rVy * rVy); if (rS < 2.5) { b1.merging = true; b2.merging = true; gameState.mergingPairs.push({ ball1: b1, ball2: b2, progress: 0 }); } else { const ang = Math.atan2(dy, dx), ax = (minDist - dist) * Math.cos(ang) * 0.1, ay = (minDist - dist) * Math.sin(ang) * 0.1; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; } } } }
        }
        function drawMergeSplit() { balls.forEach(ball => { ctx.save(); if (ball.merging) { ctx.translate(ball.x, ball.y); ctx.rotate(ball.spinAngle); ctx.translate(-ball.x, -ball.y); } drawBall(ball); ctx.restore(); const bpH = 25, sF = Math.sqrt(ball.mass), pH = Math.min(bpH * sF, ball.radius * 0.8); ball.walkers.forEach(w => { const wX = ball.x + Math.cos(w.angle) * ball.radius, wY = ball.y + Math.sin(w.angle) * ball.radius, rot = w.angle + Math.PI / 2; drawPerson(wX, wY, pH, w.personIndex, 1.0, rot); }); if (ball.mass > 1) { ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(ball.mass, ball.x, ball.y); } }); ctx.fillStyle = '#666'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'left'; ctx.fillText('Worlds: ' + balls.length, 20, canvas.height - 80); if (gameState.victory) { ctx.fillStyle = '#4A4'; ctx.font = 'bold 32px Arial'; ctx.textAlign = 'center'; ctx.fillText('ðŸŒ One World! ðŸŒ', canvas.width / 2, 160); } }
        function mergeSplitPointerDown(x, y) { for (let i = balls.length - 1; i >= 0; i--) { if (contains(balls[i], x, y) && balls[i].mass > 1 && !balls[i].merging) { const ball = balls[i], numS = Math.min(ball.mass, 4), wPN = Math.floor(ball.walkers.length / numS); for (let j = 0; j < numS; j++) { const ang = (Math.PI * 2 / numS) * j, sp = 3 + Math.random() * 2, nB = { x: ball.x, y: ball.y, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp, radius: ball.radius / Math.sqrt(numS), mass: 1, id: Date.now() + Math.random() + j, ballImage: getNextBallImage(), spinAngle: 0, merging: false, walkers: ball.walkers.slice(j * wPN, (j + 1) * wPN) }; if (nB.walkers.length === 0) nB.walkers.push({ angle: Math.random() * Math.PI * 2, walkSpeed: 0.015 + Math.random() * 0.015, direction: Math.random() > 0.5 ? 1 : -1, personIndex: getNextPersonImage() }); balls.push(nB); } balls.splice(i, 1); gameState.victory = false; addScreenShake(5); break; } } }
        
        // GAME 13: INFLATE
        function initInflate() { balls = []; gameState = { people: [], poppedCount: 0, clickPushed: 0 }; for (let i = 0; i < 6; i++) balls.push({ x: 100 + Math.random() * (canvas.width - 200), y: 100 + Math.random() * (canvas.height - 200), vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5, radius: 40, baseRadius: 40, maxRadius: 100, inflateProgress: 0, inflateSpeed: 0.2 + Math.random() * 0.4, ballImage: getNextBallImage() }); for (let i = 0; i < 8; i++) gameState.people.push({ x: 80 + Math.random() * (canvas.width - 160), y: 150 + Math.random() * (canvas.height - 300), personIndex: getNextPersonImage(), radius: 30, pushCooldown: 0 }); }
        function updateInflate() { gameState.people.forEach(p => { if (p.pushCooldown > 0) p.pushCooldown--; }); for (let i = balls.length - 1; i >= 0; i--) { const ball = balls[i]; ball.inflateProgress += ball.inflateSpeed * 0.003; const tR = ball.baseRadius + ball.inflateProgress * (ball.maxRadius - ball.baseRadius); ball.radius = Math.min(tR, ball.maxRadius); ball.vx *= 0.98; ball.vy *= 0.98; let newX = ball.x + ball.vx, newY = ball.y + ball.vy; if (newX - ball.radius < 0) { newX = ball.radius; ball.vx = Math.abs(ball.vx) * 0.3; } if (newX + ball.radius > canvas.width) { newX = canvas.width - ball.radius; ball.vx = -Math.abs(ball.vx) * 0.3; } if (newY - ball.radius < 0) { newY = ball.radius; ball.vy = Math.abs(ball.vy) * 0.3; } if (newY + ball.radius > canvas.height) { newY = canvas.height - ball.radius; ball.vy = -Math.abs(ball.vy) * 0.3; } ball.x = newX; ball.y = newY; capSpeed(ball); if (ball.radius >= ball.maxRadius * 0.95) { ball.radius = ball.baseRadius; ball.inflateProgress = 0; gameState.poppedCount++; addScreenShake(4); } } for (let i = 0; i < balls.length; i++) { for (let j = i + 1; j < balls.length; j++) { const b1 = balls[i], b2 = balls[j], dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), minDist = b1.radius + b2.radius; if (dist < minDist && dist > 0) { const overlap = minDist - dist, pushF = overlap * 0.1, ang = Math.atan2(dy, dx); b1.x -= Math.cos(ang) * pushF; b1.y -= Math.sin(ang) * pushF; b2.x += Math.cos(ang) * pushF; b2.y += Math.sin(ang) * pushF; b1.vx -= Math.cos(ang) * pushF * 0.2; b1.vy -= Math.sin(ang) * pushF * 0.2; b2.vx += Math.cos(ang) * pushF * 0.2; b2.vy += Math.sin(ang) * pushF * 0.2; } } } }
        function drawInflate() { gameState.people.forEach(p => { const canPush = p.pushCooldown === 0; if (canPush) { ctx.beginPath(); ctx.arc(p.x, p.y, p.radius + 5, 0, Math.PI * 2); ctx.fillStyle = 'rgba(100, 200, 100, 0.2)'; ctx.fill(); } drawPerson(p.x, p.y + 10, 50, p.personIndex, canPush ? 1.0 : 0.5); }); balls.forEach(ball => { const pr = ball.radius / ball.maxRadius, hue = 60 - pr * 60; ctx.save(); if (pr > 0.7) { ctx.shadowBlur = pr * 20; ctx.shadowColor = 'hsla(' + hue + ', 80%, 50%, 0.5)'; } drawBall(ball); ctx.restore(); }); ctx.fillStyle = '#666'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'left'; ctx.fillText('Auto-popped: ' + gameState.poppedCount, 20, canvas.height - 85); ctx.fillText('Push assists: ' + gameState.clickPushed, 20, canvas.height - 60); }
        function inflatePointerDown(x, y) { for (let p of gameState.people) { const dx = x - p.x, dy = y - p.y, dist = Math.sqrt(dx * dx + dy * dy); if (dist < p.radius + 10 && p.pushCooldown === 0) { balls.forEach(ball => { const bdx = ball.x - p.x, bdy = ball.y - p.y, bDist = Math.sqrt(bdx * bdx + bdy * bdy); if (bDist < 150) { const force = (150 - bDist) / 150 * 8; ball.vx += (bdx / bDist) * force; ball.vy += (bdy / bDist) * force; } }); p.pushCooldown = 60; gameState.clickPushed++; addScreenShake(3); return; } } for (let i = balls.length - 1; i >= 0; i--) { if (contains(balls[i], x, y)) { balls[i].radius = balls[i].baseRadius; balls[i].inflateProgress = 0; balls[i].vx = (Math.random() - 0.5) * 4; balls[i].vy = (Math.random() - 0.5) * 4; addScreenShake(3); break; } } }
        
        // GAME 14: BRUSH
        function initWindBrush() { balls = []; gameState = { paths: [], drawing: false, currentPath: [] }; for (let i = 0; i < 15; i++) balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: 0, vy: 0, radius: 20 + Math.random() * 15, ballImage: getNextBallImage(), followingPath: null, pathProgress: 0 }); }
        function updateWindBrush() { gameState.paths = gameState.paths.filter(path => Date.now() - path.created < 6000); balls.forEach(ball => { if (ball.followingPath && ball.followingPath.points) { const path = ball.followingPath; ball.pathProgress += 0.02; if (ball.pathProgress >= 1 || !gameState.paths.includes(path)) { ball.followingPath = null; ball.pathProgress = 0; } else { const idx = Math.floor(ball.pathProgress * (path.points.length - 1)), nextIdx = Math.min(idx + 1, path.points.length - 1), t = (ball.pathProgress * (path.points.length - 1)) - idx, targetX = path.points[idx].x + (path.points[nextIdx].x - path.points[idx].x) * t, targetY = path.points[idx].y + (path.points[nextIdx].y - path.points[idx].y) * t; ball.vx = (targetX - ball.x) * 0.15; ball.vy = (targetY - ball.y) * 0.15; } } else { for (const path of gameState.paths) { if (path.points.length < 2) continue; const startPt = path.points[0], dx = ball.x - startPt.x, dy = ball.y - startPt.y, dist = Math.sqrt(dx * dx + dy * dy); if (dist < ball.radius + 30) { ball.followingPath = path; ball.pathProgress = 0; break; } } ball.vx *= 0.95; ball.vy *= 0.95; } ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.8; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.8; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.8; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.8; } }); ballCollisions(); }
        function drawWindBrush() { gameState.paths.forEach(path => { if (path.points.length < 2) return; const age = Date.now() - path.created, op = Math.max(0, 1 - age / 6000); ctx.save(); ctx.beginPath(); ctx.moveTo(path.points[0].x, path.points[0].y); for (let i = 1; i < path.points.length; i++) ctx.lineTo(path.points[i].x, path.points[i].y); ctx.strokeStyle = 'rgba(100, 180, 255, ' + (op * 0.6) + ')'; ctx.lineWidth = 8; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.stroke(); const startPt = path.points[0]; ctx.beginPath(); ctx.arc(startPt.x, startPt.y, 12, 0, Math.PI * 2); ctx.fillStyle = 'rgba(100, 255, 150, ' + (op * 0.8) + ')'; ctx.fill(); if (path.points.length > 1) { const endPt = path.points[path.points.length - 1]; ctx.beginPath(); ctx.arc(endPt.x, endPt.y, 8, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 150, 100, ' + (op * 0.8) + ')'; ctx.fill(); } ctx.restore(); }); if (gameState.drawing && gameState.currentPath.length > 1) { ctx.save(); ctx.globalAlpha = 0.7; ctx.beginPath(); ctx.moveTo(gameState.currentPath[0].x, gameState.currentPath[0].y); for (let i = 1; i < gameState.currentPath.length; i++) ctx.lineTo(gameState.currentPath[i].x, gameState.currentPath[i].y); ctx.strokeStyle = 'rgba(100, 180, 255, 0.9)'; ctx.lineWidth = 6; ctx.lineCap = 'round'; ctx.stroke(); ctx.restore(); } balls.forEach(ball => { if (ball.followingPath) { ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius + 8, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)'; ctx.lineWidth = 3; ctx.stroke(); } drawBall(ball); }); ctx.fillStyle = '#666'; ctx.font = '16px Arial'; ctx.textAlign = 'left'; ctx.fillText('Draw paths - balls follow from green dot to orange', 20, canvas.height - 80); }
        function windBrushPointerDown(x, y) { gameState.drawing = true; gameState.currentPath = [{ x, y }]; }
        function windBrushPointerMove(x, y) { if (gameState.drawing) { const lastPt = gameState.currentPath[gameState.currentPath.length - 1]; if (Math.abs(x - lastPt.x) > 5 || Math.abs(y - lastPt.y) > 5) gameState.currentPath.push({ x, y }); } }
        function windBrushPointerUp() { if (gameState.drawing && gameState.currentPath.length > 3) gameState.paths.push({ points: [...gameState.currentPath], created: Date.now() }); gameState.drawing = false; gameState.currentPath = []; }
        
        // GAME 15: PORTALS
        function initPortals() { balls = []; gameState = { portals: [], nextPortalIsExit: false, goldenZone: { x: canvas.width * 0.75, y: canvas.height * 0.75, radius: 120, vx: 0.8, vy: 0.5 } }; for (let i = 0; i < 16; i++) { let x, y; do { x = 50 + Math.random() * (canvas.width - 100); y = 50 + Math.random() * (canvas.height - 100); } while (Math.sqrt((x - gameState.goldenZone.x) ** 2 + (y - gameState.goldenZone.y) ** 2) < gameState.goldenZone.radius + 50); balls.push({ x, y, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, radius: 25 + Math.random() * 15, baseRadius: 25 + Math.random() * 15, shrinkRate: 0.01 + Math.random() * 0.01, portalCooldown: 0, ballImage: getNextBallImage(), inZone: false }); } }
        function updatePortals() { const gz = gameState.goldenZone; gz.x += gz.vx; gz.y += gz.vy; if (gz.x - gz.radius < 0 || gz.x + gz.radius > canvas.width) gz.vx *= -1; if (gz.y - gz.radius < 0 || gz.y + gz.radius > canvas.height) gz.vy *= -1; for (let i = balls.length - 1; i >= 0; i--) { const ball = balls[i], dxGz = ball.x - gz.x, dyGz = ball.y - gz.y, distGz = Math.sqrt(dxGz * dxGz + dyGz * dyGz); ball.inZone = distGz < gz.radius - ball.radius; if (!ball.inZone) { ball.radius -= ball.shrinkRate; if (ball.radius < 5) { balls.splice(i, 1); let x, y; do { x = 50 + Math.random() * (canvas.width - 100); y = 50 + Math.random() * (canvas.height - 100); } while (Math.sqrt((x - gz.x) ** 2 + (y - gz.y) ** 2) < gz.radius + 50); balls.push({ x, y, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, radius: 25 + Math.random() * 15, baseRadius: 25 + Math.random() * 15, shrinkRate: 0.01 + Math.random() * 0.01, portalCooldown: 0, ballImage: getNextBallImage(), inZone: false }); continue; } } else ball.radius = Math.min(ball.baseRadius, ball.radius + 0.05); const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy); if (speed < 0.3) { const a = Math.atan2(ball.vy, ball.vx); ball.vx = Math.cos(a) * 0.8; ball.vy = Math.sin(a) * 0.8; } ball.vx *= 0.995; ball.vy *= 0.995; ball.x += ball.vx; ball.y += ball.vy; capSpeed(ball); if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.9; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.9; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.9; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.9; } if (ball.portalCooldown > 0) ball.portalCooldown--; gameState.portals.forEach(pp => { if (!pp.exit) return; const ent = pp.entrance, exit = pp.exit, dx = ball.x - ent.x, dy = ball.y - ent.y, dist = Math.sqrt(dx * dx + dy * dy); if (dist < 35 && ball.portalCooldown === 0) { ball.x = exit.x; ball.y = exit.y; ball.portalCooldown = 45; } }); } for (let i = 0; i < balls.length; i++) { for (let j = i + 1; j < balls.length; j++) { const b1 = balls[i], b2 = balls[j], dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), minDist = b1.radius + b2.radius; if (dist < minDist && dist > 0) { const ang = Math.atan2(dy, dx), ax = (minDist - dist) * Math.cos(ang) * 0.05, ay = (minDist - dist) * Math.sin(ang) * 0.05; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; } } } }
        function drawPortals() { const gz = gameState.goldenZone, g = ctx.createRadialGradient(gz.x, gz.y, 0, gz.x, gz.y, gz.radius); g.addColorStop(0, 'rgba(255, 215, 0, 0.3)'); g.addColorStop(0.7, 'rgba(255, 215, 0, 0.15)'); g.addColorStop(1, 'rgba(255, 215, 0, 0)'); ctx.beginPath(); ctx.arc(gz.x, gz.y, gz.radius, 0, Math.PI * 2); ctx.fillStyle = g; ctx.fill(); ctx.beginPath(); ctx.arc(gz.x, gz.y, gz.radius, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(255, 180, 0, 0.6)'; ctx.lineWidth = 4; ctx.stroke(); gameState.portals.forEach(pp => { const ent = pp.entrance, time = Date.now() * 0.004; ctx.save(); ctx.translate(ent.x, ent.y); for (let i = 0; i < 3; i++) { ctx.beginPath(); ctx.arc(0, 0, 35 - i * 8, time + i * 0.5, time + i * 0.5 + Math.PI * 1.6); ctx.strokeStyle = 'rgba(255, ' + (150 - i * 40) + ', 50, ' + (0.8 - i * 0.2) + ')'; ctx.lineWidth = 5 - i; ctx.stroke(); } ctx.restore(); if (pp.exit) { const exit = pp.exit; ctx.save(); ctx.translate(exit.x, exit.y); for (let i = 0; i < 3; i++) { ctx.beginPath(); ctx.arc(0, 0, 35 - i * 8, -time + i * 0.5, -time + i * 0.5 + Math.PI * 1.6); ctx.strokeStyle = 'rgba(50, ' + (150 - i * 40) + ', 255, ' + (0.8 - i * 0.2) + ')'; ctx.lineWidth = 5 - i; ctx.stroke(); } ctx.restore(); } }); balls.forEach(ball => { const sR = ball.radius / ball.baseRadius; if (sR < 0.5 && !ball.inZone) { ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius + 10, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(255, 100, 100, ' + (1 - sR) + ')'; ctx.lineWidth = 2; ctx.stroke(); } drawBall(ball, ball.inZone ? 1.0 : 0.7 + sR * 0.3); }); const bIZ = balls.filter(b => b.inZone).length, allIn = bIZ === balls.length; ctx.fillStyle = allIn ? '#4A4' : '#666'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'left'; ctx.fillText('In safety: ' + bIZ + '/' + balls.length, 20, canvas.height - 80); if (allIn) { ctx.fillStyle = '#FFD700'; ctx.font = 'bold 32px Arial'; ctx.textAlign = 'center'; ctx.fillText('ðŸŽ¯ All Safe! ðŸŽ¯', canvas.width / 2, 160); } if (gameState.nextPortalIsExit) { ctx.fillStyle = '#666'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.fillText('Click to place exit (blue)', canvas.width / 2, canvas.height - 100); } }
        function portalPointerDown(x, y) { if (!gameState.nextPortalIsExit) { gameState.portals.push({ entrance: { x, y }, exit: null }); gameState.nextPortalIsExit = true; } else { const lastP = gameState.portals[gameState.portals.length - 1]; if (lastP && !lastP.exit) { lastP.exit = { x, y }; gameState.nextPortalIsExit = false; } } }
        
        // HELPERS
        function contains(ball, x, y) { const dx = x - ball.x, dy = y - ball.y; return Math.sqrt(dx * dx + dy * dy) < ball.radius; }
        function drawBall(ball, opacity = 1.0, rotation = 0) { const img = ballImages[ball.ballImage - 1]; if (img && img.complete && img.naturalWidth > 0) { ctx.save(); ctx.globalAlpha = opacity; ctx.translate(ball.x, ball.y); ctx.rotate(rotation); ctx.drawImage(img, -ball.radius, -ball.radius, ball.radius * 2, ball.radius * 2); ctx.restore(); } else { ctx.save(); ctx.globalAlpha = opacity; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2); ctx.fillStyle = '#333'; ctx.fill(); ctx.restore(); } }
        function ballCollisions() { for (let i = 0; i < balls.length; i++) { for (let j = i + 1; j < balls.length; j++) { const b1 = balls[i], b2 = balls[j]; if (b1.popping || b2.popping || b1.orbiting || b2.orbiting || b1.frozen || b2.frozen || b1.merging || b2.merging) continue; const dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx * dx + dy * dy), minDist = b1.radius + b2.radius; if (dist < minDist) { const ang = Math.atan2(dy, dx), tx = b1.x + Math.cos(ang) * minDist, ty = b1.y + Math.sin(ang) * minDist, ax = (tx - b2.x) * 0.05, ay = (ty - b2.y) * 0.05; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; } } } }
        function lineCircleCollision(x1, y1, x2, y2, cx, cy, radius) { const dx = x2 - x1, dy = y2 - y1, fx = x1 - cx, fy = y1 - cy, a = dx * dx + dy * dy, b = 2 * (fx * dx + fy * dy), c = (fx * fx + fy * fy) - radius * radius; let disc = b * b - 4 * a * c; if (disc < 0) return { collides: false }; disc = Math.sqrt(disc); const t1 = (-b - disc) / (2 * a), t2 = (-b + disc) / (2 * a); if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) { const t = Math.max(0, Math.min(1, -b / (2 * a))), closestX = x1 + t * dx, closestY = y1 + t * dy, distX = cx - closestX, distY = cy - closestY, dist = Math.sqrt(distX * distX + distY * distY); if (dist < radius) { const pushDist = radius - dist; return { collides: true, newX: cx + (distX / dist) * pushDist, newY: cy + (distY / dist) * pushDist }; } } return { collides: false }; }
        
        // GAME MANAGEMENT
        function switchGame(gameNum) { if (gameNum < 1 || gameNum > 15) return; currentGame = gameNum; screenShake = { x: 0, y: 0, intensity: 0 }; document.querySelectorAll('.nav-item').forEach(item => { item.classList.remove('active'); if (parseInt(item.dataset.game) === currentGame) item.classList.add('active'); }); games[currentGame].init(); }
        document.querySelectorAll('.nav-item').forEach(item => { item.addEventListener('click', () => { switchGame(parseInt(item.dataset.game)); }); });
        
        // INPUT
        function getPointer(e) { const touch = e.touches ? e.touches[0] : e; return { x: touch.clientX, y: touch.clientY }; }
        canvas.addEventListener('mousedown', (e) => { e.preventDefault(); const { x, y } = getPointer(e), game = games[currentGame]; if (game.onPointerDown) game.onPointerDown(x, y); });
        canvas.addEventListener('mousemove', (e) => { const { x, y } = getPointer(e), game = games[currentGame]; if (game.onPointerMove) game.onPointerMove(x, y); });
        canvas.addEventListener('mouseup', (e) => { e.preventDefault(); const game = games[currentGame]; if (game.onPointerUp) game.onPointerUp(); });
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); const { x, y } = getPointer(e), game = games[currentGame]; if (game.onPointerDown) game.onPointerDown(x, y); });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); const { x, y } = getPointer(e), game = games[currentGame]; if (game.onPointerMove) game.onPointerMove(x, y); });
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); const game = games[currentGame]; if (game.onPointerUp) game.onPointerUp(); });
        document.addEventListener('keydown', (e) => { const num = parseInt(e.key); if (num >= 1 && num <= 9) switchGame(num); if (e.key === 'Shift' && gameState && gameState.shiftPressed !== undefined) gameState.shiftPressed = true; });
        document.addEventListener('keyup', (e) => { if (e.key === 'Shift' && gameState && gameState.shiftPressed !== undefined) gameState.shiftPressed = false; });
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
        
        // LOOP
        function animate() { updateScreenShake(); ctx.save(); ctx.translate(screenShake.x, screenShake.y); ctx.clearRect(-10, -10, canvas.width + 20, canvas.height + 20); const game = games[currentGame]; game.update(); game.draw(); ctx.restore(); requestAnimationFrame(animate); }
        switchGame(1);
        animate();
    </script>
</body>
</html>