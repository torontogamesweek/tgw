<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Toronto Games Week - Interactive Background Tests</title>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { overflow: hidden; background: #f0f0f0; touch-action: none; font-family: "Courier New", Courier, monospace, sans-serif; }
      canvas { display: block; background: #fff; }
      #nav { position: fixed; top: 0; left: 0; right: 0; display: grid; grid-template-columns: repeat(4, 1fr); background: rgba(255, 255, 255, 0.95); box-shadow: 0 2px 2px rgba(0, 0, 0, 0.1); z-index: 100; }
      .nav-item { padding: 8px 8px; text-align: center; cursor: pointer; border-right: 1px solid #ddd; border-bottom: 1px solid #ddd; font-size: 1rem; font-weight: 600; transition: all 0.2s; user-select: none; position: relative; }
      .nav-item:nth-child(4n) { border-right: none; }
      .nav-item:hover { background: rgba(0, 0, 0, 0.05); }
      .nav-item.active { background: rgba(0, 0, 0, 0.1); color: #000; }
      .nav-item .tooltip { position: absolute; top: 100%; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.85); color: white; padding: 8px 12px; border-radius: 6px; font-size: 12px; font-weight: normal; white-space: nowrap; opacity: 0; pointer-events: none; transition: opacity 0.2s; z-index: 200; margin-top: 5px; }
      .nav-item .tooltip::before { content: ""; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); border: 6px solid transparent; border-bottom-color: rgba(0, 0, 0, 0.85); }
      .nav-item:hover .tooltip { opacity: 1; }
    </style>
  </head>
  <body>
    <div id="nav">
      <div class="nav-item" data-game="1">Fling<span class="tooltip">Collect gold but avoid catchers!</span></div>
      <div class="nav-item" data-game="2">Paddle<span class="tooltip">Keep the balls bouncing!</span></div>
      <div class="nav-item" data-game="3">Pop<span class="tooltip">Pop them all!</span></div>
      <div class="nav-item" data-game="4">Vacuum<span class="tooltip">Hold to vacuum, release to explode!</span></div>
      <div class="nav-item" data-game="5">Gravity Flip<span class="tooltip">Click to reverse gravity</span></div>
      <div class="nav-item" data-game="6">Bounce<span class="tooltip">Draw lines to bounce ball to heart!</span></div>
      <div class="nav-item" data-game="7">Magnet<span class="tooltip">Click = attract, SHIFT = repel</span></div>
      <div class="nav-item" data-game="8">Explode<span class="tooltip">Hold to charge, release to burst!</span></div>
      <div class="nav-item" data-game="9">Orbital<span class="tooltip">Click to release orbiting balls!</span></div>
      <div class="nav-item" data-game="10">Defend<span class="tooltip">Click balls to recruit guards!</span></div>
      <div class="nav-item" data-game="11">Connect<span class="tooltip">Connect people to balls!</span></div>
      <div class="nav-item" data-game="12">Merge<span class="tooltip">Unite all walkers!</span></div>
      <div class="nav-item" data-game="13">Inflate<span class="tooltip">Click balls to pop them</span></div>
      <div class="nav-item" data-game="14">Brush<span class="tooltip">Paint paths for balls</span></div>
      <div class="nav-item" data-game="15">Portals<span class="tooltip">Move balls to golden zone!</span></div>
      <div class="nav-item" data-game="16">Wheelball<span class="tooltip">Launch and spin!</span></div>
    </div>
    <canvas id="canvas"></canvas>
    <script>
const Config = {
  MAX_SPEED: 25,
  NUM_BALL_IMAGES: 29,
  NUM_PEOPLE_IMAGES: 19,
  SCREEN_SHAKE_DECAY: 0.85,
  SCREEN_SHAKE_MAX: 8,
  SCREEN_SHAKE_MIN_THRESHOLD: 0.3,
  isMobile: ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (window.innerWidth < 768),
};

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const Assets = {
  balls: [],
  people: [],
  stars: [],
  special: {},

  load() {
    for (let i = 1; i <= Config.NUM_BALL_IMAGES; i++) {
      const img = new Image();
      img.src = "balls/ball_" + i + ".png";
      this.balls.push(img);
    }
    for (let i = 1; i <= Config.NUM_PEOPLE_IMAGES; i++) {
      const img = new Image();
      img.src = "ppl/ppl_" + i + ".png";
      this.people.push(img);
    }
    for (let i = 1; i <= 3; i++) {
      const img = new Image();
      img.src = "particles/stars/star_" + i + ".png";
      this.stars.push(img);
    }
    this.special.point = this._loadImage("special/point.png");
    this.special.baddie = this._loadImage("special/baddie.png");
    this.special.heart = this._loadImage("particles/hot/heart.png");
    this.special.ko = this._loadImage("particles/hot/ko.png");
    this.special.blackCircle = this._loadImage("special/black-circle.png");
  },
  _loadImage(src) { const img = new Image(); img.src = src; return img; },
  getBallImage(index) { return this.balls[(index - 1) % this.balls.length]; },
  getPersonImage(index) { return this.people[index % this.people.length]; },
  getStarImage(index) { return this.stars[index % this.stars.length]; },
  isImageReady(img) { return img && img.complete && img.naturalWidth > 0; },
};

const ImageCounter = {
  ball: 0,
  person: 0,
  nextBall() { this.ball = (this.ball + 1) % Config.NUM_BALL_IMAGES; return this.ball + 1; },
  nextPerson() { const idx = this.person; this.person = (this.person + 1) % Config.NUM_PEOPLE_IMAGES; return idx; },
};

const ScreenShake = {
  x: 0, y: 0, intensity: 0,
  add(amount) { this.intensity = Math.min(Math.max(this.intensity, amount * 0.4), Config.SCREEN_SHAKE_MAX); },
  update() {
    if (this.intensity > 0) {
      this.x = (Math.random() - 0.5) * this.intensity;
      this.y = (Math.random() - 0.5) * this.intensity;
      this.intensity *= Config.SCREEN_SHAKE_DECAY;
      if (this.intensity < Config.SCREEN_SHAKE_MIN_THRESHOLD) this.intensity = 0;
    } else { this.x = 0; this.y = 0; }
  },
  reset() { this.x = 0; this.y = 0; this.intensity = 0; },
};

const Physics = {
  capSpeed(ball) {
    const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
    if (speed > Config.MAX_SPEED) { const scale = Config.MAX_SPEED / speed; ball.vx *= scale; ball.vy *= scale; }
  },
  getSpeed(ball) { return Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy); },
  distance(x1, y1, x2, y2) { return Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)); },
  contains(ball, x, y) { return this.distance(ball.x, ball.y, x, y) < ball.radius; },
  handleWallCollision(ball, canvasRef, bounce, squash) {
    if (bounce === undefined) bounce = 0.9;
    if (squash === undefined) squash = true;
    let hit = false;
    if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -bounce; if (squash && ball.squashX !== undefined) { ball.squashX = 0.85; ball.squashY = 1.15; } hit = true; }
    if (ball.x + ball.radius > canvasRef.width) { ball.x = canvasRef.width - ball.radius; ball.vx *= -bounce; if (squash && ball.squashX !== undefined) { ball.squashX = 0.85; ball.squashY = 1.15; } hit = true; }
    if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -bounce; if (squash && ball.squashX !== undefined) { ball.squashX = 1.15; ball.squashY = 0.85; } hit = true; }
    if (ball.y + ball.radius > canvasRef.height) { ball.y = canvasRef.height - ball.radius; ball.vy *= -bounce; if (squash && ball.squashX !== undefined) { ball.squashX = 1.15; ball.squashY = 0.85; } hit = true; }
    return hit;
  },
  handleBallCollisions(balls, options) {
    if (!options) options = {};
    const skipCondition = options.skipCondition || function(b) { return b.popping || b.orbiting || b.frozen || b.merging; };
    const pushFactor = options.pushFactor || 0.05;
    for (let i = 0; i < balls.length; i++) {
      for (let j = i + 1; j < balls.length; j++) {
        const b1 = balls[i], b2 = balls[j];
        if (skipCondition(b1) || skipCondition(b2)) continue;
        const dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx*dx + dy*dy), minDist = b1.radius + b2.radius;
        if (dist < minDist && dist > 0) {
          const ang = Math.atan2(dy, dx), ax = (minDist - dist) * Math.cos(ang) * pushFactor, ay = (minDist - dist) * Math.sin(ang) * pushFactor;
          b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay;
        }
      }
    }
  },
  lineCircleCollision(x1, y1, x2, y2, cx, cy, radius) {
    const dx = x2 - x1, dy = y2 - y1, fx = x1 - cx, fy = y1 - cy;
    const a = dx*dx + dy*dy, b = 2*(fx*dx + fy*dy), c = fx*fx + fy*fy - radius*radius;
    let disc = b*b - 4*a*c;
    if (disc < 0) return { collides: false };
    disc = Math.sqrt(disc);
    const t1 = (-b - disc) / (2*a), t2 = (-b + disc) / (2*a);
    if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {
      const t = Math.max(0, Math.min(1, -b / (2*a)));
      const closestX = x1 + t*dx, closestY = y1 + t*dy;
      const distX = cx - closestX, distY = cy - closestY, dist = Math.sqrt(distX*distX + distY*distY);
      if (dist < radius) { const pushDist = radius - dist; return { collides: true, newX: cx + (distX/dist)*pushDist, newY: cy + (distY/dist)*pushDist }; }
    }
    return { collides: false };
  },
};

const Renderer = {
  drawImage(img, x, y, w, h, opacity, rotation) {
    if (!Assets.isImageReady(img)) return false;
    if (opacity === undefined) opacity = 1;
    if (rotation === undefined) rotation = 0;
    ctx.save(); ctx.globalAlpha = opacity; ctx.translate(x + w/2, y + h/2); ctx.rotate(rotation);
    ctx.drawImage(img, -w/2, -h/2, w, h); ctx.restore(); return true;
  },
  drawBall(ball, opacity, rotation) { this.drawBallWithSquash(ball, opacity, rotation, 1, 1); },
  drawBallWithSquash(ball, opacity, rotation, squashX, squashY) {
    if (opacity === undefined) opacity = 1;
    if (rotation === undefined) rotation = 0;
    if (squashX === undefined) squashX = 1;
    if (squashY === undefined) squashY = 1;
    const img = Assets.getBallImage(ball.ballImage);
    ctx.save(); ctx.globalAlpha = opacity; ctx.translate(ball.x, ball.y); ctx.rotate(rotation); ctx.scale(squashX, squashY);
    if (Assets.isImageReady(img)) { ctx.drawImage(img, -ball.radius, -ball.radius, ball.radius*2, ball.radius*2); }
    else { ctx.beginPath(); ctx.arc(0, 0, ball.radius, 0, Math.PI*2); ctx.fillStyle = "#333"; ctx.fill(); }
    ctx.restore();
  },
  drawPerson(x, y, height, imageIndex, opacity, rotation) {
    if (opacity === undefined) opacity = 1;
    if (rotation === undefined) rotation = 0;
    const img = Assets.getPersonImage(imageIndex);
    if (Assets.isImageReady(img)) {
      const aspectRatio = img.naturalWidth / img.naturalHeight, width = height * aspectRatio;
      ctx.save(); ctx.globalAlpha = opacity; ctx.translate(x, y); ctx.rotate(rotation);
      ctx.drawImage(img, -width/2, -height, width, height); ctx.restore();
    }
  },
  drawStarburst(x, y, innerRadius, outerRadius, points, color) {
    ctx.beginPath();
    for (let i = 0; i < points * 2; i++) {
      const angle = ((Math.PI * 2) / (points * 2)) * i - Math.PI / 2;
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      if (i === 0) ctx.moveTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
      else ctx.lineTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
    }
    ctx.closePath(); ctx.fillStyle = color; ctx.fill();
  },
  createRadialGradient(x, y, r1, r2, stops) {
    const gradient = ctx.createRadialGradient(x, y, r1, x, y, r2);
    stops.forEach(function(s) { gradient.addColorStop(s[0], s[1]); });
    return gradient;
  },
};

class ParticleSystem {
  constructor() { this.particles = []; }
  add(particle) {
    this.particles.push({
      life: 30, maxLife: 30, gravity: 0, spin: 0, rotation: 0,
      x: particle.x, y: particle.y, vx: particle.vx || 0, vy: particle.vy || 0,
      size: particle.size, type: particle.type, starIndex: particle.starIndex,
      ballImage: particle.ballImage, radius: particle.radius, text: particle.text, big: particle.big,
      life: particle.life || 30, maxLife: particle.maxLife || particle.life || 30,
      gravity: particle.gravity || 0, spin: particle.spin || 0, rotation: particle.rotation || 0
    });
  }
  addBurst(x, y, count, config) {
    if (!config) config = {};
    const speed = config.speed || 4, speedVariance = config.speedVariance || 2, life = config.life || 30;
    const size = config.size || 15, sizeVariance = config.sizeVariance || 10, gravity = config.gravity || 0.1, type = config.type || "star";
    for (let i = 0; i < count; i++) {
      const angle = ((Math.PI * 2) / count) * i + Math.random() * 0.3;
      const particleSpeed = speed + Math.random() * speedVariance;
      this.add({ x: x, y: y, vx: Math.cos(angle) * particleSpeed, vy: Math.sin(angle) * particleSpeed,
        life: life, maxLife: life, size: size + Math.random() * sizeVariance,
        rotation: Math.random() * Math.PI * 2, spin: (Math.random() - 0.5) * 0.3, gravity: gravity, type: type, starIndex: Math.floor(Math.random() * 3) });
    }
  }
  update() {
    this.particles = this.particles.filter(function(p) {
      p.x += p.vx; p.y += p.vy; p.vy += p.gravity || 0; p.life--;
      p.rotation = (p.rotation || 0) + (p.spin || 0);
      return p.life > 0;
    });
  }
  draw(customDrawer) {
    const self = this;
    this.particles.forEach(function(p) {
      const alpha = p.life / (p.maxLife || 30);
      if (customDrawer) { customDrawer(p, alpha); return; }
      if (p.type === "star" && p.starIndex !== undefined) {
        const img = Assets.getStarImage(p.starIndex);
        Renderer.drawImage(img, p.x - p.size/2, p.y - p.size/2, p.size, p.size, alpha, p.rotation);
      } else if (p.type === "heart") {
        Renderer.drawImage(Assets.special.heart, p.x - p.size/2, p.y - p.size/2, p.size, p.size, alpha, p.rotation);
      } else if (p.type === "ko") {
        Renderer.drawImage(Assets.special.ko, p.x - p.size/2, p.y - p.size/2, p.size, p.size, alpha, p.rotation);
      } else if (p.ballImage) {
        const img = Assets.getBallImage(p.ballImage);
        if (Assets.isImageReady(img)) {
          ctx.save(); ctx.globalAlpha = alpha; ctx.translate(p.x, p.y); ctx.rotate(p.rotation);
          ctx.drawImage(img, -p.radius, -p.radius, p.radius*2, p.radius*2); ctx.restore();
        }
      }
    });
  }
  clear() { this.particles = []; }
}

class BaseGame {
  constructor() { this.balls = []; this.state = {}; this.particles = new ParticleSystem(); }
  init() { this.balls = []; this.state = {}; this.particles.clear(); }
  update() { this.particles.update(); }
  draw() { this.particles.draw(); }
  onPointerDown(x, y) {}
  onPointerMove(x, y) {}
  onPointerUp() {}
  createBall(options) {
    if (!options) options = {};
    return {
      x: options.x !== undefined ? options.x : Math.random() * canvas.width,
      y: options.y !== undefined ? options.y : Math.random() * canvas.height,
      vx: options.vx || 0, vy: options.vy || 0,
      radius: options.radius || 30,
      ballImage: options.ballImage || ImageCounter.nextBall(),
      rotation: options.rotation || 0, squashX: 1, squashY: 1,
      ...options
    };
  }
  updateBallPhysics(ball, options) {
    if (!options) options = {};
    const gravity = options.gravity || 0, friction = options.friction || 0.99;
    const minSpeed = options.minSpeed || 0, bounce = options.bounce || 0.9, squashRecovery = options.squashRecovery || 0.15;
    ball.vy += gravity; ball.vx *= friction; ball.vy *= friction;
    if (minSpeed > 0) {
      const speed = Physics.getSpeed(ball);
      if (speed < minSpeed && speed > 0) { const angle = Math.atan2(ball.vy, ball.vx); ball.vx = Math.cos(angle) * minSpeed; ball.vy = Math.sin(angle) * minSpeed; }
    }
    ball.x += ball.vx; ball.y += ball.vy; Physics.capSpeed(ball);
    if (ball.squashX !== undefined) { ball.squashX += (1 - ball.squashX) * squashRecovery; ball.squashY += (1 - ball.squashY) * squashRecovery; }
    if (ball.rotation !== undefined) { const speed = Physics.getSpeed(ball); ball.rotation += speed * 0.02; }
    Physics.handleWallCollision(ball, canvas, bounce);
  }
}

// GAME 1: FLING
class FlingGame extends BaseGame {
  init() {
    super.init();
    this.state = { draggedBall: null, goldenOrbs: [], catchers: [], score: 0, lives: 5, gameTime: 0, lastCatcherSpawn: 0 };
    this.spawnBall();
    for (let i = 0; i < 3; i++) {
      this.state.goldenOrbs.push({ x: 150 + Math.random() * (canvas.width - 300), y: 200 + Math.random() * (canvas.height - 400), radius: 25, pulse: Math.random() * Math.PI * 2 });
    }
    this.spawnCatcher(); this.spawnCatcher();
  }
  spawnBall(animated) {
    const angle = Math.random() * Math.PI * 2;
    this.balls.push(this.createBall({ x: canvas.width/2 + (Math.random()-0.5)*200, y: canvas.height/2 + (Math.random()-0.5)*200,
      vx: Math.cos(angle)*0.5, vy: Math.sin(angle)*0.5, radius: 30 + Math.random()*20,
      isDragging: false, dragStartX: 0, dragStartY: 0, trail: [], glowTimer: 0, dying: false, deathProgress: 0, deathType: "explode", spawnProgress: animated ? 0 : 1 }));
  }
  spawnCatcher() {
    let x, y;
    do { x = 100 + Math.random()*(canvas.width-200); y = 100 + Math.random()*(canvas.height-200); }
    while (Math.abs(x - canvas.width/2) < 200 && Math.abs(y - canvas.height/2) < 200);
    this.state.catchers.push({ x:x, y:y, personIndex: ImageCounter.nextPerson(), radius: 35, spawnProgress: 0, pulsePhase: Math.random()*Math.PI*2, rotationPhase: Math.random()*Math.PI*2 });
  }
  update() {
    super.update();
    const s = this.state;
    s.gameTime++;
    if (s.catchers.length < 12 && s.gameTime - s.lastCatcherSpawn > 1200) { this.spawnCatcher(); s.lastCatcherSpawn = s.gameTime; }
    s.goldenOrbs.forEach(function(o) { o.pulse += 0.1; });
    s.catchers.forEach(function(c) { if (c.spawnProgress < 1) c.spawnProgress += 0.01; c.pulsePhase += 0.08; c.rotationPhase += 0.02; });
    const self = this;
    for (let i = this.balls.length - 1; i >= 0; i--) {
      const ball = this.balls[i];
      if (ball.spawnProgress < 1) { ball.spawnProgress += 0.05; ball.squashX = 0.3 + ball.spawnProgress*0.7 + Math.sin(ball.spawnProgress*Math.PI)*0.3; ball.squashY = 0.3 + ball.spawnProgress*0.7 + Math.sin(ball.spawnProgress*Math.PI + Math.PI/2)*0.2; continue; }
      if (ball.dying) { ball.deathProgress += 0.06; ball.squashX = ball.deathType === "explode" ? 1 + ball.deathProgress*1.5 : 1 + ball.deathProgress*0.8; ball.squashY = ball.deathType === "explode" ? 1 - ball.deathProgress*0.8 : 1 - ball.deathProgress*0.9; if (ball.deathProgress >= 1) { this.balls.splice(i, 1); this.spawnBall(true); } continue; }
      if (ball.isDragging) continue;
      if (ball.glowTimer > 0) ball.glowTimer--;
      ball.squashX += (1 - ball.squashX) * 0.15; ball.squashY += (1 - ball.squashY) * 0.15;
      const speed = Physics.getSpeed(ball);
      if (speed < 0.3) { const a = Math.atan2(ball.vy, ball.vx); ball.vx = Math.cos(a)*0.5; ball.vy = Math.sin(a)*0.5; }
      ball.vx *= 0.995; ball.vy *= 0.995; ball.x += ball.vx; ball.y += ball.vy; Physics.capSpeed(ball); ball.rotation += speed * 0.05;
      if (speed > 3) ball.trail.push({ x: ball.x, y: ball.y, life: 20 });
      ball.trail = ball.trail.filter(function(p) { return p.life-- > 0; });
      if (speed > 4) {
        for (let j = s.goldenOrbs.length - 1; j >= 0; j--) {
          const orb = s.goldenOrbs[j];
          if (Physics.distance(ball.x, ball.y, orb.x, orb.y) < ball.radius + orb.radius + 5) {
            ball.glowTimer = 60; s.score++; self.particles.addBurst(orb.x, orb.y, 8, { speed: 4, life: 30, type: "star" });
            orb.x = 150 + Math.random()*(canvas.width-300); orb.y = 200 + Math.random()*(canvas.height-400);
          }
        }
        s.catchers.forEach(function(c) {
          if (c.spawnProgress < 0.8) return;
          if (Physics.distance(ball.x, ball.y, c.x, c.y) < ball.radius + c.radius && !ball.dying) {
            ball.dying = true; ball.deathProgress = 0; ball.deathType = Math.random() > 0.5 ? "explode" : "squish"; s.lives--; ScreenShake.add(10);
            for (let k = 0; k < 12; k++) { const a = ((Math.PI*2)/12)*k; self.particles.add({ x: ball.x, y: ball.y, vx: Math.cos(a)*(3+Math.random()*3), vy: Math.sin(a)*(3+Math.random()*3), life: 35, maxLife: 35, ballImage: ball.ballImage, radius: ball.radius*0.2, rotation: Math.random()*Math.PI*2, spin: (Math.random()-0.5)*0.3, gravity: 0.15 }); }
          }
        });
      }
      if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.95; ball.squashX = 0.7; ball.squashY = 1.2; }
      if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.95; ball.squashX = 0.7; ball.squashY = 1.2; }
      if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.95; ball.squashX = 1.2; ball.squashY = 0.7; }
      if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.95; ball.squashX = 1.2; ball.squashY = 0.7; }
    }
    Physics.handleBallCollisions(this.balls);
  }
  draw() {
    const s = this.state;
    s.catchers.forEach(function(c) {
      const op = Math.min(1, c.spawnProgress), scale = 0.5 + c.spawnProgress*0.5;
      ctx.save(); ctx.globalAlpha = op; ctx.translate(c.x, c.y); ctx.scale(scale, scale);
      ctx.save(); ctx.rotate(c.rotationPhase); Renderer.drawStarburst(0, 0, c.radius*0.5, (c.radius+18)*(1+Math.sin(c.pulsePhase)*0.15), 8, "rgba(255, 60, 60, 0.4)"); ctx.restore();
      const dg = Renderer.createRadialGradient(0, 0, 0, c.radius*1.2, [[0, "rgba(255, 0, 0, 0.2)"], [1, "rgba(255, 0, 0, 0)"]]);
      ctx.beginPath(); ctx.arc(0, 0, c.radius*1.2, 0, Math.PI*2); ctx.fillStyle = dg; ctx.fill(); ctx.restore();
      Renderer.drawPerson(c.x, c.y + 20*scale, 50*scale, c.personIndex, op);
    });
    s.goldenOrbs.forEach(function(orb) {
      const ps = 1 + Math.sin(orb.pulse)*0.2;
      const g = Renderer.createRadialGradient(orb.x, orb.y, 0, orb.radius*ps*2, [[0, "rgba(255, 215, 0, 0.8)"], [0.5, "rgba(255, 180, 0, 0.3)"], [1, "rgba(255, 150, 0, 0)"]]);
      ctx.beginPath(); ctx.arc(orb.x, orb.y, orb.radius*ps*2, 0, Math.PI*2); ctx.fillStyle = g; ctx.fill();
      ctx.beginPath(); ctx.arc(orb.x, orb.y, orb.radius*ps, 0, Math.PI*2); ctx.fillStyle = "#FFD700"; ctx.fill();
      ctx.strokeStyle = "rgba(255, 255, 200, 0.8)"; ctx.lineWidth = 3; ctx.stroke();
    });
    super.draw();
    this.balls.forEach(function(ball) {
      ball.trail.forEach(function(p) { const a = p.life/25; ctx.beginPath(); ctx.arc(p.x, p.y, ball.radius*a*0.5, 0, Math.PI*2); ctx.fillStyle = ball.glowTimer > 0 ? "rgba(255, 215, 0, "+(a*0.3)+")" : "rgba(200, 150, 150, "+(a*0.2)+")"; ctx.fill(); });
      if (ball.glowTimer > 0) { const g = Renderer.createRadialGradient(ball.x, ball.y, ball.radius*0.5, ball.radius*1.8, [[0, "rgba(255, 215, 0, "+(ball.glowTimer/120)+")"], [1, "rgba(255, 215, 0, 0)"]]); ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius*1.8, 0, Math.PI*2); ctx.fillStyle = g; ctx.fill(); }
      const op = ball.dying ? 1 - ball.deathProgress : ball.spawnProgress < 1 ? ball.spawnProgress : ball.isDragging ? 0.7 : 1.0;
      Renderer.drawBallWithSquash(ball, op, ball.rotation, ball.squashX, ball.squashY);
      if (ball.isDragging) { ctx.beginPath(); ctx.moveTo(ball.dragStartX, ball.dragStartY); ctx.lineTo(ball.x, ball.y); ctx.strokeStyle = "rgba(100, 100, 100, 0.5)"; ctx.lineWidth = 3; ctx.stroke(); }
    });
  }
  onPointerDown(x, y) {
    for (let i = this.balls.length - 1; i >= 0; i--) {
      if (Physics.contains(this.balls[i], x, y) && !this.balls[i].dying && this.balls[i].spawnProgress >= 1) {
        this.state.draggedBall = this.balls[i]; this.balls[i].isDragging = true; this.balls[i].dragStartX = x; this.balls[i].dragStartY = y; break;
      }
    }
  }
  onPointerMove(x, y) {
    if (!this.state.draggedBall) return;
    const ball = this.state.draggedBall, pad = ball.radius + 10;
    ball.x = Math.max(pad, Math.min(canvas.width - pad, x)); ball.y = Math.max(pad, Math.min(canvas.height - pad, y));
  }
  onPointerUp() {
    if (!this.state.draggedBall) return;
    const ball = this.state.draggedBall;
    ball.vx = (ball.dragStartX - ball.x) * 0.45; ball.vy = (ball.dragStartY - ball.y) * 0.45;
    Physics.capSpeed(ball); ball.isDragging = false; this.state.draggedBall = null;
  }
}

// GAME 2: PADDLE
class PaddleGame extends BaseGame {
  init() {
    super.init();
    this.state = { mouseX: canvas.width/2, mouseY: canvas.height/2, lastMouseX: canvas.width/2, lastMouseY: canvas.height/2, personIndex: ImageCounter.nextPerson() };
    const baseRadius = Config.isMobile ? 25 : 35, radiusVariance = Config.isMobile ? 15 : 20;
    for (let i = 0; i < 15; i++) {
      const a = Math.random()*Math.PI*2, s = 2 + Math.random()*2;
      this.balls.push(this.createBall({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, vx: Math.cos(a)*s, vy: Math.sin(a)*s, radius: baseRadius + Math.random()*radiusVariance, lastHitTime: Date.now(), sleepy: false, fadeProgress: 0, wallHitTimer: 0 }));
    }
  }
  update() {
    super.update();
    const s = this.state, mVx = s.mouseX - s.lastMouseX, mVy = s.mouseY - s.lastMouseY;
    for (let i = this.balls.length - 1; i >= 0; i--) {
      const ball = this.balls[i];
      ball.vy += 0.15;
      const speed = Physics.getSpeed(ball);
      ball.vx *= 0.995; ball.vy *= 0.995; ball.x += ball.vx; ball.y += ball.vy; ball.rotation += speed * 0.02; Physics.capSpeed(ball);
      if (ball.wallHitTimer > 0) ball.wallHitTimer--; else { ball.squashX += (1 - ball.squashX)*0.3; ball.squashY += (1 - ball.squashY)*0.3; }
      if (speed < 1.5 && Date.now() - ball.lastHitTime > 3000) { ball.sleepy = true; ball.fadeProgress += 0.008; if (ball.fadeProgress >= 1) { this.balls.splice(i, 1); this.spawnNewBall(); continue; } }
      else { ball.sleepy = false; ball.fadeProgress = Math.max(0, ball.fadeProgress - 0.02); ball.lastHitTime = Date.now(); }
      this.handleWalls(ball); this.handlePaddle(ball, mVx, mVy);
    }
    Physics.handleBallCollisions(this.balls);
    s.lastMouseX = s.mouseX; s.lastMouseY = s.mouseY;
  }
  handleWalls(ball) {
    if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.9; if (ball.vx > 1) { ball.squashX = 0.85; ball.squashY = 1.15; ball.wallHitTimer = 3; }}
    if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.9; if (ball.vx < -1) { ball.squashX = 0.85; ball.squashY = 1.15; ball.wallHitTimer = 3; }}
    if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.9; if (ball.vy > 1) { ball.squashX = 1.15; ball.squashY = 0.85; ball.wallHitTimer = 3; }}
    if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.7; if (ball.vy < -1) { ball.squashX = 1.15; ball.squashY = 0.85; ball.wallHitTimer = 3; }}
  }
  handlePaddle(ball, mVx, mVy) {
    const s = this.state, dx = ball.x - s.mouseX, dy = ball.y - s.mouseY, dist = Math.sqrt(dx*dx + dy*dy), padR = 55;
    if (dist < ball.radius + padR) {
      const mSpeed = Math.sqrt(mVx*mVx + mVy*mVy), force = Math.min(mSpeed*0.5, 15), ang = Math.atan2(dy, dx);
      ball.vx += Math.cos(ang)*force; ball.vy += Math.sin(ang)*force;
      const overlap = ball.radius + padR - dist; ball.x += Math.cos(ang)*overlap; ball.y += Math.sin(ang)*overlap;
      ball.lastHitTime = Date.now(); ball.sleepy = false; if (force > 3) ScreenShake.add(force*0.3); Physics.capSpeed(ball);
    }
  }
  spawnNewBall() {
    const a = Math.random()*Math.PI*2, ns = 3 + Math.random()*2;
    this.balls.push(this.createBall({ x: Math.random()*canvas.width, y: 100, vx: Math.cos(a)*ns, vy: Math.sin(a)*ns, radius: 35 + Math.random()*20, lastHitTime: Date.now(), sleepy: false, fadeProgress: 0, wallHitTimer: 0 }));
  }
  draw() {
    super.draw();
    const self = this;
    this.balls.forEach(function(ball) {
      const op = 1 - ball.fadeProgress;
      if (ball.sleepy) { ctx.fillStyle = "rgba(100, 100, 200, "+(0.3*op)+")"; ctx.font = "20px Arial"; ctx.textAlign = "center"; ctx.fillText("ðŸ’¤", ball.x, ball.y - ball.radius - 10); }
      Renderer.drawBallWithSquash(ball, op, ball.rotation, ball.squashX, ball.squashY);
    });
    Renderer.drawPerson(this.state.mouseX, this.state.mouseY + 35, 80, this.state.personIndex);
    ctx.beginPath(); ctx.arc(this.state.mouseX, this.state.mouseY, 55, 0, Math.PI*2); ctx.strokeStyle = "rgba(100, 100, 100, 0.3)"; ctx.lineWidth = 3; ctx.stroke();
  }
  onPointerMove(x, y) { this.state.mouseX = x; this.state.mouseY = y; }
}

// GAME 3: POP
class PopGame extends BaseGame {
  init() {
    super.init();
    const baseRadius = Config.isMobile ? 50 : 90, radiusVariance = Config.isMobile ? 20 : 30;
    for (let i = 0; i < 20; i++) {
      const a = Math.random()*Math.PI*2, s = 0.8 + Math.random()*0.8;
      this.balls.push(this.createBall({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, vx: Math.cos(a)*s, vy: Math.sin(a)*s, radius: baseRadius + Math.random()*radiusVariance, popping: false, popProgress: 0, opacity: 1 }));
    }
  }
  update() {
    super.update();
    for (let i = this.balls.length - 1; i >= 0; i--) {
      const ball = this.balls[i];
      if (ball.popping) { ball.popProgress += 0.12; ball.opacity = 1 - ball.popProgress; if (ball.popProgress >= 1) this.balls.splice(i, 1); continue; }
      this.updateBallPhysics(ball, { friction: 0.98, minSpeed: 0.5, bounce: 0.9 });
    }
    Physics.handleBallCollisions(this.balls);
  }
  draw() {
    this.particles.draw(function(p, alpha) {
      const img = Assets.getBallImage(p.ballImage);
      if (Assets.isImageReady(img)) { ctx.save(); ctx.globalAlpha = alpha; ctx.translate(p.x, p.y); ctx.rotate(p.rotation); ctx.drawImage(img, -p.size/2, -p.size/2, p.size, p.size); ctx.restore(); }
    });
    this.balls.forEach(function(ball) {
      ctx.save(); ctx.globalAlpha = ball.opacity;
      if (ball.popping) { const sc = 1 + ball.popProgress*0.8; ctx.translate(ball.x, ball.y); ctx.scale(sc, sc); ctx.rotate(ball.popProgress*0.5); ctx.translate(-ball.x, -ball.y); }
      Renderer.drawBall(ball, 1, ball.rotation); ctx.restore();
    });
  }
  onPointerDown(x, y) {
    const self = this;
    for (let i = this.balls.length - 1; i >= 0; i--) {
      const ball = this.balls[i];
      if (!ball.popping && Physics.contains(ball, x, y)) {
        ball.popping = true; ScreenShake.add(ball.radius * 0.08);
        const nP = Math.floor(ball.radius * 0.25);
        for (let j = 0; j < nP; j++) { const a = Math.random()*Math.PI*2, sp = 3 + Math.random()*5; this.particles.add({ x: ball.x, y: ball.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp - 2, size: 8 + Math.random()*15, life: 40, maxLife: 40, rotation: Math.random()*Math.PI, spin: (Math.random()-0.5)*0.2, gravity: 0.15, ballImage: ball.ballImage }); }
        if (ball.radius > 25) {
          const cR = ball.radius * 0.55, nC = 2 + Math.floor(Math.random()*2);
          for (let j = 0; j < nC; j++) { const a = ((Math.PI*2)/nC)*j + Math.random()*0.5, sp = 4 + Math.random()*4; this.balls.push(this.createBall({ x: ball.x, y: ball.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, radius: cR, popping: false, popProgress: 0, opacity: 1 })); }
        }
        break;
      }
    }
  }
}

// GAME 4: VACUUM
class VacuumGame extends BaseGame {
  init() {
    super.init();
    this.state = { mouseX: canvas.width/2, mouseY: canvas.height/2, isVacuuming: false, vacuumStrength: 0 };
    const baseRadius = Config.isMobile ? 20 : 30, radiusVariance = Config.isMobile ? 18 : 25;
    for (let i = 0; i < 30; i++) this.balls.push(this.createBall({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, radius: baseRadius + Math.random()*radiusVariance }));
  }
  update() {
    super.update();
    const s = this.state;
    if (s.isVacuuming) s.vacuumStrength = Math.min(s.vacuumStrength + 3, 100);
    this.balls.forEach(function(ball) {
      if (s.isVacuuming) { const dx = s.mouseX - ball.x, dy = s.mouseY - ball.y, dist = Math.sqrt(dx*dx + dy*dy), force = Math.min(s.vacuumStrength / (dist + 20), 8); ball.vx += (dx/dist)*force; ball.vy += (dy/dist)*force; }
      if (ball.x < canvas.width/2) ball.vx -= 0.15; else ball.vx += 0.15;
      ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; Physics.capSpeed(ball);
      ball.squashX += (1 - ball.squashX)*0.1; ball.squashY += (1 - ball.squashY)*0.1;
      if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.9; ball.squashX = 0.92; ball.squashY = 1.08; }
      if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.9; ball.squashX = 0.92; ball.squashY = 1.08; }
      if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.9; ball.squashX = 1.08; ball.squashY = 0.92; }
      if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.9; ball.squashX = 1.08; ball.squashY = 0.92; }
    });
    for (let i = 0; i < this.balls.length; i++) {
      for (let j = i + 1; j < this.balls.length; j++) {
        const b1 = this.balls[i], b2 = this.balls[j], dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx*dx + dy*dy), minDist = b1.radius + b2.radius;
        if (dist < minDist) { const ang = Math.atan2(dy, dx), ax = (minDist - dist)*Math.cos(ang)*0.05, ay = (minDist - dist)*Math.sin(ang)*0.05; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; b1.squashX = 0.94; b1.squashY = 1.06; b2.squashX = 0.94; b2.squashY = 1.06; }
      }
    }
  }
  draw() {
    super.draw();
    const s = this.state;
    if (s.isVacuuming) {
      const maxR = 150;
      for (let i = 0; i < 3; i++) { ctx.beginPath(); const r = maxR*(1 - i*0.3)*(s.vacuumStrength/100); ctx.arc(s.mouseX, s.mouseY, r, 0, Math.PI*2); ctx.strokeStyle = "rgba(100, 100, 100, "+(0.3 - i*0.1)+")"; ctx.lineWidth = 3; ctx.stroke(); }
      ctx.beginPath(); ctx.arc(s.mouseX, s.mouseY, 10, 0, Math.PI*2); ctx.fillStyle = "#666"; ctx.fill();
    }
    this.balls.forEach(function(ball) { Renderer.drawBallWithSquash(ball, 1, 0, ball.squashX, ball.squashY); });
  }
  onPointerDown(x, y) { this.state.mouseX = x; this.state.mouseY = y; this.state.isVacuuming = true; this.state.vacuumStrength = 0; }
  onPointerMove(x, y) { this.state.mouseX = x; this.state.mouseY = y; }
  onPointerUp() {
    const s = this.state;
    if (s.isVacuuming) {
      ScreenShake.add(s.vacuumStrength * 0.1);
      this.balls.forEach(function(ball) { const dx = ball.x - s.mouseX, dy = ball.y - s.mouseY, dist = Math.sqrt(dx*dx + dy*dy), force = Math.min(5000 / (dist + 50), 20); ball.vx += (dx/dist)*force; ball.vy += (dy/dist)*force; ball.squashX = 0.85; ball.squashY = 1.15; Physics.capSpeed(ball); });
      s.isVacuuming = false; s.vacuumStrength = 0;
    }
  }
}

// GAME 5: GRAVITY FLIP
class GravityFlipGame extends BaseGame {
  init() {
    super.init();
    this.state = { gravityDir: 1 };
    for (let i = 0; i < 30; i++) this.balls.push(this.createBall({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, radius: 25 + Math.random()*20 }));
  }
  update() {
    super.update();
    const self = this;
    this.balls.forEach(function(ball) {
      ball.vy += 0.25 * self.state.gravityDir;
      ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; Physics.capSpeed(ball);
      ball.squashX += (1 - ball.squashX)*0.25; ball.squashY += (1 - ball.squashY)*0.25;
      if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.75; ball.squashX = 0.85; ball.squashY = 1.15; }
      if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.75; ball.squashX = 0.85; ball.squashY = 1.15; }
      if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.75; ball.squashX = 1.15; ball.squashY = 0.85; }
      if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.75; ball.squashX = 1.15; ball.squashY = 0.85; }
    });
    for (let i = 0; i < this.balls.length; i++) {
      for (let j = i + 1; j < this.balls.length; j++) {
        const b1 = this.balls[i], b2 = this.balls[j], dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx*dx + dy*dy), minDist = b1.radius + b2.radius;
        if (dist < minDist) { const ang = Math.atan2(dy, dx), ax = (minDist - dist)*Math.cos(ang)*0.05, ay = (minDist - dist)*Math.sin(ang)*0.05; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; b1.squashX = 0.9; b1.squashY = 1.1; b2.squashX = 0.9; b2.squashY = 1.1; }
      }
    }
  }
  draw() {
    super.draw();
    this.balls.forEach(function(ball) { Renderer.drawBallWithSquash(ball, 1, 0, ball.squashX, ball.squashY); });
    const aY = this.state.gravityDir === 1 ? canvas.height - 30 : 30;
    ctx.fillStyle = "rgba(0, 0, 0, 0.3)"; ctx.font = "bold 24px Arial"; ctx.textAlign = "center";
    ctx.fillText(this.state.gravityDir === 1 ? "â†“" : "â†‘", canvas.width/2, aY);
  }
  onPointerDown() { this.state.gravityDir *= -1; ScreenShake.add(4); }
}

// GAME 6: BOUNCE (IMPROVED)
class BounceGame extends BaseGame {
  init() {
    super.init();
    const targetRadius = Config.isMobile ? 30 : 50;
    const maxLineLength = Config.isMobile ? 120 : 200;
    this.state = { barriers: [], drawing: false, drawStart: null, drawEnd: null, maxBarriers: 3, maxLineLength: maxLineLength, barrierLifetime: 8000, splats: [], score: 0, target: { x: canvas.width / 2, y: canvas.height / 2, radius: targetRadius, pulse: 0, rotation: 0 } };
    this.spawnBall();
  }

  spawnBall() {
    const ballRadius = Config.isMobile ? 20 : 30;
    this.balls.push(this.createBall({ x: 100 + Math.random() * (canvas.width - 200), y: 100, vx: (Math.random() - 0.5) * 2, vy: 1, radius: ballRadius, growScale: 1, squishX: 1, squishY: 1, squishRecovery: 0.15, dying: false, deathProgress: 0 }));
  }

  update() {
    super.update();
    const s = this.state;
    s.barriers = s.barriers.filter(b => Date.now() - b.created < s.barrierLifetime);
    s.splats = s.splats.filter(sp => sp.life > 0);
    s.splats.forEach(sp => sp.life--);
    s.target.pulse += 0.08; s.target.rotation += 0.02;

    for (let i = this.balls.length - 1; i >= 0; i--) {
      const ball = this.balls[i];
      if (ball.dying) { ball.deathProgress += 0.08; if (ball.deathProgress >= 1) { this.balls.splice(i, 1); setTimeout(() => this.spawnBall(), 500); } continue; }
      ball.vy += 0.08; ball.vx *= 0.995; ball.vy *= 0.995; ball.x += ball.vx; ball.y += ball.vy;
      ball.squishX += (1 - ball.squishX) * ball.squishRecovery; ball.squishY += (1 - ball.squishY) * ball.squishRecovery;
      Physics.capSpeed(ball);

      const dx = ball.x - s.target.x, dy = ball.y - s.target.y, dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < ball.radius * ball.growScale + s.target.radius) {
        s.score++; ball.growScale += 0.15; ScreenShake.add(12);
        this.particles.addBurst(s.target.x, s.target.y, 12, { speed: 4, speedVariance: 4, life: 50, size: 30, sizeVariance: 25, gravity: 0.12, type: "star" });
        s.target.x = 150 + Math.random() * (canvas.width - 300); s.target.y = 250 + Math.random() * (canvas.height - 400);
        const ang = Math.atan2(dy, dx); ball.vx = Math.cos(ang) * 5; ball.vy = Math.sin(ang) * 5;
      }

      if (ball.y + ball.radius * ball.growScale >= canvas.height - 5 && !ball.dying) {
        ball.dying = true; ball.deathProgress = 0; ScreenShake.add(5);
        s.splats.push({ x: ball.x, y: canvas.height, radius: ball.radius * ball.growScale, life: 120, color: `hsl(${Math.random() * 360}, 60%, 50%)` });
        continue;
      }

      if (ball.x - ball.radius * ball.growScale < 0) { ball.x = ball.radius * ball.growScale; ball.vx *= -0.9; ball.squishX = 0.7; ball.squishY = 1.3; }
      if (ball.x + ball.radius * ball.growScale > canvas.width) { ball.x = canvas.width - ball.radius * ball.growScale; ball.vx *= -0.9; ball.squishX = 0.7; ball.squishY = 1.3; }
      if (ball.y - ball.radius * ball.growScale < 0) { ball.y = ball.radius * ball.growScale; ball.vy *= -0.9; ball.squishX = 1.4; ball.squishY = 0.6; }

      s.barriers.forEach(barrier => {
        const result = Physics.lineCircleCollision(barrier.x1, barrier.y1, barrier.x2, barrier.y2, ball.x, ball.y, ball.radius * ball.growScale);
        if (result.collides) {
          ball.x = result.newX; ball.y = result.newY;
          const ang = Math.atan2(barrier.y2 - barrier.y1, barrier.x2 - barrier.x1), nAng = ang + Math.PI / 2, dot = ball.vx * Math.cos(nAng) + ball.vy * Math.sin(nAng);
          ball.vx -= 2 * dot * Math.cos(nAng) * 1.1; ball.vy -= 2 * dot * Math.sin(nAng) * 1.1;
          ball.squishX = 0.75; ball.squishY = 1.25; Physics.capSpeed(ball);
        }
      });
    }
  }

  draw() {
    const s = this.state, t = s.target, pulseScale = 1 + Math.sin(t.pulse) * 0.15;
    const glowGrad = Renderer.createRadialGradient(t.x, t.y, t.radius * 0.3, t.radius * 2.5, [[0, "rgba(255, 220, 100, 0.6)"], [1, "rgba(255, 180, 50, 0)"]]);
    ctx.beginPath(); ctx.arc(t.x, t.y, t.radius * 2.5 * pulseScale, 0, Math.PI * 2); ctx.fillStyle = glowGrad; ctx.fill();
    const size = t.radius * 2.5 * pulseScale, starImg = Assets.stars[0];
    if (Assets.isImageReady(starImg)) { ctx.save(); ctx.translate(t.x, t.y); ctx.rotate(t.rotation); ctx.drawImage(starImg, -size/2, -size/2, size, size); ctx.restore(); }
    super.draw();
    s.splats.forEach(splat => { const a = splat.life / 120, sq = 1 + (1 - a) * 2; ctx.save(); ctx.globalAlpha = a * 0.6; ctx.translate(splat.x, splat.y); ctx.scale(sq, 0.3); ctx.beginPath(); ctx.arc(0, 0, splat.radius, 0, Math.PI * 2); ctx.fillStyle = splat.color; ctx.fill(); ctx.restore(); });
    this.balls.forEach(ball => {
      const img = Assets.getBallImage(ball.ballImage), r = ball.radius * ball.growScale;
      if (Assets.isImageReady(img)) {
        if (ball.dying) { ctx.save(); const sqY = 1 - ball.deathProgress * 0.8, sqX = 1 + ball.deathProgress * 0.5; ctx.translate(ball.x, canvas.height); ctx.scale(sqX, sqY); ctx.globalAlpha = 1 - ball.deathProgress; ctx.drawImage(img, -r, -r * 2, r * 2, r * 2); ctx.restore(); }
        else { ctx.save(); ctx.translate(ball.x, ball.y); ctx.scale(ball.squishX, ball.squishY); ctx.drawImage(img, -r, -r, r * 2, r * 2); ctx.restore(); }
      }
    });
    s.barriers.forEach(barrier => {
      const age = Date.now() - barrier.created, op = Math.max(0, 1 - age / s.barrierLifetime);
      ctx.save(); ctx.shadowColor = "rgba(100, 180, 255, 0.8)"; ctx.shadowBlur = 15 * op;
      ctx.beginPath(); ctx.moveTo(barrier.x1, barrier.y1); ctx.lineTo(barrier.x2, barrier.y2);
      ctx.strokeStyle = `rgba(80, 150, 220, ${op})`; ctx.lineWidth = 8; ctx.lineCap = "round"; ctx.stroke(); ctx.restore();
      ctx.beginPath(); ctx.moveTo(barrier.x1, barrier.y1); ctx.lineTo(barrier.x2, barrier.y2);
      ctx.strokeStyle = `rgba(255, 255, 255, ${op * 0.9})`; ctx.lineWidth = 4; ctx.lineCap = "round"; ctx.stroke();
    });
    if (s.drawing && s.drawStart) {
      let dx = s.drawEnd.x - s.drawStart.x, dy = s.drawEnd.y - s.drawStart.y, len = Math.sqrt(dx*dx + dy*dy);
      if (len > s.maxLineLength) { dx = (dx/len) * s.maxLineLength; dy = (dy/len) * s.maxLineLength; }
      const endX = s.drawStart.x + dx, endY = s.drawStart.y + dy;
      ctx.save(); ctx.shadowColor = "rgba(100, 180, 255, 0.5)"; ctx.shadowBlur = 10;
      ctx.beginPath(); ctx.moveTo(s.drawStart.x, s.drawStart.y); ctx.lineTo(endX, endY);
      ctx.strokeStyle = len > s.maxLineLength ? "rgba(255, 100, 100, 0.5)" : "rgba(80, 150, 220, 0.5)";
      ctx.lineWidth = 8; ctx.lineCap = "round"; ctx.stroke(); ctx.restore();
    }
  }

  onPointerDown(x, y) { if (this.state.barriers.length >= this.state.maxBarriers) return; this.state.drawing = true; this.state.drawStart = { x, y }; this.state.drawEnd = { x, y }; }
  onPointerMove(x, y) { if (this.state.drawing) this.state.drawEnd = { x, y }; }
  onPointerUp() {
    const s = this.state;
    if (s.drawing && s.drawStart && s.drawEnd) {
      let dx = s.drawEnd.x - s.drawStart.x, dy = s.drawEnd.y - s.drawStart.y, len = Math.sqrt(dx*dx + dy*dy);
      if (len > 20) { if (len > s.maxLineLength) { dx = (dx/len) * s.maxLineLength; dy = (dy/len) * s.maxLineLength; }
        s.barriers.push({ x1: s.drawStart.x, y1: s.drawStart.y, x2: s.drawStart.x + dx, y2: s.drawStart.y + dy, created: Date.now() });
      }
    }
    s.drawing = false; s.drawStart = null; s.drawEnd = null;
  }
}

// GAME 7-16 and Manager (simplified for brevity - core changes applied)
class MagnetZonesGame extends BaseGame { init() { super.init(); this.state = { magnets: [], shiftPressed: false, lastTapTime: 0, lastTapX: 0, lastTapY: 0 }; for (let i = 0; i < 20; i++) this.balls.push(this.createBall({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, vx: (Math.random()-0.5)*3, vy: (Math.random()-0.5)*3, radius: 18 + Math.random()*15 })); } update() { super.update(); const self = this; this.state.magnets = this.state.magnets.filter(function(m) { return Date.now() - m.created < 10000; }); this.balls.forEach(function(ball) { ball.vy += 0.15; self.state.magnets.forEach(function(magnet) { const dx = magnet.x - ball.x, dy = magnet.y - ball.y, dist = Math.sqrt(dx*dx + dy*dy), force = (magnet.type === "attract" ? 1 : -1) * Math.min(200 / (dist + 20), 4); ball.vx += (dx/dist)*force; ball.vy += (dy/dist)*force; }); ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; Physics.capSpeed(ball); Physics.handleWallCollision(ball, canvas, 0.7, false); }); Physics.handleBallCollisions(this.balls); } draw() { super.draw(); const self = this; this.state.magnets.forEach(function(magnet) { const age = Date.now() - magnet.created, op = Math.max(0, 1 - age/10000), isAttr = magnet.type === "attract", time = Date.now()*0.0015; if (isAttr) { for (let i = 0; i < 4; i++) { const bR = 100 - ((time*30 + i*25) % 100); ctx.beginPath(); ctx.arc(magnet.x, magnet.y, bR, 0, Math.PI*2); ctx.strokeStyle = "rgba(50, 150, 255, "+(op*(0.5-i*0.1))+")"; ctx.lineWidth = 3; ctx.stroke(); } } else { for (let i = 0; i < 4; i++) { const bR = 20 + ((time*30 + i*25) % 100); ctx.beginPath(); ctx.arc(magnet.x, magnet.y, bR, 0, Math.PI*2); ctx.strokeStyle = "rgba(255, 80, 80, "+(op*(0.5-i*0.1))+")"; ctx.lineWidth = 3; ctx.stroke(); } } const g = Renderer.createRadialGradient(magnet.x, magnet.y, 0, 60, [[0, isAttr ? "rgba(50, 150, 255, "+(op*0.4)+")" : "rgba(255, 80, 80, "+(op*0.4)+")"], [1, isAttr ? "rgba(50, 150, 255, 0)" : "rgba(255, 80, 80, 0)"]]); ctx.beginPath(); ctx.arc(magnet.x, magnet.y, 60, 0, Math.PI*2); ctx.fillStyle = g; ctx.fill(); Renderer.drawPerson(magnet.x, magnet.y + 80, 55, magnet.personIndex, op); ctx.font = "bold 28px Arial"; ctx.textAlign = "center"; ctx.fillStyle = isAttr ? "rgba(50, 150, 255, "+op+")" : "rgba(255, 80, 80, "+op+")"; ctx.fillText(isAttr ? "âŠ•" : "âŠ–", magnet.x, magnet.y - 5); }); this.balls.forEach(function(ball) { Renderer.drawBall(ball); }); ctx.fillStyle = "#666"; ctx.font = "14px Arial"; ctx.textAlign = "left"; ctx.fillText(Config.isMobile ? (this.state.shiftPressed ? "Mode: REPEL" : "Mode: ATTRACT [double-tap for repel]") : (this.state.shiftPressed ? "Mode: REPEL" : "Mode: ATTRACT [hold SHIFT]"), 20, canvas.height - 80); } onPointerDown(x, y) { const now = Date.now(), timeSinceLastTap = now - this.state.lastTapTime, distFromLastTap = Math.sqrt((x - this.state.lastTapX)*(x - this.state.lastTapX) + (y - this.state.lastTapY)*(y - this.state.lastTapY)); const isDoubleTap = Config.isMobile && timeSinceLastTap < 300 && distFromLastTap < 50; const type = (this.state.shiftPressed || isDoubleTap) ? "repel" : "attract"; this.state.magnets.push({ x:x, y:y, type: type, created: Date.now(), personIndex: ImageCounter.nextPerson() }); this.state.lastTapTime = now; this.state.lastTapX = x; this.state.lastTapY = y; } }

class ExplodeGame extends BaseGame { init() { super.init(); this.state = { chargeStart: 0, charging: false, chargeX: 0, chargeY: 0 }; } update() { super.update(); for (let i = this.balls.length - 1; i >= 0; i--) { const ball = this.balls[i]; ball.vy += 0.2; ball.vx *= 0.99; ball.vy *= 0.99; ball.x += ball.vx; ball.y += ball.vy; Physics.capSpeed(ball); ball.life--; ball.opacity = Math.min(1, ball.life/60); if (ball.life <= 0 || ball.y > canvas.height + 50) { this.balls.splice(i, 1); continue; } Physics.handleWallCollision(ball, canvas, 0.7, false); } Physics.handleBallCollisions(this.balls); } draw() { super.draw(); const s = this.state; if (s.charging) { const cT = Date.now() - s.chargeStart, cA = Math.min(cT/1000, 1), r = 20 + cA*60, pulse = Math.sin(Date.now()*0.02)*5; ctx.beginPath(); ctx.arc(s.chargeX, s.chargeY, r + pulse, 0, Math.PI*2); ctx.strokeStyle = "rgba(100, 100, 100, "+(0.3 + cA*0.4)+")"; ctx.lineWidth = 3 + cA*3; ctx.stroke(); ctx.beginPath(); ctx.arc(s.chargeX, s.chargeY, r*0.3, 0, Math.PI*2); ctx.fillStyle = "rgba(80, 80, 80, "+(0.3 + cA*0.5)+")"; ctx.fill(); ctx.fillStyle = "#666"; ctx.font = "bold 16px Arial"; ctx.textAlign = "center"; ctx.fillText(Math.floor(cA*100)+"%", s.chargeX, s.chargeY + r + 25); } this.balls.forEach(function(ball) { ctx.save(); ctx.globalAlpha = ball.opacity; Renderer.drawBall(ball); ctx.restore(); }); } onPointerDown(x, y) { this.state.charging = true; this.state.chargeStart = Date.now(); this.state.chargeX = x; this.state.chargeY = y; } onPointerUp() { const s = this.state; if (!s.charging) return; const cT = Date.now() - s.chargeStart, cA = Math.min(cT/1000, 1), power = 5 + cA*12, numBalls = Math.floor(8 + cA*27); ScreenShake.add(cA*10); for (let i = 0; i < numBalls; i++) { const ang = ((Math.PI*2)/numBalls)*i + Math.random()*0.2, sV = 0.7 + Math.random()*0.6; this.balls.push(this.createBall({ x: s.chargeX, y: s.chargeY, vx: Math.cos(ang)*power*sV, vy: Math.sin(ang)*power*sV, radius: 12 + Math.random()*29, life: 150 + Math.random()*100, opacity: 1 })); } s.charging = false; } }

// GAME 9: ORBITAL (IMPROVED - gentle re-orbit pull)
class OrbitalGame extends BaseGame { init() { super.init(); this.state = { mouseX: canvas.width/2, mouseY: canvas.height/2 }; for (let i = 0; i < 40; i++) { const ang = ((Math.PI*2)/40)*i, dist = 60 + Math.random()*180; this.balls.push({ angle: ang, distance: dist, angleSpeed: (0.02 + Math.random()*0.04)*(Math.random() > 0.5 ? 1 : -1), radius: 15 + Math.random()*18, orbiting: true, vx: 0, vy: 0, x: 0, y: 0, ballImage: ImageCounter.nextBall(), originalDistance: dist }); } } update() { super.update(); const s = this.state; this.balls.forEach(function(ball) { if (ball.orbiting) { ball.angle += ball.angleSpeed; ball.x = s.mouseX + Math.cos(ball.angle)*ball.distance; ball.y = s.mouseY + Math.sin(ball.angle)*ball.distance; } else { ball.vy += 0.2; ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy; Physics.capSpeed(ball); Physics.handleWallCollision(ball, canvas, 0.7, false); const dx = s.mouseX - ball.x, dy = s.mouseY - ball.y, dist = Math.sqrt(dx*dx + dy*dy); if (dist > 0) { const pullStrength = 0.008; ball.vx += (dx/dist)*pullStrength; ball.vy += (dy/dist)*pullStrength; } } }); const freeBalls = this.balls.filter(function(b) { return !b.orbiting; }); Physics.handleBallCollisions(freeBalls); } draw() { super.draw(); const s = this.state; this.balls.filter(function(b) { return b.orbiting; }).forEach(function(ball) { ctx.beginPath(); ctx.arc(s.mouseX, s.mouseY, ball.distance, 0, Math.PI*2); ctx.strokeStyle = "rgba(200, 200, 200, 0.2)"; ctx.lineWidth = 1; ctx.stroke(); }); this.balls.forEach(function(ball) { Renderer.drawBall(ball, ball.orbiting ? 0.8 : 1.0); }); ctx.beginPath(); ctx.arc(s.mouseX, s.mouseY, 5, 0, Math.PI*2); ctx.fillStyle = "#999"; ctx.fill(); } onPointerMove(x, y) { this.state.mouseX = x; this.state.mouseY = y; } onPointerDown() { this.balls.forEach(function(ball) { if (ball.orbiting) { ball.orbiting = false; const tS = Math.abs(ball.angleSpeed)*ball.distance*2; ball.vx = Math.cos(ball.angle + Math.PI/2)*tS + Math.cos(ball.angle)*8; ball.vy = Math.sin(ball.angle + Math.PI/2)*tS + Math.sin(ball.angle)*8; Physics.capSpeed(ball); } }); } }

// Placeholder classes for remaining games (simplified versions)
class DefendGame extends BaseGame { init() { super.init(); this.state = { centerRadius: 80, centerX: canvas.width/2, centerY: canvas.height/2, spawnTimer: 0, spawnDelay: 80, pulse: 0, targetRadius: 40 }; for (let i = 0; i < 3; i++) this.spawnBall(); } spawnBall() { const side = Math.floor(Math.random()*4); let x, y, vx, vy; switch(side) { case 0: x = Math.random()*canvas.width; y = -30; vx = (Math.random()-0.5)*1.5; vy = 0.8 + Math.random()*0.5; break; case 1: x = canvas.width + 30; y = Math.random()*canvas.height; vx = -0.8 - Math.random()*0.5; vy = (Math.random()-0.5)*1.5; break; case 2: x = Math.random()*canvas.width; y = canvas.height + 30; vx = (Math.random()-0.5)*1.5; vy = -0.8 - Math.random()*0.5; break; case 3: x = -30; y = Math.random()*canvas.height; vx = 0.8 + Math.random()*0.5; vy = (Math.random()-0.5)*1.5; break; } this.balls.push(this.createBall({ x:x, y:y, vx:vx, vy:vy, radius: 25 + Math.random()*15, personImage: ImageCounter.nextPerson(), isGuard: false, breached: false, breachProgress: 0, originalRadius: 0, stretchAngle: 0 })); } findNearestThreat(guard) { const s = this.state; let nearest = null, nearestDist = Infinity; for (let i = 0; i < this.balls.length; i++) { const ball = this.balls[i]; if (ball === guard || ball.isGuard || ball.breached) continue; const enemyDistToCenter = Physics.distance(ball.x, ball.y, s.centerX, s.centerY), urgency = Math.max(0, 300 - enemyDistToCenter), distToGuard = Physics.distance(ball.x, ball.y, guard.x, guard.y), score = distToGuard - urgency; if (score < nearestDist) { nearestDist = score; nearest = ball; } } return nearest; } update() { super.update(); const s = this.state, self = this; s.spawnTimer++; s.pulse += 0.03; if (s.centerRadius < s.targetRadius) s.centerRadius += (s.targetRadius - s.centerRadius)*0.08; const maxRadius = Math.min(canvas.width, canvas.height)*0.48; if (s.centerRadius >= maxRadius) { this.init(); return; } if (this.balls.length < 12 && s.spawnTimer >= s.spawnDelay) { this.spawnBall(); s.spawnTimer = 0; } for (let i = this.balls.length - 1; i >= 0; i--) { const ball = this.balls[i], dx = s.centerX - ball.x, dy = s.centerY - ball.y, dist = Math.sqrt(dx*dx + dy*dy); if (ball.isGuard) { const threat = this.findNearestThreat(ball); if (threat) { const threatDx = s.centerX - threat.x, threatDy = s.centerY - threat.y, threatDist = Math.sqrt(threatDx*threatDx + threatDy*threatDy); const interceptX = threat.x + (threatDx/threatDist)*(ball.radius + threat.radius + 20), interceptY = threat.y + (threatDy/threatDist)*(ball.radius + threat.radius + 20); const toInterceptX = interceptX - ball.x, toInterceptY = interceptY - ball.y, toInterceptDist = Math.sqrt(toInterceptX*toInterceptX + toInterceptY*toInterceptY); if (toInterceptDist > 5) { const chaseSpeed = 0.4; ball.vx += (toInterceptX/toInterceptDist)*chaseSpeed; ball.vy += (toInterceptY/toInterceptDist)*chaseSpeed; } } else { const patrolDist = s.centerRadius + 50; if (dist < patrolDist - 10) { ball.vx -= (dx/dist)*0.15; ball.vy -= (dy/dist)*0.15; } else if (dist > patrolDist + 10) { ball.vx += (dx/dist)*0.15; ball.vy += (dy/dist)*0.15; } const perpX = -dy/dist, perpY = dx/dist; ball.vx += perpX*0.08; ball.vy += perpY*0.08; } ball.vx *= 0.94; ball.vy *= 0.94; ball.x += ball.vx; ball.y += ball.vy; for (let j = this.balls.length - 1; j >= 0; j--) { if (i === j || this.balls[j].isGuard || this.balls[j].breached) continue; const enemy = this.balls[j], edx = enemy.x - ball.x, edy = enemy.y - ball.y, eDist = Math.sqrt(edx*edx + edy*edy), hitDist = ball.radius + enemy.radius + 8; if (eDist < hitDist) { const ang = Math.atan2(edy, edx), enemyDistToCenter = Math.sqrt((enemy.x - s.centerX)*(enemy.x - s.centerX) + (enemy.y - s.centerY)*(enemy.y - s.centerY)), urgency = Math.max(1, 3 - enemyDistToCenter/s.centerRadius), deflectPower = 6*urgency; enemy.vx = Math.cos(ang)*deflectPower; enemy.vy = Math.sin(ang)*deflectPower; ScreenShake.add(4*urgency); this.particles.addBurst((ball.x + enemy.x)/2, (ball.y + enemy.y)/2, 6, { speed: 3, life: 20, size: 10, type: "star" }); } } } else if (ball.breached) { ball.breachProgress += 0.025; const ease = ball.breachProgress*ball.breachProgress; ball.radius = ball.originalRadius*(1 - ease*0.95); const pullStrength = 0.05 + ball.breachProgress*0.15; ball.x += (s.centerX - ball.x)*pullStrength; ball.y += (s.centerY - ball.y)*pullStrength; if (ball.breachProgress >= 1) { const growthAmount = ball.originalRadius*0.8; s.targetRadius += growthAmount; ScreenShake.add(8); this.balls.splice(i, 1); continue; } } else { const maxDist = 400, normalizedDist = Math.min(dist, maxDist)/maxDist, gravityStrength = 0.01 + (1 - normalizedDist)*0.04; ball.vx += (dx/dist)*gravityStrength; ball.vy += (dy/dist)*gravityStrength; const spiralStrength = (1 - normalizedDist)*0.008; ball.vx += (-dy/dist)*spiralStrength; ball.vy += (dx/dist)*spiralStrength; ball.vx *= 0.995; ball.vy *= 0.995; ball.x += ball.vx; ball.y += ball.vy; if (dist < s.centerRadius) { ball.breached = true; ball.breachProgress = 0; ball.originalRadius = ball.radius; ball.stretchAngle = Math.atan2(dy, dx); ScreenShake.add(10); continue; } if (ball.x < -100 || ball.x > canvas.width + 100 || ball.y < -100 || ball.y > canvas.height + 100) { this.balls.splice(i, 1); continue; } } if (!ball.breached) Physics.handleWallCollision(ball, canvas, 0.7, false); } } draw() { super.draw(); const s = this.state, pulseSize = Math.sin(s.pulse)*5, centerSize = s.centerRadius*2.5 + pulseSize; const gradient = Renderer.createRadialGradient(s.centerX, s.centerY, s.centerRadius*0.5, s.centerRadius*1.8, [[0, "rgba(0, 0, 0, 0.3)"], [0.7, "rgba(20, 0, 30, 0.1)"], [1, "rgba(0, 0, 0, 0)"]]); ctx.beginPath(); ctx.arc(s.centerX, s.centerY, s.centerRadius*1.8, 0, Math.PI*2); ctx.fillStyle = gradient; ctx.fill(); Renderer.drawImage(Assets.special.blackCircle, s.centerX - centerSize/2, s.centerY - centerSize/2, centerSize, centerSize, 0.85); const self = this; this.balls.forEach(function(ball) { if (ball.isGuard) { Renderer.drawPerson(ball.x, ball.y + ball.radius*0.8, ball.radius*2.2, ball.personImage); ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius + 12, 0, Math.PI*2); ctx.strokeStyle = "rgba(100, 220, 120, 0.6)"; ctx.lineWidth = 2; ctx.stroke(); } else if (ball.breached) { ctx.save(); ctx.translate(ball.x, ball.y); ctx.rotate(ball.stretchAngle + Math.PI); const stretch = 1 + ball.breachProgress*1.5, squash = 1/Math.sqrt(stretch); ctx.scale(squash, stretch); ctx.filter = "grayscale("+(ball.breachProgress*100)+"%) brightness("+(1 - ball.breachProgress*0.5)+")"; ctx.globalAlpha = 1 - ball.breachProgress*0.8; ctx.translate(-ball.x, -ball.y); Renderer.drawBall(ball); ctx.restore(); } else { const distToCenter = Physics.distance(ball.x, ball.y, s.centerX, s.centerY), dangerZone = s.centerRadius*2; if (distToCenter < dangerZone) { const danger = 1 - distToCenter/dangerZone; ctx.save(); ctx.filter = "saturate("+(1 + danger*0.5)+")"; Renderer.drawBall(ball); ctx.restore(); } else Renderer.drawBall(ball); } }); } onPointerDown(x, y) { for (let i = this.balls.length - 1; i >= 0; i--) { if (!this.balls[i].breached && Physics.contains(this.balls[i], x, y)) { this.balls[i].isGuard = !this.balls[i].isGuard; break; } } } }

class ConnectionsGame extends BaseGame {
  init() {
    super.init();
    this.state = { connections: [], firstEntity: null, hoveredEntity: null, score: 0, exploded: 0, dyingEntities: [] };
    for (let i = 0; i < 8; i++) { const a = Math.random() * Math.PI * 2, s = 1.5 + Math.random() * 1.5; this.balls.push(this.createBall({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a) * s, vy: Math.sin(a) * s, radius: 25 + Math.random() * 15, type: "ball", rotationSpeed: (Math.random() - 0.5) * 0.03, scale: 1, targetScale: 1 })); }
    for (let i = 0; i < 8; i++) { const a = Math.random() * Math.PI * 2, s = 1 + Math.random(); this.balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a) * s, vy: Math.sin(a) * s, radius: 35, clickRadius: 50, personImage: ImageCounter.nextPerson(), type: "person", rotation: Math.random() * Math.PI * 2, rotationSpeed: (Math.random() - 0.5) * 0.02, scale: 1, targetScale: 1 }); }
  }

  getDeathState(entity) { for (const dying of this.state.dyingEntities) { if (dying.entity1 === entity || dying.entity2 === entity) return dying; } return null; }

  update() {
    super.update();
    const s = this.state;
    s.dyingEntities = s.dyingEntities.filter(dying => {
      dying.timer--;
      if (dying.timer <= 0) {
        if (dying.phase === "red") { dying.phase = "grey"; dying.timer = 25; }
        else if (dying.phase === "grey") { dying.phase = "explode"; dying.timer = 1; }
        else if (dying.phase === "explode") {
          const cx = (dying.entity1.x + dying.entity2.x) / 2, cy = (dying.entity1.y + dying.entity2.y) / 2;
          ScreenShake.add(20);
          for (let j = 0; j < 5; j++) { const a = -Math.PI / 2 + (Math.random() - 0.5) * 1, sp = 3 + Math.random() * 4; this.particles.add({ x: cx, y: cy, vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 3, size: 50 + Math.random() * 30, life: 60, maxLife: 60, type: "ko" }); }
          s.connections = s.connections.filter(c => c.entity1 !== dying.entity1 && c.entity2 !== dying.entity1 && c.entity1 !== dying.entity2 && c.entity2 !== dying.entity2);
          const idx1 = this.balls.indexOf(dying.entity1), idx2 = this.balls.indexOf(dying.entity2);
          if (idx1 > idx2) { this.balls.splice(idx1, 1); this.balls.splice(idx2, 1); } else { this.balls.splice(idx2, 1); this.balls.splice(idx1, 1); }
          setTimeout(() => {
            const a1 = Math.random() * Math.PI * 2, a2 = Math.random() * Math.PI * 2;
            this.balls.push(this.createBall({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a1) * 2, vy: Math.sin(a1) * 2, radius: 25 + Math.random() * 15, type: "ball", rotationSpeed: (Math.random() - 0.5) * 0.03, scale: 1, targetScale: 1 }));
            this.balls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a2) * 1.5, vy: Math.sin(a2) * 1.5, radius: 35, clickRadius: 50, personImage: ImageCounter.nextPerson(), type: "person", rotation: Math.random() * Math.PI * 2, rotationSpeed: (Math.random() - 0.5) * 0.02, scale: 1, targetScale: 1 });
          }, 500);
          return false;
        }
      }
      return true;
    });
    s.connections.forEach(conn => {
      const b1 = conn.entity1, b2 = conn.entity2;
      if (!this.balls.includes(b1) || !this.balls.includes(b2)) return;
      const dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx*dx + dy*dy), stretch = dist - conn.restLength, force = stretch * 0.02, fx = (dx/dist) * force, fy = (dy/dist) * force;
      b1.vx += fx; b1.vy += fy; b2.vx -= fx; b2.vy -= fy;
    });
    this.balls.forEach(ball => {
      const isDying = this.getDeathState(ball);
      if (!isDying) { ball.scale += (ball.targetScale - ball.scale) * 0.15; ball.rotation += ball.rotationSpeed; }
      const speed = Physics.getSpeed(ball);
      if (speed < 0.3) { const a = Math.atan2(ball.vy, ball.vx); ball.vx = Math.cos(a) * 0.8; ball.vy = Math.sin(a) * 0.8; }
      ball.vx *= 0.98; ball.vy *= 0.98; ball.x += ball.vx; ball.y += ball.vy;
      Physics.capSpeed(ball); Physics.handleWallCollision(ball, canvas, 0.8, false);
    });
    Physics.handleBallCollisions(this.balls);
  }

  draw() {
    const s = this.state;
    super.draw();
    s.connections.forEach(conn => { if (!this.balls.includes(conn.entity1) || !this.balls.includes(conn.entity2)) return; ctx.beginPath(); ctx.moveTo(conn.entity1.x, conn.entity1.y); ctx.lineTo(conn.entity2.x, conn.entity2.y); ctx.strokeStyle = "rgba(100, 200, 100, 0.6)"; ctx.lineWidth = 3; ctx.stroke(); });
    this.balls.forEach(entity => {
      const isSel = s.firstEntity === entity, deathState = this.getDeathState(entity);
      ctx.save();
      if (deathState) { if (deathState.phase === "red") { const pulse = Math.sin(deathState.timer * 0.3) * 0.3 + 0.7; ctx.filter = `saturate(2) sepia(1) hue-rotate(-50deg) brightness(${pulse})`; } else if (deathState.phase === "grey") { const fadeProgress = 1 - deathState.timer / 25; ctx.filter = `grayscale(1) opacity(${1 - fadeProgress * 0.7})`; } }
      const scale = entity.scale || 1;
      ctx.translate(entity.x, entity.y); ctx.scale(scale, scale);
      if (deathState && deathState.phase === "grey") { const fadeProgress = 1 - deathState.timer / 25; ctx.scale(1 - fadeProgress * 0.3, 1 - fadeProgress * 0.3); }
      ctx.translate(-entity.x, -entity.y);
      if (isSel && !deathState) { ctx.shadowColor = "rgba(100, 200, 255, 0.8)"; ctx.shadowBlur = 20; }
      if (entity.type === "person") Renderer.drawPerson(entity.x, entity.y + 10, 55, entity.personImage);
      else Renderer.drawBall(entity);
      ctx.restore();
    });
  }

  onPointerMove(x, y) {
    this.balls.forEach(entity => { entity.targetScale = 1; });
    this.state.hoveredEntity = null;
    for (let i = this.balls.length - 1; i >= 0; i--) {
      const entity = this.balls[i];
      if (this.getDeathState(entity)) continue;
      const clickR = entity.clickRadius || entity.radius, dx = x - entity.x, dy = y - entity.y;
      if (Math.sqrt(dx*dx + dy*dy) < clickR + 10) { this.state.hoveredEntity = entity; entity.targetScale = 1.25; break; }
    }
  }

  onPointerDown(x, y) {
    const s = this.state;
    for (let i = this.balls.length - 1; i >= 0; i--) {
      const entity = this.balls[i];
      if (this.getDeathState(entity)) continue;
      const clickR = entity.clickRadius || entity.radius, dx = x - entity.x, dy = y - entity.y;
      if (Math.sqrt(dx*dx + dy*dy) < clickR + 10) {
        if (!s.firstEntity) { s.firstEntity = entity; entity.targetScale = 1.3; }
        else if (s.firstEntity !== entity) {
          if (s.firstEntity.type === entity.type) { s.exploded++; s.dyingEntities.push({ entity1: s.firstEntity, entity2: entity, phase: "red", timer: 30 }); }
          else {
            const existingConn = s.connections.find(c => (c.entity1 === s.firstEntity && c.entity2 === entity) || (c.entity2 === s.firstEntity && c.entity1 === entity));
            if (!existingConn) {
              const dx = entity.x - s.firstEntity.x, dy = entity.y - s.firstEntity.y, dist = Math.sqrt(dx*dx + dy*dy);
              s.connections.push({ entity1: s.firstEntity, entity2: entity, restLength: Math.min(dist, 150) }); s.score++;
              const cx = (s.firstEntity.x + entity.x) / 2, cy = (s.firstEntity.y + entity.y) / 2;
              this.particles.addBurst(cx, cy, 8, { speed: 3, speedVariance: 3, life: 50, size: 30, sizeVariance: 20, gravity: 0.15, type: "heart" });
            }
          }
          s.firstEntity = null;
        }
        return;
      }
    }
    s.firstEntity = null;
  }
}

class MergeSplitGame extends BaseGame {
  init() {
    super.init();
    this.state = { mergingPairs: [], victory: false };
    const baseRadius = Config.isMobile ? 18 : 30;
    const radiusVariance = Config.isMobile ? 8 : 12;
    for (let i = 0; i < 25; i++) {
      const a = Math.random() * Math.PI * 2, s = 1 + Math.random() * 1.5;
      const ball = this.createBall({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(a) * s, vy: Math.sin(a) * s, radius: baseRadius + Math.random() * radiusVariance, mass: 1, id: Date.now() + Math.random(), spinAngle: 0, merging: false, walkers: [] });
      ball.walkers.push({ angle: Math.random() * Math.PI * 2, walkSpeed: 0.015 + Math.random() * 0.015, direction: Math.random() > 0.5 ? 1 : -1, personIndex: ImageCounter.nextPerson() });
      this.balls.push(ball);
    }
  }

  update() {
    super.update();
    const s = this.state;
    if (this.balls.length === 1 && !s.victory) { s.victory = true; ScreenShake.add(15); this.particles.addBurst(this.balls[0].x, this.balls[0].y, 30, { speed: 4, speedVariance: 4, life: 40, size: 15, sizeVariance: 10, gravity: 0.05, type: "star" }); }

    for (let p = s.mergingPairs.length - 1; p >= 0; p--) {
      const pair = s.mergingPairs[p];
      pair.progress += 0.025;
      const b1 = pair.ball1, b2 = pair.ball2;
      if (!this.balls.includes(b1) || !this.balls.includes(b2)) { s.mergingPairs.splice(p, 1); continue; }
      const dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx*dx + dy*dy), pullF = 0.4;
      b1.vx += (dx/dist) * pullF; b1.vy += (dy/dist) * pullF; b2.vx -= (dx/dist) * pullF; b2.vy -= (dy/dist) * pullF;
      b1.spinAngle += 0.15; b2.spinAngle -= 0.15;
      if (pair.progress >= 1 || dist < 20) {
        const tM = b1.mass + b2.mass, nR = Math.sqrt(b1.radius * b1.radius + b2.radius * b2.radius), cW = [...b1.walkers, ...b2.walkers];
        cW.forEach((w, idx) => { w.angle = ((Math.PI * 2) / cW.length) * idx; });
        const mergeX = (b1.x * b1.mass + b2.x * b2.mass) / tM, mergeY = (b1.y * b1.mass + b2.y * b2.mass) / tM;
        const newBall = this.createBall({ x: mergeX, y: mergeY, vx: (b1.vx * b1.mass + b2.vx * b2.mass) / tM, vy: (b1.vy * b1.mass + b2.vy * b2.mass) / tM, radius: nR, mass: tM, id: Date.now() + Math.random(), spinAngle: 0, merging: false, walkers: cW });
        const i1 = this.balls.indexOf(b1), i2 = this.balls.indexOf(b2);
        if (i1 > i2) { this.balls.splice(i1, 1); this.balls.splice(i2, 1); } else { this.balls.splice(i2, 1); this.balls.splice(i1, 1); }
        this.balls.push(newBall);
        this.particles.addBurst(mergeX, mergeY, 12, { speed: 3, speedVariance: 3, life: 30, size: 12, sizeVariance: 10, gravity: 0.05, type: "star" });
        ScreenShake.add(6); s.mergingPairs.splice(p, 1);
      }
    }

    this.balls.forEach(ball => {
      if (ball.merging) return;
      ball.walkers.forEach(w => { w.angle += w.walkSpeed * w.direction; });
      const speed = Physics.getSpeed(ball);
      if (speed < 0.4) { const a = Math.atan2(ball.vy, ball.vx); ball.vx = Math.cos(a) * 0.8; ball.vy = Math.sin(a) * 0.8; }
      ball.vx *= 0.99; ball.vy *= 0.99; ball.x += ball.vx; ball.y += ball.vy;
      Physics.capSpeed(ball); Physics.handleWallCollision(ball, canvas, 0.8, false);
    });

    for (let i = this.balls.length - 1; i >= 0; i--) {
      for (let j = i - 1; j >= 0; j--) {
        const b1 = this.balls[i], b2 = this.balls[j];
        if (b1.merging || b2.merging) continue;
        const dx = b2.x - b1.x, dy = b2.y - b1.y, dist = Math.sqrt(dx*dx + dy*dy), minDist = b1.radius + b2.radius;
        if (dist < minDist * 0.9) {
          const rVx = b2.vx - b1.vx, rVy = b2.vy - b1.vy, rS = Math.sqrt(rVx*rVx + rVy*rVy);
          if (rS < 2.5) { b1.merging = true; b2.merging = true; s.mergingPairs.push({ ball1: b1, ball2: b2, progress: 0 }); }
          else { const ang = Math.atan2(dy, dx), ax = (minDist - dist) * Math.cos(ang) * 0.1, ay = (minDist - dist) * Math.sin(ang) * 0.1; b1.vx -= ax; b1.vy -= ay; b2.vx += ax; b2.vy += ay; }
        }
      }
    }
  }

  draw() {
    this.balls.forEach(ball => {
      ctx.save(); if (ball.merging) { ctx.translate(ball.x, ball.y); ctx.rotate(ball.spinAngle); ctx.translate(-ball.x, -ball.y); }
      Renderer.drawBall(ball); ctx.restore();
      const basePersonH = 40, sF = Math.sqrt(ball.mass), pH = Math.min(basePersonH * sF, ball.radius * 0.7);
      ball.walkers.forEach(w => { const wX = ball.x + Math.cos(w.angle) * ball.radius, wY = ball.y + Math.sin(w.angle) * ball.radius, rot = w.angle + Math.PI / 2; Renderer.drawPerson(wX, wY, pH, w.personIndex, 1, rot); });
    });
    super.draw();
    if (this.state.victory) { ctx.fillStyle = "#4A4"; ctx.font = "bold 32px Arial"; ctx.textAlign = "center"; ctx.fillText("ðŸŒ One World! ðŸŒ", canvas.width / 2, 160); }
  }

  onPointerDown(x, y) {
    for (let i = this.balls.length - 1; i >= 0; i--) {
      const ball = this.balls[i];
      if (Physics.contains(ball, x, y) && ball.mass > 1 && !ball.merging) {
        this.particles.addBurst(ball.x, ball.y, 15, { speed: 3, speedVariance: 3, life: 30, size: 12, sizeVariance: 10, gravity: 0.05, type: "star" });
        const numS = Math.min(ball.mass, 4), wPN = Math.floor(ball.walkers.length / numS);
        for (let j = 0; j < numS; j++) {
          const ang = ((Math.PI * 2) / numS) * j, sp = 3 + Math.random() * 2;
          const nB = this.createBall({ x: ball.x, y: ball.y, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp, radius: ball.radius / Math.sqrt(numS), mass: 1, id: Date.now() + Math.random() + j, spinAngle: 0, merging: false, walkers: ball.walkers.slice(j * wPN, (j + 1) * wPN) });
          if (nB.walkers.length === 0) nB.walkers.push({ angle: Math.random() * Math.PI * 2, walkSpeed: 0.015 + Math.random() * 0.015, direction: Math.random() > 0.5 ? 1 : -1, personIndex: ImageCounter.nextPerson() });
          this.balls.push(nB);
        }
        this.balls.splice(i, 1); this.state.victory = false; ScreenShake.add(5); break;
      }
    }
  }
}
// GAME 13: INFLATE (IMPROVED - slower)
class InflateGame extends BaseGame { init() { super.init(); this.state = { popEffects: [] }; const baseRadius = Config.isMobile ? 25 : 35, maxRadius = Config.isMobile ? 130 : 180; for (let i = 0; i < 30; i++) this.balls.push(this.createBall({ x: 100 + Math.random()*(canvas.width-200), y: 100 + Math.random()*(canvas.height-200), vx: (Math.random()-0.5)*0.5, vy: (Math.random()-0.5)*0.5, radius: baseRadius, baseRadius: baseRadius, maxRadius: maxRadius, inflateProgress: 0, inflateSpeed: 0.8 + Math.random()*0.08 })); } update() { super.update(); const self = this; this.state.popEffects = this.state.popEffects.filter(function(e) { e.progress += 0.06; e.rotation += e.spinSpeed; return e.progress < 1; }); for (let i = this.balls.length - 1; i >= 0; i--) { const ball = this.balls[i]; ball.inflateProgress += ball.inflateSpeed * 0.0006; const tR = ball.baseRadius + ball.inflateProgress*(ball.maxRadius - ball.baseRadius); ball.radius = Math.min(tR, ball.maxRadius); ball.vx *= 0.85; ball.vy *= 0.85; ball.x += ball.vx; ball.y += ball.vy; if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx = 0; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx = 0; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy = 0; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy = 0; } } for (let iter = 0; iter < 6; iter++) { for (let i = 0; i < this.balls.length; i++) { let totalDx = 0, totalDy = 0; for (let j = 0; j < this.balls.length; j++) { if (i === j) continue; const b1 = this.balls[i], b2 = this.balls[j], dx = b1.x - b2.x, dy = b1.y - b2.y, dist = Math.sqrt(dx*dx + dy*dy), minDist = b1.radius + b2.radius; if (dist < minDist && dist > 0) { const overlap = minDist - dist, pushF = overlap*0.15; totalDx += (dx/dist)*pushF; totalDy += (dy/dist)*pushF; } } const maxMove = 3, moveDist = Math.sqrt(totalDx*totalDx + totalDy*totalDy); if (moveDist > maxMove) { totalDx = (totalDx/moveDist)*maxMove; totalDy = (totalDy/moveDist)*maxMove; } this.balls[i].x += totalDx; this.balls[i].y += totalDy; } } this.balls.forEach(function(ball) { if (ball.x - ball.radius < 0) ball.x = ball.radius; if (ball.x + ball.radius > canvas.width) ball.x = canvas.width - ball.radius; if (ball.y - ball.radius < 0) ball.y = ball.radius; if (ball.y + ball.radius > canvas.height) ball.y = canvas.height - ball.radius; }); for (let i = this.balls.length - 1; i >= 0; i--) { const ball = this.balls[i]; if (ball.radius >= ball.maxRadius*0.5) { let severeOverlap = false; for (let j = 0; j < this.balls.length; j++) { if (i === j) continue; const b2 = this.balls[j], dist = Physics.distance(ball.x, ball.y, b2.x, b2.y); if (dist < (ball.radius + b2.radius)*0.9) { severeOverlap = true; break; } } if (ball.x < ball.radius*0.5 || ball.x > canvas.width - ball.radius*0.5 || ball.y < ball.radius*0.5 || ball.y > canvas.height - ball.radius*0.5) severeOverlap = true; if (severeOverlap) self.popBall(ball); } } } popBall(ball) { this.particles.addBurst(ball.x, ball.y, 12, { speed: 4, speedVariance: 5, life: 45, size: 20, sizeVariance: 15, gravity: 0.12, type: "star" }); this.state.popEffects.push({ x: ball.x, y: ball.y, radius: ball.radius, ballImage: ball.ballImage, progress: 0, rotation: 0, spinSpeed: (Math.random()-0.5)*0.5 }); ball.radius = ball.baseRadius; ball.inflateProgress = 0; ball.x = 100 + Math.random()*(canvas.width-200); ball.y = 100 + Math.random()*(canvas.height-200); ScreenShake.add(8); } draw() { super.draw(); const self = this; this.state.popEffects.forEach(function(e) { const img = Assets.getBallImage(e.ballImage); if (Assets.isImageReady(img)) { ctx.save(); ctx.globalAlpha = (1 - e.progress)*0.8; ctx.translate(e.x, e.y); ctx.rotate(e.rotation*3); const scale = 1 + e.progress*2; ctx.scale(scale, scale*(1 - e.progress*0.5)); ctx.drawImage(img, -e.radius/2, -e.radius/2, e.radius, e.radius); ctx.restore(); } }); this.balls.forEach(function(ball) { const pr = ball.radius/ball.maxRadius, wobble = pr > 0.8 ? Math.sin(Date.now()*0.02)*(pr - 0.8)*10 : 0; ctx.save(); ctx.translate(ball.x, ball.y); ctx.scale(1 + wobble*0.02, 1 - wobble*0.02); ctx.translate(-ball.x, -ball.y); Renderer.drawBall(ball); ctx.restore(); }); } onPointerDown(x, y) { const self = this; for (let i = this.balls.length - 1; i >= 0; i--) { if (Physics.contains(this.balls[i], x, y)) { this.popBall(this.balls[i]); break; } } } }

// GAME 14: BRUSH (IMPROVED - longer lines, smoother curves)
class BrushGame extends BaseGame { init() { super.init(); this.state = { paths: [], drawing: false, currentPath: [] }; for (let i = 0; i < 20; i++) this.balls.push(this.createBall({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, vx: (Math.random()-0.5)*0.1, vy: (Math.random()-0.5)*0.1, radius: 20 + Math.random()*15, followingPath: null, pathProgress: 0, pathDirection: 1, driftAngle: Math.random()*Math.PI*2, pathSpeed: 0.003 + Math.random()*0.001, speedPhase: Math.random()*Math.PI*2 })); } update() { super.update(); const self = this; this.state.paths = this.state.paths.filter(function(path) { return Date.now() - path.created < 12000; }); this.balls.forEach(function(ball) { if (ball.followingPath && ball.followingPath.points) { const path = ball.followingPath; if (!self.state.paths.includes(path)) { ball.followingPath = null; ball.pathProgress = 0; return; } ball.speedPhase += 0.05; const oscillation = Math.sin(ball.speedPhase)*0.003, totalPoints = path.isLoop ? path.points.length : path.points.length - 1; const dynamicSpeed = ball.pathSpeed + oscillation; ball.pathProgress += dynamicSpeed*ball.pathDirection; if (path.isLoop) { if (ball.pathProgress >= 1) ball.pathProgress -= 1; else if (ball.pathProgress < 0) ball.pathProgress += 1; } else { if (ball.pathProgress >= 1) { ball.pathProgress = 1; ball.pathDirection = -1; } else if (ball.pathProgress <= 0) { ball.pathProgress = 0; ball.pathDirection = 1; } } const idx = Math.floor(ball.pathProgress*totalPoints), clampedIdx = Math.max(0, Math.min(path.points.length - 1, idx)); const nextIdx = path.isLoop ? (clampedIdx + 1) % path.points.length : Math.min(clampedIdx + 1, path.points.length - 1); const t = ball.pathProgress*totalPoints - idx; ball.x = path.points[clampedIdx].x + (path.points[nextIdx].x - path.points[clampedIdx].x)*t; ball.y = path.points[clampedIdx].y + (path.points[nextIdx].y - path.points[clampedIdx].y)*t; ball.rotation += (ball.pathDirection > 0 ? 1 : -1)*dynamicSpeed*8; } else { for (let p = 0; p < self.state.paths.length; p++) { const path = self.state.paths[p]; if (path.points.length < 2) continue; for (let i = 0; i < path.points.length; i++) { const pt = path.points[i], dist = Physics.distance(ball.x, ball.y, pt.x, pt.y); if (dist < ball.radius + 20) { ball.followingPath = path; ball.pathProgress = i / (path.points.length - 1); ball.pathDirection = 1; ball.speedPhase = Math.random()*Math.PI*2; break; } } if (ball.followingPath) break; } if (!ball.followingPath) { ball.driftAngle += (Math.random() - 0.5)*0.02; ball.vx += Math.cos(ball.driftAngle)*0.003; ball.vy += Math.sin(ball.driftAngle)*0.003; const speed = Physics.getSpeed(ball); if (speed > 0.2) { ball.vx *= 0.2/speed; ball.vy *= 0.2/speed; } ball.rotation += 0.002; } ball.vx *= 0.99; ball.vy *= 0.99; ball.x += ball.vx; ball.y += ball.vy; Physics.capSpeed(ball); if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx *= -0.8; ball.driftAngle = Math.PI - ball.driftAngle; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius; ball.vx *= -0.8; ball.driftAngle = Math.PI - ball.driftAngle; } if (ball.y - ball.radius < 0) { ball.y = ball.radius; ball.vy *= -0.8; ball.driftAngle = -ball.driftAngle; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy *= -0.8; ball.driftAngle = -ball.driftAngle; } } }); Physics.handleBallCollisions(this.balls); } catmullRomPoint(p0, p1, p2, p3, t) { const t2 = t*t, t3 = t2*t; return { x: 0.5*((2*p1.x) + (-p0.x + p2.x)*t + (2*p0.x - 5*p1.x + 4*p2.x - p3.x)*t2 + (-p0.x + 3*p1.x - 3*p2.x + p3.x)*t3), y: 0.5*((2*p1.y) + (-p0.y + p2.y)*t + (2*p0.y - 5*p1.y + 4*p2.y - p3.y)*t2 + (-p0.y + 3*p1.y - 3*p2.y + p3.y)*t3) }; } drawSmoothPath(points, opacity) { if (points.length < 2) return; ctx.save(); ctx.strokeStyle = "rgba(100, 180, 255, "+(opacity*0.6)+")"; ctx.lineWidth = 8; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y); if (points.length === 2) { ctx.lineTo(points[1].x, points[1].y); } else { for (let i = 0; i < points.length - 1; i++) { const p0 = points[Math.max(0, i - 1)], p1 = points[i], p2 = points[Math.min(points.length - 1, i + 1)], p3 = points[Math.min(points.length - 1, i + 2)]; const segments = 10; for (let j = 1; j <= segments; j++) { const t = j/segments, pt = this.catmullRomPoint(p0, p1, p2, p3, t); ctx.lineTo(pt.x, pt.y); } } } ctx.stroke(); ctx.restore(); } draw() { const self = this; this.state.paths.forEach(function(path) { if (path.points.length < 2) return; const age = Date.now() - path.created, op = Math.max(0, 1 - age/12000); self.drawSmoothPath(path.points, op); }); if (this.state.drawing && this.state.currentPath.length > 1) { ctx.save(); ctx.globalAlpha = 0.7; this.drawSmoothPath(this.state.currentPath, 1.5); ctx.restore(); } this.balls.forEach(function(ball) { Renderer.drawBall(ball, 1, ball.rotation); }); super.draw(); } onPointerDown(x, y) { this.state.drawing = true; this.state.currentPath = [{ x:x, y:y }]; } onPointerMove(x, y) { if (this.state.drawing) { const lastPt = this.state.currentPath[this.state.currentPath.length - 1]; if (Math.abs(x - lastPt.x) > 5 || Math.abs(y - lastPt.y) > 5) this.state.currentPath.push({ x:x, y:y }); } } onPointerUp() { if (this.state.drawing && this.state.currentPath.length > 3) { const startPt = this.state.currentPath[0], endPt = this.state.currentPath[this.state.currentPath.length - 1]; const dist = Physics.distance(startPt.x, startPt.y, endPt.x, endPt.y), isLoop = dist < 50; this.state.paths.push({ points: this.state.currentPath.slice(), created: Date.now(), isLoop: isLoop }); } this.state.drawing = false; this.state.currentPath = []; } }

// GAME 15: PORTALS
class PortalsGame extends BaseGame { init() { super.init(); const safeZoneRadius = Config.isMobile ? 100 : 150; this.state = { portals: [], safeZone: { x: canvas.width/2, y: canvas.height/2, radius: safeZoneRadius, jumpTimer: 0, jumpInterval: 900, minJumpInterval: 300, speedUpRate: 0.98 }, spawnTimer: 0, spawnInterval: 300 }; for (let i = 0; i < 6; i++) this.spawnBall(); } spawnBall() { const padding = 50, baseRadius = Config.isMobile ? 18 : 25, radiusVariance = Config.isMobile ? 10 : 15; this.balls.push(this.createBall({ x: padding + Math.random()*(canvas.width - padding*2), y: padding + Math.random()*(canvas.height - padding*2), vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, radius: baseRadius + Math.random()*radiusVariance, portalCooldown: 0, grayscale: 0, scale: 1 })); } isInSafeZone(ball) { const sz = this.state.safeZone; return Physics.distance(ball.x, ball.y, sz.x, sz.y) < sz.radius - ball.radius; } isPointInSafeZone(x, y) { const sz = this.state.safeZone; return Physics.distance(x, y, sz.x, sz.y) < sz.radius; } update() { super.update(); const s = this.state, sz = s.safeZone, self = this; sz.jumpTimer++; if (sz.jumpTimer >= sz.jumpInterval) { sz.jumpTimer = 0; const padding = sz.radius + 50; sz.x = padding + Math.random()*(canvas.width - padding*2); sz.y = padding + Math.random()*(canvas.height - padding*2); ScreenShake.add(8); sz.jumpInterval = Math.max(sz.minJumpInterval, sz.jumpInterval*sz.speedUpRate); } s.spawnTimer++; if (s.spawnTimer >= s.spawnInterval && this.balls.length < 10) { this.spawnBall(); s.spawnTimer = 0; } for (let i = this.balls.length - 1; i >= 0; i--) { const ball = this.balls[i], inZone = this.isInSafeZone(ball); ball.vx *= 0.99; ball.vy *= 0.99; const speed = Physics.getSpeed(ball); if (speed < 0.5) { const a = Math.atan2(ball.vy, ball.vx); ball.vx = Math.cos(a)*1; ball.vy = Math.sin(a)*1; } ball.x += ball.vx; ball.y += ball.vy; Physics.capSpeed(ball); if (inZone) { const dx = ball.x - sz.x, dy = ball.y - sz.y, dist = Math.sqrt(dx*dx + dy*dy), maxDist = sz.radius - ball.radius - 5; if (dist > maxDist) { const nx = dx/dist, ny = dy/dist; ball.x = sz.x + nx*maxDist; ball.y = sz.y + ny*maxDist; const dot = ball.vx*nx + ball.vy*ny; ball.vx -= 2*dot*nx; ball.vy -= 2*dot*ny; ball.vx *= 0.8; ball.vy *= 0.8; } } Physics.handleWallCollision(ball, canvas, 0.9, false); if (ball.portalCooldown > 0) ball.portalCooldown--; if (inZone) { ball.grayscale = Math.max(0, ball.grayscale - 0.05); ball.scale = Math.min(1, ball.scale + 0.03); } else { ball.grayscale = Math.min(1, ball.grayscale + 0.0015); ball.scale = Math.max(0, ball.scale - 0.0008); } if (ball.scale <= 0.1 && ball.grayscale >= 0.95) { this.balls.splice(i, 1); continue; } s.portals.forEach(function(portal) { if (!portal.exit) return; const dist = Physics.distance(ball.x, ball.y, portal.entrance.x, portal.entrance.y); if (dist < 45 && ball.portalCooldown === 0) { ball.x = portal.exit.x; ball.y = portal.exit.y; ball.portalCooldown = 60; ScreenShake.add(3); } }); } Physics.handleBallCollisions(this.balls); } draw() { const s = this.state, sz = s.safeZone, time = Date.now()*0.002, self = this; const warningTime = 120, timeUntilJump = sz.jumpInterval - sz.jumpTimer, isWarning = timeUntilJump < warningTime, warningIntensity = isWarning ? 1 - timeUntilJump/warningTime : 0; const grad = ctx.createRadialGradient(sz.x, sz.y, 0, sz.x, sz.y, sz.radius); if (isWarning) { const flash = Math.sin(time*10*(1 + warningIntensity))*0.5 + 0.5, r = 255, g = Math.floor(215 - warningIntensity*150), b = Math.floor(warningIntensity*100*flash); grad.addColorStop(0, "rgba("+r+", "+g+", "+b+", "+(0.3 + warningIntensity*0.2)+")"); grad.addColorStop(0.7, "rgba("+r+", "+g+", "+b+", 0.15)"); grad.addColorStop(1, "rgba("+r+", "+g+", "+b+", 0.05)"); } else { grad.addColorStop(0, "rgba(255, 215, 0, 0.3)"); grad.addColorStop(0.7, "rgba(255, 215, 0, 0.15)"); grad.addColorStop(1, "rgba(255, 215, 0, 0.05)"); } ctx.beginPath(); ctx.arc(sz.x, sz.y, sz.radius, 0, Math.PI*2); ctx.fillStyle = grad; ctx.fill(); ctx.strokeStyle = isWarning ? "rgba(255, "+(150 - warningIntensity*100)+", 0, "+(0.6 + warningIntensity*0.4)+")" : "rgba(255, 200, 0, 0.6)"; ctx.lineWidth = isWarning ? 4 + warningIntensity*4 : 4; ctx.stroke(); const pulse = 1 + Math.sin(time*2)*0.05; ctx.beginPath(); ctx.arc(sz.x, sz.y, sz.radius*0.8*pulse, 0, Math.PI*2); ctx.strokeStyle = isWarning ? "rgba(255, "+(200 - warningIntensity*150)+", 100, "+(0.2 + warningIntensity*0.3)+")" : "rgba(255, 220, 100, 0.2)"; ctx.lineWidth = 2; ctx.stroke(); s.portals.forEach(function(portal) { const ent = portal.entrance, portalPulse = 1 + Math.sin(time)*0.1, size = 70*portalPulse; const entranceGrad = Renderer.createRadialGradient(ent.x, ent.y, 0, size, [[0, "rgba(255, 150, 100, 0.4)"], [1, "rgba(255, 150, 100, 0)"]]); ctx.beginPath(); ctx.arc(ent.x, ent.y, size, 0, Math.PI*2); ctx.fillStyle = entranceGrad; ctx.fill(); Renderer.drawImage(Assets.stars[1] || Assets.stars[0], ent.x - size/2, ent.y - size/2, size, size, 1, time*0.5); if (portal.exit) { const exit = portal.exit, exitGrad = Renderer.createRadialGradient(exit.x, exit.y, 0, size, [[0, "rgba(255, 215, 0, 0.4)"], [1, "rgba(255, 215, 0, 0)"]]); ctx.beginPath(); ctx.arc(exit.x, exit.y, size, 0, Math.PI*2); ctx.fillStyle = exitGrad; ctx.fill(); Renderer.drawImage(Assets.stars[0], exit.x - size/2, exit.y - size/2, size, size, 1, -time*0.5); ctx.beginPath(); ctx.moveTo(ent.x, ent.y); ctx.lineTo(exit.x, exit.y); ctx.strokeStyle = "rgba(255, 200, 100, 0.2)"; ctx.lineWidth = 2; ctx.setLineDash([10, 10]); ctx.stroke(); ctx.setLineDash([]); } }); this.balls.forEach(function(ball) { const inZone = self.isInSafeZone(ball); ctx.save(); if (ball.grayscale > 0) ctx.filter = "grayscale("+(ball.grayscale*100)+"%) brightness("+(1 - ball.grayscale*0.3)+")"; ctx.globalAlpha = Math.max(0.1, ball.scale); ctx.translate(ball.x, ball.y); ctx.scale(ball.scale, ball.scale); ctx.translate(-ball.x, -ball.y); Renderer.drawBall(ball, inZone ? 1.0 : 0.7); ctx.filter = "none"; ctx.globalAlpha = 1; ctx.restore(); }); super.draw(); } onPointerDown(x, y) { const s = this.state, inZone = this.isPointInSafeZone(x, y); const tooClose = this.balls.some(function(ball) { return Physics.distance(x, y, ball.x, ball.y) < ball.radius + 20; }); if (!inZone) { if (tooClose) return; s.portals = []; s.portals.push({ entrance: { x:x, y:y }, exit: null }); } else { const lastP = s.portals[s.portals.length - 1]; if (lastP && !lastP.exit) lastP.exit = { x:x, y:y }; } } }

// GAME 16: WHEELBALL (IMPROVED - repositioned wheels)
class WheelballGame extends BaseGame { init() { super.init(); this.state = { wheels: [], voids: [], stars: [], gravity: 0.12, score: 0, highScore: 0, spawnTimer: 0, activeWheel: null }; this.createWheels(); this.createVoids(); this.createStars(); } createWheels() { const configs = [{ x: 0.12, y: 0.15, baseSize: 50, spinDir: 1 }, { x: 0.88, y: 0.15, baseSize: 50, spinDir: -1 }, { x: 0.25, y: 0.4, baseSize: 45, spinDir: -1 }, { x: 0.75, y: 0.4, baseSize: 45, spinDir: 1 }, { x: 0.18, y: 0.78, baseSize: 55, spinDir: 1 }, { x: 0.5, y: 0.75, baseSize: 55, spinDir: -1 }, { x: 0.82, y: 0.78, baseSize: 55, spinDir: 1 }, { x: 0.5, y: 0.5, baseSize: 48, spinDir: 1 }]; const self = this; configs.forEach(function(cfg) { self.state.wheels.push({ x: canvas.width*cfg.x, y: canvas.height*cfg.y, baseSize: cfg.baseSize, size: cfg.baseSize, maxSize: cfg.baseSize*2.2, rotation: Math.random()*Math.PI*2, spinDir: cfg.spinDir, spinSpeed: 0.015*cfg.spinDir, ballImage: ImageCounter.nextBall(), vx: (Math.random()-0.5)*0.2, vy: (Math.random()-0.5)*0.2, baseX: cfg.x, baseY: cfg.y, hitFlash: 0, isHeld: false }); }); } createVoids() { const positions = [{ x: 0.06, y: 0.08, r: 35 }, { x: 0.94, y: 0.08, r: 35 }, { x: 0.1, y: 0.92, r: 40 }, { x: 0.5, y: 0.94, r: 35 }, { x: 0.9, y: 0.92, r: 40 }]; const self = this; positions.forEach(function(v) { self.state.voids.push({ x: canvas.width*v.x, y: canvas.height*v.y, radius: v.r, pulsePhase: Math.random()*Math.PI*2 }); }); } createStars() { const positions = [{ x: 0.35, y: 0.15 }, { x: 0.65, y: 0.15 }, { x: 0.18, y: 0.35 }, { x: 0.82, y: 0.35 }, { x: 0.35, y: 0.5 }, { x: 0.65, y: 0.5 }, { x: 0.3, y: 0.8 }, { x: 0.7, y: 0.8 }]; const self = this; positions.forEach(function(pos) { self.state.stars.push({ x: canvas.width*pos.x, y: canvas.height*pos.y, radius: 26, starType: Math.floor(Math.random()*3), pulse: Math.random()*Math.PI*2, collected: false, respawnTimer: 0 }); }); } collideBallWithWheel(ball, wheel) { const dx = ball.x - wheel.x, dy = ball.y - wheel.y, dist = Math.sqrt(dx*dx + dy*dy), collisionDist = ball.radius + wheel.size*0.55; if (dist < collisionDist && dist > 0) { const nx = dx/dist, ny = dy/dist; ball.x = wheel.x + nx*(collisionDist + 2); ball.y = wheel.y + ny*(collisionDist + 2); const tangentX = -ny*wheel.spinDir, tangentY = nx*wheel.spinDir, sizeRatio = wheel.size/wheel.baseSize, spinPower = Math.abs(wheel.spinSpeed)*300*sizeRatio, basePush = 6 + sizeRatio*4; ball.vx = nx*basePush + tangentX*spinPower; ball.vy = ny*basePush + tangentY*spinPower; wheel.hitFlash = 1; const points = Math.round(5 + (sizeRatio - 1)*15); this.state.score += points; this.particles.add({ x: wheel.x, y: wheel.y - wheel.size*0.7, vx: (Math.random()-0.5)*2, vy: -2.5, life: sizeRatio > 1.5 ? 75 : 50, maxLife: sizeRatio > 1.5 ? 75 : 50, type: "score", text: "+"+points, big: sizeRatio > 1.5 }); ScreenShake.add(2 + sizeRatio*2); Physics.capSpeed(ball); return true; } return false; } update() { super.update(); const s = this.state, self = this; if (this.balls.length === 0) { s.spawnTimer++; if (s.spawnTimer > 50) { const ballRadius = Config.isMobile ? 24 : 32; this.balls.push(this.createBall({ x: canvas.width/2 + (Math.random()-0.5)*120, y: canvas.height*0.12, vx: (Math.random()-0.5)*4, vy: 2, radius: ballRadius })); s.spawnTimer = 0; } } s.wheels.forEach(function(wheel) { if (wheel.isHeld) { wheel.size = Math.min(wheel.maxSize, wheel.size + 5); wheel.spinSpeed = 0.08*wheel.spinDir; } else { wheel.size = Math.max(wheel.baseSize, wheel.size - 0.8); wheel.spinSpeed += (0.015*wheel.spinDir - wheel.spinSpeed)*0.05; } wheel.rotation += wheel.spinSpeed; if (wheel.hitFlash > 0) wheel.hitFlash -= 0.06; wheel.x += wheel.vx; wheel.y += wheel.vy; const margin = wheel.maxSize*0.8; if (wheel.x < margin) { wheel.x = margin; wheel.vx = Math.abs(wheel.vx); } if (wheel.x > canvas.width - margin) { wheel.x = canvas.width - margin; wheel.vx = -Math.abs(wheel.vx); } if (wheel.y < margin) { wheel.y = margin; wheel.vy = Math.abs(wheel.vy); } if (wheel.y > canvas.height - margin) { wheel.y = canvas.height - margin; wheel.vy = -Math.abs(wheel.vy); } if (Math.random() < 0.01) { wheel.vx += (Math.random()-0.5)*0.06; wheel.vy += (Math.random()-0.5)*0.06; wheel.vx = Math.max(-0.3, Math.min(0.3, wheel.vx)); wheel.vy = Math.max(-0.3, Math.min(0.3, wheel.vy)); } }); s.voids.forEach(function(v) { v.pulsePhase += 0.04; }); s.stars.forEach(function(star) { star.pulse += 0.07; if (star.collected) { star.respawnTimer--; if (star.respawnTimer <= 0) { star.collected = false; star.starType = Math.floor(Math.random()*3); } } }); for (let i = this.balls.length - 1; i >= 0; i--) { const ball = this.balls[i]; ball.vy += s.gravity; const speed = Physics.getSpeed(ball), substeps = Math.max(1, Math.ceil(speed/12)); for (let sub = 0; sub < substeps; sub++) { ball.x += ball.vx/substeps; ball.y += ball.vy/substeps; s.wheels.forEach(function(wheel) { self.collideBallWithWheel(ball, wheel); }); } ball.vx *= 0.997; ball.vy *= 0.997; Physics.capSpeed(ball); const wallBounce = 0.65, wallPush = 1.5; if (ball.x - ball.radius < 0) { ball.x = ball.radius + 1; ball.vx = Math.abs(ball.vx)*wallBounce + wallPush; } if (ball.x + ball.radius > canvas.width) { ball.x = canvas.width - ball.radius - 1; ball.vx = -Math.abs(ball.vx)*wallBounce - wallPush; } if (ball.y - ball.radius < 0) { ball.y = ball.radius + 1; ball.vy = Math.abs(ball.vy)*wallBounce + wallPush; } if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius - 1; ball.vy = -Math.abs(ball.vy)*wallBounce - wallPush; } s.stars.forEach(function(star) { if (star.collected) return; const dist = Physics.distance(ball.x, ball.y, star.x, star.y); if (dist < ball.radius + star.radius) { star.collected = true; star.respawnTimer = 150; s.score += 50; self.particles.add({ x: star.x, y: star.y - 30, vx: (Math.random()-0.5)*2, vy: -2.5, life: 75, maxLife: 75, type: "score", text: "+50", big: true }); self.particles.addBurst(star.x, star.y, 12, { speed: 5, speedVariance: 6, life: 50, size: 18, sizeVariance: 22, gravity: 0.12, type: "star" }); ScreenShake.add(6); } }); for (let v = 0; v < s.voids.length; v++) { const vd = s.voids[v], dist = Physics.distance(ball.x, ball.y, vd.x, vd.y), pulseRadius = vd.radius + Math.sin(vd.pulsePhase)*4; if (dist < pulseRadius + ball.radius*0.4) { this.balls.splice(i, 1); if (s.score > s.highScore) s.highScore = s.score; s.score = 0; ScreenShake.add(12); break; } if (dist < pulseRadius*2.5 && dist > 0) { const suctionStrength = 0.6*(1 - dist/(pulseRadius*2.5)); ball.vx -= ((ball.x - vd.x)/dist)*suctionStrength; ball.vy -= ((ball.y - vd.y)/dist)*suctionStrength; } } } } draw() { const s = this.state; ctx.fillStyle = "#FAFAFA"; ctx.fillRect(0, 0, canvas.width, canvas.height); s.voids.forEach(function(v) { const pulseRadius = v.radius + Math.sin(v.pulsePhase)*4; ctx.strokeStyle = "rgba(0, 0, 0, 0.15)"; ctx.lineWidth = 1; ctx.setLineDash([4, 8]); ctx.beginPath(); ctx.arc(v.x, v.y, pulseRadius*2, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle = "#111"; ctx.beginPath(); ctx.arc(v.x, v.y, pulseRadius, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = "rgba(255, 255, 255, 0.3)"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(v.x, v.y, pulseRadius*0.4, 0, Math.PI*2); ctx.stroke(); }); s.stars.forEach(function(star) { if (star.collected) return; const pulseScale = 1 + Math.sin(star.pulse)*0.15, size = star.radius*2*pulseScale; const glow = Renderer.createRadialGradient(star.x, star.y, 0, size, [[0, "rgba(255, 220, 100, 0.3)"], [1, "rgba(255, 220, 100, 0)"]]); ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(star.x, star.y, size, 0, Math.PI*2); ctx.fill(); const img = Assets.getStarImage(star.starType); if (Assets.isImageReady(img)) { ctx.save(); ctx.translate(star.x, star.y); ctx.rotate(star.pulse*0.15); ctx.drawImage(img, -size/2, -size/2, size, size); ctx.restore(); } }); s.wheels.forEach(function(wheel) { const sizeRatio = wheel.size/wheel.baseSize; ctx.save(); ctx.translate(wheel.x, wheel.y); ctx.strokeStyle = wheel.isHeld ? "rgba(0, 0, 0, 0.7)" : "rgba(0, 0, 0, 0.3)"; ctx.lineWidth = 2 + sizeRatio; ctx.beginPath(); ctx.arc(0, 0, wheel.size*0.55, 0, Math.PI*2); ctx.stroke(); if (wheel.hitFlash > 0) { ctx.strokeStyle = "rgba(0, 0, 0, "+(wheel.hitFlash*0.5)+")"; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(0, 0, wheel.size*0.65, 0, Math.PI*2); ctx.stroke(); } ctx.rotate(wheel.rotation); ctx.strokeStyle = wheel.isHeld ? "rgba(0, 0, 0, 0.5)" : "rgba(0, 0, 0, 0.25)"; ctx.lineWidth = 2 + sizeRatio; for (let i = 0; i < 4; i++) { const angle = (Math.PI*2*i)/4; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(Math.cos(angle)*wheel.size*0.5, Math.sin(angle)*wheel.size*0.5); ctx.stroke(); } ctx.restore(); const img = Assets.getBallImage(wheel.ballImage), hubSize = wheel.size*0.7; if (Assets.isImageReady(img)) ctx.drawImage(img, wheel.x - hubSize/2, wheel.y - hubSize/2, hubSize, hubSize); }); this.particles.draw(function(p, alpha) { if (p.type === "star" && p.starIndex !== undefined) { const img = Assets.getStarImage(p.starIndex); ctx.save(); ctx.globalAlpha = alpha; ctx.translate(p.x, p.y); ctx.rotate(p.rotation); if (Assets.isImageReady(img)) ctx.drawImage(img, -p.size/2, -p.size/2, p.size, p.size); ctx.restore(); } else if (p.type === "score") { const size = p.big ? 26 : 18; ctx.font = "bold "+size+"px monospace"; ctx.textAlign = "center"; ctx.fillStyle = p.big ? "rgba(200, 150, 0, "+alpha+")" : "rgba(0, 0, 0, "+(alpha*0.7)+")"; ctx.fillText(p.text, p.x, p.y); } else { ctx.fillStyle = "rgba(0, 0, 0, "+(alpha*0.6)+")"; ctx.beginPath(); ctx.arc(p.x, p.y, p.size*alpha, 0, Math.PI*2); ctx.fill(); } }); this.balls.forEach(function(ball) { Renderer.drawBall(ball); }); ctx.fillStyle = "rgba(0, 0, 0, 0.8)"; ctx.font = "bold 24px monospace"; ctx.textAlign = "right"; ctx.fillText(s.score+"", canvas.width - 20, 35); ctx.fillStyle = "rgba(0, 0, 0, 0.4)"; ctx.font = "14px monospace"; ctx.fillText("best "+s.highScore, canvas.width - 20, 55); ctx.fillStyle = "rgba(0, 0, 0, 0.25)"; ctx.font = "12px monospace"; ctx.textAlign = "center"; ctx.fillText("hold a wheel to grow it", canvas.width/2, canvas.height - 15); } onPointerDown(x, y) { const self = this; for (let i = 0; i < this.state.wheels.length; i++) { const wheel = this.state.wheels[i], dist = Physics.distance(x, y, wheel.x, wheel.y); if (dist < wheel.maxSize*0.8) { wheel.isHeld = true; wheel.size = wheel.maxSize; this.state.activeWheel = wheel; return; } } } onPointerUp() { this.state.wheels.forEach(function(w) { w.isHeld = false; }); this.state.activeWheel = null; } }

const GameManager = { games: { 1: { name: "Fling", class: FlingGame }, 2: { name: "Paddle", class: PaddleGame }, 3: { name: "Pop", class: PopGame }, 4: { name: "Vacuum", class: VacuumGame }, 5: { name: "Gravity", class: GravityFlipGame }, 6: { name: "Bounce", class: BounceGame }, 7: { name: "Magnet", class: MagnetZonesGame }, 8: { name: "Explode", class: ExplodeGame }, 9: { name: "Orbital", class: OrbitalGame }, 10: { name: "Defend", class: DefendGame }, 11: { name: "Connect", class: ConnectionsGame }, 12: { name: "Merge", class: MergeSplitGame }, 13: { name: "Inflate", class: InflateGame }, 14: { name: "Brush", class: BrushGame }, 15: { name: "Portals", class: PortalsGame }, 16: { name: "Wheelball", class: WheelballGame } }, currentGameNum: 1, currentGame: null, shiftPressed: false, init: function() { this.switchGame(1); }, switchGame: function(gameNum) { if (gameNum < 1 || gameNum > 16) return; this.currentGameNum = gameNum; ScreenShake.reset(); document.querySelectorAll(".nav-item").forEach(function(item) { item.classList.remove("active"); if (parseInt(item.dataset.game) === gameNum) item.classList.add("active"); }); const GameClass = this.games[gameNum].class; this.currentGame = new GameClass(); this.currentGame.init(); }, update: function() { if (this.currentGame) this.currentGame.update(); }, draw: function() { if (this.currentGame) this.currentGame.draw(); }, onPointerDown: function(x, y) { if (this.currentGame && this.currentGame.onPointerDown) this.currentGame.onPointerDown(x, y); }, onPointerMove: function(x, y) { if (this.currentGame && this.currentGame.onPointerMove) this.currentGame.onPointerMove(x, y); }, onPointerUp: function() { if (this.currentGame && this.currentGame.onPointerUp) this.currentGame.onPointerUp(); } };

const Input = { mouseX: 0, mouseY: 0, isMouseDown: false, init: function() { this.setupMouseEvents(); this.setupTouchEvents(); this.setupKeyboardEvents(); this.setupNavigation(); this.setupResize(); }, getPointer: function(e) { const touch = e.touches ? e.touches[0] : e; return { x: touch.clientX, y: touch.clientY }; }, setupMouseEvents: function() { const self = this; canvas.addEventListener("mousedown", function(e) { e.preventDefault(); self.isMouseDown = true; const p = self.getPointer(e); GameManager.onPointerDown(p.x, p.y); }); canvas.addEventListener("mousemove", function(e) { const p = self.getPointer(e); self.mouseX = p.x; self.mouseY = p.y; GameManager.onPointerMove(p.x, p.y); }); canvas.addEventListener("mouseup", function(e) { e.preventDefault(); self.isMouseDown = false; GameManager.onPointerUp(); }); canvas.addEventListener("mouseleave", function() { if (self.isMouseDown) GameManager.onPointerUp(); }); window.addEventListener("mouseup", function() { if (self.isMouseDown) { self.isMouseDown = false; GameManager.onPointerUp(); } }); window.addEventListener("blur", function() { if (self.isMouseDown) { self.isMouseDown = false; GameManager.onPointerUp(); } }); }, setupTouchEvents: function() { const self = this; canvas.addEventListener("touchstart", function(e) { e.preventDefault(); const p = self.getPointer(e); GameManager.onPointerDown(p.x, p.y); }); canvas.addEventListener("touchmove", function(e) { e.preventDefault(); const p = self.getPointer(e); self.mouseX = p.x; self.mouseY = p.y; GameManager.onPointerMove(p.x, p.y); }); canvas.addEventListener("touchend", function(e) { e.preventDefault(); GameManager.onPointerUp(); }); }, setupKeyboardEvents: function() { document.addEventListener("keydown", function(e) { const num = parseInt(e.key); if (num >= 1 && num <= 9) GameManager.switchGame(num); if (e.key === "0") GameManager.switchGame(10); if (e.key === "Shift") { GameManager.shiftPressed = true; if (GameManager.currentGame && GameManager.currentGame.state && GameManager.currentGame.state.shiftPressed !== undefined) GameManager.currentGame.state.shiftPressed = true; } }); document.addEventListener("keyup", function(e) { if (e.key === "Shift") { GameManager.shiftPressed = false; if (GameManager.currentGame && GameManager.currentGame.state && GameManager.currentGame.state.shiftPressed !== undefined) GameManager.currentGame.state.shiftPressed = false; } }); }, setupNavigation: function() { document.querySelectorAll(".nav-item").forEach(function(item) { item.addEventListener("click", function() { GameManager.switchGame(parseInt(item.dataset.game)); }); }); }, setupResize: function() { window.addEventListener("resize", function() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }); } };

function animate() { ScreenShake.update(); ctx.save(); ctx.translate(ScreenShake.x, ScreenShake.y); ctx.clearRect(-10, -10, canvas.width + 20, canvas.height + 20); GameManager.update(); GameManager.draw(); ctx.restore(); requestAnimationFrame(animate); }

Assets.load(); Input.init(); GameManager.init(); animate();
    </script>
  </body>
</html>