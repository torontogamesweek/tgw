<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Toronto Games Week - Interactive Background Tests</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        overflow: hidden;
        background: #f0f0f0;
        touch-action: none;
        font-family: "Courier New", Courier, monospace, sans-serif;
      }
      canvas {
        display: block;
        background: #fff;
      }
      #nav {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        background: rgba(255, 255, 255, 0.95);
        box-shadow: 0 2px 2px rgba(0, 0, 0, 0.1);
        z-index: 100;
      }
      .nav-item {
        padding: 8px 8px;
        text-align: center;
        cursor: pointer;
        border-right: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        font-size: 1rem;
        font-weight: 600;
        transition: all 0.2s;
        user-select: none;
        position: relative;
      }
      .nav-item:nth-child(4n) {
        border-right: none;
      }
      .nav-item:hover {
        background: rgba(0, 0, 0, 0.05);
      }
      .nav-item.active {
        background: rgba(0, 0, 0, 0.1);
        color: #000;
      }
      .nav-item .tooltip {
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: normal;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s;
        z-index: 200;
        margin-top: 5px;
      }
      .nav-item .tooltip::before {
        content: "";
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 6px solid transparent;
        border-bottom-color: rgba(0, 0, 0, 0.85);
      }
      .nav-item:hover .tooltip {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <div id="nav">
      <div class="nav-item" data-game="1">Fling<span class="tooltip">Collect gold but avoid catchers!</span></div>
      <div class="nav-item" data-game="2">Paddle<span class="tooltip">Keep the balls bouncing!</span></div>
      <div class="nav-item" data-game="3">Pop<span class="tooltip">Pop them all!</span></div>
      <div class="nav-item" data-game="4">Vacuum<span class="tooltip">Hold to vacuum, release to explode!</span></div>
      <div class="nav-item" data-game="5">Gravity Flip<span class="tooltip">Click to reverse gravity</span></div>
      <div class="nav-item" data-game="6">Bounce<span class="tooltip">Draw lines to bounce ball to heart!</span></div>
      <div class="nav-item" data-game="7">Magnet<span class="tooltip">Click = attract, SHIFT = repel</span></div>
      <div class="nav-item" data-game="8">Explode<span class="tooltip">Hold to charge, release to burst!</span></div>
      <div class="nav-item" data-game="9">Orbital<span class="tooltip">Click to release orbiting balls!</span></div>
      <div class="nav-item" data-game="10">Defend<span class="tooltip">Click balls to recruit guards!</span></div>
      <div class="nav-item" data-game="11">Connect<span class="tooltip">Connect people to balls!</span></div>
      <div class="nav-item" data-game="12">Merge<span class="tooltip">Unite all walkers!</span></div>
      <div class="nav-item" data-game="13">Inflate<span class="tooltip">Click balls to pop them</span></div>
      <div class="nav-item" data-game="14">Brush<span class="tooltip">Paint paths for balls</span></div>
      <div class="nav-item" data-game="15">Portals<span class="tooltip">Move balls to golden zone!</span></div>
      <div class="nav-item" data-game="16">Wheelball<span class="tooltip">Launch and spin!</span></div>
    </div>
    <canvas id="canvas"></canvas>
    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      let currentGame = 1,
        balls = [],
        gameState = {},
        mouseX = 0,
        mouseY = 0,
        isMouseDown = false;
      const MAX_SPEED = 25;
      let screenShake = { x: 0, y: 0, intensity: 0 };

      function capSpeed(ball) {
        const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
        if (speed > MAX_SPEED) {
          const scale = MAX_SPEED / speed;
          ball.vx *= scale;
          ball.vy *= scale;
        }
      }
      function addScreenShake(intensity) {
        screenShake.intensity = Math.min(Math.max(screenShake.intensity, intensity * 0.4), 8);
      }
      function updateScreenShake() {
        if (screenShake.intensity > 0) {
          screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
          screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
          screenShake.intensity *= 0.85;
          if (screenShake.intensity < 0.3) screenShake.intensity = 0;
        } else {
          screenShake.x = 0;
          screenShake.y = 0;
        }
      }

      const ballImages = [],
        peopleImages = [];
      const numBallImages = 29,
        numPeopleImages = 19;
      for (let i = 1; i <= numBallImages; i++) {
        const img = new Image();
        img.src = "balls/ball_" + i + ".png";
        ballImages.push(img);
      }
      for (let i = 1; i <= numPeopleImages; i++) {
        const img = new Image();
        img.src = "ppl/ppl_" + i + ".png";
        peopleImages.push(img);
      }

      const pointImg = new Image();
      pointImg.src = "special/point.png";
      const baddieImg = new Image();
      baddieImg.src = "special/baddie.png";
      const heartImg = new Image();
      heartImg.src = "particles/hot/heart.png";
      const koImg = new Image();
      koImg.src = "particles/hot/ko.png";
      const starImages = [];
      for (let i = 1; i <= 3; i++) {
        const img = new Image();
        img.src = "particles/stars/star_" + i + ".png";
        starImages.push(img);
      }

      function drawPerson(x, y, height, imageIndex, opacity = 1.0, rotation = 0) {
        const img = peopleImages[imageIndex % numPeopleImages];
        if (img && img.complete && img.naturalWidth > 0) {
          const aspectRatio = img.naturalWidth / img.naturalHeight,
            width = height * aspectRatio;
          ctx.save();
          ctx.globalAlpha = opacity;
          ctx.translate(x, y);
          ctx.rotate(rotation);
          ctx.drawImage(img, -width / 2, -height, width, height);
          ctx.restore();
        }
      }

      let ballImageCounter = 0,
        personImageCounter = 0;
      function getNextBallImage() {
        ballImageCounter = (ballImageCounter + 1) % numBallImages;
        return ballImageCounter + 1;
      }
      function getNextPersonImage() {
        const idx = personImageCounter;
        personImageCounter = (personImageCounter + 1) % numPeopleImages;
        return idx;
      }

      function safeDrawImage(img, x, y, w, h, opacity = 1, rotation = 0) {
        if (img && img.complete && img.naturalWidth > 0) {
          ctx.save();
          ctx.globalAlpha = opacity;
          ctx.translate(x + w / 2, y + h / 2);
          ctx.rotate(rotation);
          ctx.drawImage(img, -w / 2, -h / 2, w, h);
          ctx.restore();
          return true;
        }
        return false;
      }

      function drawBallWithSquash(ball, opacity = 1.0, rotation = 0, squashX = 1, squashY = 1) {
        const img = ballImages[ball.ballImage - 1];
        ctx.save();
        ctx.globalAlpha = opacity;
        ctx.translate(ball.x, ball.y);
        ctx.rotate(rotation);
        ctx.scale(squashX, squashY);
        if (img && img.complete && img.naturalWidth > 0) ctx.drawImage(img, -ball.radius, -ball.radius, ball.radius * 2, ball.radius * 2);
        else {
          ctx.beginPath();
          ctx.arc(0, 0, ball.radius, 0, Math.PI * 2);
          ctx.fillStyle = "#333";
          ctx.fill();
        }
        ctx.restore();
      }

      function drawBall(ball, opacity = 1.0, rotation = 0) {
        drawBallWithSquash(ball, opacity, rotation, 1, 1);
      }

      function drawStarburst(x, y, innerRadius, outerRadius, points, color) {
        ctx.beginPath();
        for (let i = 0; i < points * 2; i++) {
          const angle = ((Math.PI * 2) / (points * 2)) * i - Math.PI / 2;
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          if (i === 0) ctx.moveTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
          else ctx.lineTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
        }
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
      }

      const games = {
        1: {
          name: "Fling",
          init: initFling,
          update: updateFling,
          draw: drawFling,
          onPointerDown: flingPointerDown,
          onPointerMove: flingPointerMove,
          onPointerUp: flingPointerUp,
        },
        2: { name: "Paddle", init: initPaddle, update: updatePaddle, draw: drawPaddle, onPointerMove: paddlePointerMove },
        3: { name: "Pop", init: initPop, update: updatePop, draw: drawPop, onPointerDown: popPointerDown },
        4: {
          name: "Vacuum",
          init: initVacuum,
          update: updateVacuum,
          draw: drawVacuum,
          onPointerDown: vacuumPointerDown,
          onPointerMove: vacuumPointerMove,
          onPointerUp: vacuumPointerUp,
        },
        5: { name: "Gravity", init: initGravityFlip, update: updateGravityFlip, draw: drawGravityFlip, onPointerDown: gravityFlipPointerDown },
        6: {
          name: "Bounce",
          init: initBounce,
          update: updateBounce,
          draw: drawBounce,
          onPointerDown: bouncePointerDown,
          onPointerMove: bouncePointerMove,
          onPointerUp: bouncePointerUp,
        },
        7: { name: "Magnet", init: initMagnetZones, update: updateMagnetZones, draw: drawMagnetZones, onPointerDown: magnetPointerDown },
        8: {
          name: "Explode",
          init: initExplode,
          update: updateExplode,
          draw: drawExplode,
          onPointerDown: explodePointerDown,
          onPointerUp: explodePointerUp,
        },
        9: {
          name: "Orbital",
          init: initOrbital,
          update: updateOrbital,
          draw: drawOrbital,
          onPointerMove: orbitalPointerMove,
          onPointerDown: orbitalPointerDown,
        },
        10: { name: "Defend", init: initDefend, update: updateDefend, draw: drawDefend, onPointerDown: defendPointerDown },
        11: {
          name: "Connect",
          init: initConnections,
          update: updateConnections,
          draw: drawConnections,
          onPointerDown: connectionsPointerDown,
          onPointerMove: connectionsPointerMove,
        },
        12: { name: "Merge", init: initMergeSplit, update: updateMergeSplit, draw: drawMergeSplit, onPointerDown: mergeSplitPointerDown },
        13: { name: "Inflate", init: initInflate, update: updateInflate, draw: drawInflate, onPointerDown: inflatePointerDown },
        14: {
          name: "Brush",
          init: initBrush,
          update: updateBrush,
          draw: drawBrush,
          onPointerDown: brushPointerDown,
          onPointerMove: brushPointerMove,
          onPointerUp: brushPointerUp,
        },
        15: { name: "Portals", init: initPortals, update: updatePortals, draw: drawPortals, onPointerDown: portalPointerDown },
        16: {
          name: "Wheelball",
          init: initWheelball,
          update: updateWheelball,
          draw: drawWheelball,
          onPointerDown: WheelballPointerDown,
          onPointerUp: WheelballPointerUp,
        },
      };

      // GAME 1: FLING
      function initFling() {
        balls = [];
        gameState = { draggedBall: null, goldenOrbs: [], catchers: [], score: 0, lives: 5, particles: [], gameTime: 0, lastCatcherSpawn: 0 };
        spawnFlingBall();
        for (let i = 0; i < 3; i++)
          gameState.goldenOrbs.push({
            x: 150 + Math.random() * (canvas.width - 300),
            y: 200 + Math.random() * (canvas.height - 400),
            radius: 25,
            pulse: Math.random() * Math.PI * 2,
          });
        spawnCatcher();
        spawnCatcher();
      }

      function spawnFlingBall(animated = false) {
        const angle = Math.random() * Math.PI * 2;
        balls.push({
          x: canvas.width / 2 + (Math.random() - 0.5) * 200,
          y: canvas.height / 2 + (Math.random() - 0.5) * 200,
          vx: Math.cos(angle) * 0.5,
          vy: Math.sin(angle) * 0.5,
          radius: 30 + Math.random() * 20,
          isDragging: false,
          dragStartX: 0,
          dragStartY: 0,
          ballImage: getNextBallImage(),
          rotation: 0,
          trail: [],
          glowTimer: 0,
          dying: false,
          deathProgress: 0,
          deathType: "explode",
          spawnProgress: animated ? 0 : 1,
          squashX: 1,
          squashY: 1,
        });
      }

      function spawnCatcher() {
        let x, y;
        do {
          x = 100 + Math.random() * (canvas.width - 200);
          y = 100 + Math.random() * (canvas.height - 200);
        } while (Math.abs(x - canvas.width / 2) < 200 && Math.abs(y - canvas.height / 2) < 200);
        gameState.catchers.push({
          x,
          y,
          personIndex: getNextPersonImage(),
          radius: 35,
          spawnProgress: 0,
          pulsePhase: Math.random() * Math.PI * 2,
          rotationPhase: Math.random() * Math.PI * 2,
        });
      }

      function updateFling() {
        gameState.gameTime++;
        if (gameState.catchers.length < 12 && gameState.gameTime - gameState.lastCatcherSpawn > 1200) {
          spawnCatcher();
          gameState.lastCatcherSpawn = gameState.gameTime;
        }
        gameState.goldenOrbs.forEach((orb) => {
          orb.pulse += 0.1;
        });
        gameState.catchers.forEach((c) => {
          if (c.spawnProgress < 1) c.spawnProgress += 0.01;
          c.pulsePhase += 0.08;
          c.rotationPhase += 0.02;
        });
        gameState.particles = gameState.particles.filter((p) => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += p.gravity || 0;
          p.life--;
          p.rotation = (p.rotation || 0) + (p.spin || 0);
          return p.life > 0;
        });

        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          if (ball.spawnProgress < 1) {
            ball.spawnProgress += 0.05;
            ball.squashX = 0.3 + ball.spawnProgress * 0.7 + Math.sin(ball.spawnProgress * Math.PI) * 0.3;
            ball.squashY = 0.3 + ball.spawnProgress * 0.7 + Math.sin(ball.spawnProgress * Math.PI + Math.PI / 2) * 0.2;
            continue;
          }
          if (ball.dying) {
            ball.deathProgress += 0.06;
            ball.squashX = ball.deathType === "explode" ? 1 + ball.deathProgress * 1.5 : 1 + ball.deathProgress * 0.8;
            ball.squashY = ball.deathType === "explode" ? 1 - ball.deathProgress * 0.8 : 1 - ball.deathProgress * 0.9;
            if (ball.deathProgress >= 1) {
              balls.splice(i, 1);
              spawnFlingBall(true);
            }
            continue;
          }
          if (ball.isDragging) continue;
          if (ball.glowTimer > 0) ball.glowTimer--;
          ball.squashX += (1 - ball.squashX) * 0.15;
          ball.squashY += (1 - ball.squashY) * 0.15;
          const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
          if (speed < 0.3) {
            const a = Math.atan2(ball.vy, ball.vx);
            ball.vx = Math.cos(a) * 0.5;
            ball.vy = Math.sin(a) * 0.5;
          }
          ball.vx *= 0.995;
          ball.vy *= 0.995;
          ball.x += ball.vx;
          ball.y += ball.vy;
          capSpeed(ball);
          ball.rotation += speed * 0.05;
          if (speed > 3) ball.trail.push({ x: ball.x, y: ball.y, life: 20 });
          ball.trail = ball.trail.filter((p) => p.life-- > 0);

          if (speed > 4) {
            for (let j = gameState.goldenOrbs.length - 1; j >= 0; j--) {
              const orb = gameState.goldenOrbs[j],
                dx = ball.x - orb.x,
                dy = ball.y - orb.y;
              if (Math.sqrt(dx * dx + dy * dy) < ball.radius + orb.radius + 5) {
                ball.glowTimer = 60;
                gameState.score++;
                for (let k = 0; k < 8; k++) {
                  const a = ((Math.PI * 2) / 8) * k;
                  gameState.particles.push({
                    x: orb.x,
                    y: orb.y,
                    vx: Math.cos(a) * 4,
                    vy: Math.sin(a) * 4,
                    life: 30,
                    starImg: starImages[Math.floor(Math.random() * 3)],
                    size: 15 + Math.random() * 15,
                    rotation: Math.random() * Math.PI * 2,
                    spin: (Math.random() - 0.5) * 0.3,
                    gravity: 0.1,
                  });
                }
                orb.x = 150 + Math.random() * (canvas.width - 300);
                orb.y = 200 + Math.random() * (canvas.height - 400);
              }
            }
            gameState.catchers.forEach((catcher) => {
              if (catcher.spawnProgress < 0.8) return;
              const dx = ball.x - catcher.x,
                dy = ball.y - catcher.y;
              if (Math.sqrt(dx * dx + dy * dy) < ball.radius + catcher.radius && !ball.dying) {
                ball.dying = true;
                ball.deathProgress = 0;
                ball.deathType = Math.random() > 0.5 ? "explode" : "squish";
                gameState.lives--;
                addScreenShake(10);
                for (let k = 0; k < 12; k++) {
                  const a = ((Math.PI * 2) / 12) * k;
                  gameState.particles.push({
                    x: ball.x,
                    y: ball.y,
                    vx: Math.cos(a) * (3 + Math.random() * 3),
                    vy: Math.sin(a) * (3 + Math.random() * 3),
                    life: 35,
                    ballImage: ball.ballImage,
                    radius: ball.radius * 0.2,
                    rotation: Math.random() * Math.PI * 2,
                    spin: (Math.random() - 0.5) * 0.3,
                    gravity: 0.15,
                  });
                }
              }
            });
          }
          // More bounce on walls
          if (ball.x - ball.radius < 0) {
            ball.x = ball.radius;
            ball.vx *= -0.95;
            ball.squashX = 0.7;
            ball.squashY = 1.2;
          }
          if (ball.x + ball.radius > canvas.width) {
            ball.x = canvas.width - ball.radius;
            ball.vx *= -0.95;
            ball.squashX = 0.7;
            ball.squashY = 1.2;
          }
          if (ball.y - ball.radius < 0) {
            ball.y = ball.radius;
            ball.vy *= -0.95;
            ball.squashX = 1.2;
            ball.squashY = 0.7;
          }
          if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius;
            ball.vy *= -0.95;
            ball.squashX = 1.2;
            ball.squashY = 0.7;
          }
        }
        ballCollisions();
      }

      function drawFling() {
        gameState.catchers.forEach((c) => {
          const op = Math.min(1, c.spawnProgress),
            scale = 0.5 + c.spawnProgress * 0.5;
          const spikeScale = 1 + Math.sin(c.pulsePhase) * 0.15;
          ctx.save();
          ctx.globalAlpha = op;
          ctx.translate(c.x, c.y);
          ctx.scale(scale, scale);
          ctx.save();
          ctx.rotate(c.rotationPhase);
          const spikeRadius = (c.radius + 18) * spikeScale;
          drawStarburst(0, 0, c.radius * 0.5, spikeRadius, 8, "rgba(255, 60, 60, 0.4)");
          ctx.restore();
          const dangerGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, c.radius * 1.2);
          dangerGrad.addColorStop(0, "rgba(255, 0, 0, 0.2)");
          dangerGrad.addColorStop(1, "rgba(255, 0, 0, 0)");
          ctx.beginPath();
          ctx.arc(0, 0, c.radius * 1.2, 0, Math.PI * 2);
          ctx.fillStyle = dangerGrad;
          ctx.fill();
          ctx.restore();
          drawPerson(c.x, c.y + 20 * scale, 50 * scale, c.personIndex, op);
        });
        gameState.goldenOrbs.forEach((orb) => {
          const ps = 1 + Math.sin(orb.pulse) * 0.2;
          const g = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, orb.radius * ps * 2);
          g.addColorStop(0, "rgba(255, 215, 0, 0.8)");
          g.addColorStop(0.5, "rgba(255, 180, 0, 0.3)");
          g.addColorStop(1, "rgba(255, 150, 0, 0)");
          ctx.beginPath();
          ctx.arc(orb.x, orb.y, orb.radius * ps * 2, 0, Math.PI * 2);
          ctx.fillStyle = g;
          ctx.fill();
          ctx.beginPath();
          ctx.arc(orb.x, orb.y, orb.radius * ps, 0, Math.PI * 2);
          ctx.fillStyle = "#FFD700";
          ctx.fill();
          ctx.strokeStyle = "rgba(255, 255, 200, 0.8)";
          ctx.lineWidth = 3;
          ctx.stroke();
        });
        gameState.particles.forEach((p) => {
          if (p.starImg) {
            safeDrawImage(p.starImg, p.x - p.size / 2, p.y - p.size / 2, p.size, p.size, p.life / 30, p.rotation);
          } else if (p.ballImage) {
            const img = ballImages[p.ballImage - 1];
            if (img && img.complete && img.naturalWidth > 0) {
              ctx.save();
              ctx.globalAlpha = p.life / 35;
              ctx.translate(p.x, p.y);
              ctx.rotate(p.rotation);
              ctx.drawImage(img, -p.radius, -p.radius, p.radius * 2, p.radius * 2);
              ctx.restore();
            }
          }
        });
        balls.forEach((ball) => {
          ball.trail.forEach((p) => {
            const a = p.life / 25;
            ctx.beginPath();
            ctx.arc(p.x, p.y, ball.radius * a * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = ball.glowTimer > 0 ? "rgba(255, 215, 0, " + a * 0.3 + ")" : "rgba(200, 150, 150, " + a * 0.2 + ")";
            ctx.fill();
          });
          if (ball.glowTimer > 0) {
            const g = ctx.createRadialGradient(ball.x, ball.y, ball.radius * 0.5, ball.x, ball.y, ball.radius * 1.8);
            g.addColorStop(0, "rgba(255, 215, 0, " + ball.glowTimer / 120 + ")");
            g.addColorStop(1, "rgba(255, 215, 0, 0)");
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius * 1.8, 0, Math.PI * 2);
            ctx.fillStyle = g;
            ctx.fill();
          }
          const op = ball.dying ? 1 - ball.deathProgress : ball.spawnProgress < 1 ? ball.spawnProgress : ball.isDragging ? 0.7 : 1.0;
          drawBallWithSquash(ball, op, ball.rotation, ball.squashX, ball.squashY);
          if (ball.isDragging) {
            ctx.beginPath();
            ctx.moveTo(ball.dragStartX, ball.dragStartY);
            ctx.lineTo(ball.x, ball.y);
            ctx.strokeStyle = "rgba(100, 100, 100, 0.5)";
            ctx.lineWidth = 3;
            ctx.stroke();
          }
        });
      }
      function flingPointerDown(x, y) {
        for (let i = balls.length - 1; i >= 0; i--) {
          if (contains(balls[i], x, y) && !balls[i].dying && balls[i].spawnProgress >= 1) {
            gameState.draggedBall = balls[i];
            balls[i].isDragging = true;
            balls[i].dragStartX = x;
            balls[i].dragStartY = y;
            break;
          }
        }
      }
      function flingPointerMove(x, y) {
        if (!gameState.draggedBall) return;
        const ball = gameState.draggedBall,
          pad = ball.radius + 10;
        ball.x = Math.max(pad, Math.min(canvas.width - pad, x));
        ball.y = Math.max(pad, Math.min(canvas.height - pad, y));
      }
      function flingPointerUp() {
        if (!gameState.draggedBall) return;
        const ball = gameState.draggedBall;
        ball.vx = (ball.dragStartX - ball.x) * 0.45;
        ball.vy = (ball.dragStartY - ball.y) * 0.45;
        capSpeed(ball);
        ball.isDragging = false;
        gameState.draggedBall = null;
      }

      // GAME 2: PADDLE - shorter squash, no energy bar
      function initPaddle() {
        balls = [];
        gameState = {
          mouseX: canvas.width / 2,
          mouseY: canvas.height / 2,
          lastMouseX: canvas.width / 2,
          lastMouseY: canvas.height / 2,
          personIndex: getNextPersonImage(),
        };
        for (let i = 0; i < 15; i++) {
          const a = Math.random() * Math.PI * 2,
            s = 2 + Math.random() * 2;
          balls.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: Math.cos(a) * s,
            vy: Math.sin(a) * s,
            radius: 35 + Math.random() * 20,
            rotation: Math.random() * Math.PI * 2,
            ballImage: getNextBallImage(),
            lastHitTime: Date.now(),
            sleepy: false,
            fadeProgress: 0,
            squashX: 1,
            squashY: 1,
            wallHitTimer: 0,
          });
        }
      }

      function updatePaddle() {
        const mVx = gameState.mouseX - gameState.lastMouseX,
          mVy = gameState.mouseY - gameState.lastMouseY;
        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          ball.vy += 0.15;
          const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
          ball.vx *= 0.995;
          ball.vy *= 0.995;
          ball.x += ball.vx;
          ball.y += ball.vy;
          ball.rotation += speed * 0.02;
          capSpeed(ball);
          if (ball.wallHitTimer > 0) {
            ball.wallHitTimer--;
          } else {
            ball.squashX += (1 - ball.squashX) * 0.3;
            ball.squashY += (1 - ball.squashY) * 0.3;
          }
          if (speed < 1.5 && Date.now() - ball.lastHitTime > 3000) {
            ball.sleepy = true;
            ball.fadeProgress += 0.008;
            if (ball.fadeProgress >= 1) {
              balls.splice(i, 1);
              const a = Math.random() * Math.PI * 2,
                ns = 3 + Math.random() * 2;
              balls.push({
                x: Math.random() * canvas.width,
                y: 100,
                vx: Math.cos(a) * ns,
                vy: Math.sin(a) * ns,
                radius: 35 + Math.random() * 20,
                rotation: 0,
                ballImage: getNextBallImage(),
                lastHitTime: Date.now(),
                sleepy: false,
                fadeProgress: 0,
                squashX: 1,
                squashY: 1,
                wallHitTimer: 0,
              });
              continue;
            }
          } else {
            ball.sleepy = false;
            ball.fadeProgress = Math.max(0, ball.fadeProgress - 0.02);
            ball.lastHitTime = Date.now();
          }
          if (ball.x - ball.radius < 0) {
            ball.x = ball.radius;
            ball.vx *= -0.9;
            if (ball.vx > 1) {
              ball.squashX = 0.85;
              ball.squashY = 1.15;
              ball.wallHitTimer = 3;
            }
          }
          if (ball.x + ball.radius > canvas.width) {
            ball.x = canvas.width - ball.radius;
            ball.vx *= -0.9;
            if (ball.vx < -1) {
              ball.squashX = 0.85;
              ball.squashY = 1.15;
              ball.wallHitTimer = 3;
            }
          }
          if (ball.y - ball.radius < 0) {
            ball.y = ball.radius;
            ball.vy *= -0.9;
            if (ball.vy > 1) {
              ball.squashX = 1.15;
              ball.squashY = 0.85;
              ball.wallHitTimer = 3;
            }
          }
          if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius;
            ball.vy *= -0.7;
            if (ball.vy < -1) {
              ball.squashX = 1.15;
              ball.squashY = 0.85;
              ball.wallHitTimer = 3;
            }
          }
          const dx = ball.x - gameState.mouseX,
            dy = ball.y - gameState.mouseY,
            dist = Math.sqrt(dx * dx + dy * dy),
            padR = 55;
          if (dist < ball.radius + padR) {
            const mSpeed = Math.sqrt(mVx * mVx + mVy * mVy),
              force = Math.min(mSpeed * 0.5, 15),
              ang = Math.atan2(dy, dx);
            ball.vx += Math.cos(ang) * force;
            ball.vy += Math.sin(ang) * force;
            const overlap = ball.radius + padR - dist;
            ball.x += Math.cos(ang) * overlap;
            ball.y += Math.sin(ang) * overlap;
            ball.lastHitTime = Date.now();
            ball.sleepy = false;
            if (force > 3) addScreenShake(force * 0.3);
            capSpeed(ball);
          }
        }
        for (let i = 0; i < balls.length; i++) {
          for (let j = i + 1; j < balls.length; j++) {
            const b1 = balls[i],
              b2 = balls[j],
              dx = b2.x - b1.x,
              dy = b2.y - b1.y,
              dist = Math.sqrt(dx * dx + dy * dy),
              minDist = b1.radius + b2.radius;
            if (dist < minDist) {
              const ang = Math.atan2(dy, dx),
                tx = b1.x + Math.cos(ang) * minDist,
                ty = b1.y + Math.sin(ang) * minDist,
                ax = (tx - b2.x) * 0.05,
                ay = (ty - b2.y) * 0.05;
              b1.vx -= ax;
              b1.vy -= ay;
              b2.vx += ax;
              b2.vy += ay;
            }
          }
        }
        gameState.lastMouseX = gameState.mouseX;
        gameState.lastMouseY = gameState.mouseY;
      }
      function drawPaddle() {
        balls.forEach((ball) => {
          const op = 1 - ball.fadeProgress;
          if (ball.sleepy) {
            ctx.fillStyle = "rgba(100, 100, 200, " + 0.3 * op + ")";
            ctx.font = "20px Arial";
            ctx.textAlign = "center";
            ctx.fillText("ðŸ’¤", ball.x, ball.y - ball.radius - 10);
          }
          drawBallWithSquash(ball, op, ball.rotation, ball.squashX, ball.squashY);
        });
        drawPerson(gameState.mouseX, gameState.mouseY + 35, 80, gameState.personIndex);
        ctx.beginPath();
        ctx.arc(gameState.mouseX, gameState.mouseY, 55, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(100, 100, 100, 0.3)";
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      function paddlePointerMove(x, y) {
        gameState.mouseX = x;
        gameState.mouseY = y;
      }

      // GAME 3: POP
      function initPop() {
        balls = [];
        gameState = { particles: [] };
        for (let i = 0; i < 20; i++) {
          const a = Math.random() * Math.PI * 2,
            s = 0.8 + Math.random() * 0.8;
          balls.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: Math.cos(a) * s,
            vy: Math.sin(a) * s,
            radius: 90 + Math.random() * 30,
            popping: false,
            popProgress: 0,
            opacity: 1,
            rotation: Math.random() * Math.PI * 2,
            ballImage: getNextBallImage(),
          });
        }
      }
      function updatePop() {
        gameState.particles = gameState.particles.filter((p) => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += p.gravity || 0.1;
          p.life--;
          p.rotation = (p.rotation || 0) + (p.spin || 0);
          return p.life > 0;
        });
        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          if (ball.popping) {
            ball.popProgress += 0.12;
            ball.opacity = 1 - ball.popProgress;
            if (ball.popProgress >= 1) balls.splice(i, 1);
            continue;
          }
          const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
          if (speed < 0.5) {
            const a = Math.atan2(ball.vy, ball.vx);
            ball.vx = Math.cos(a) * 0.8;
            ball.vy = Math.sin(a) * 0.8;
          }
          ball.vx *= 0.98;
          ball.vy *= 0.98;
          ball.x += ball.vx;
          ball.y += ball.vy;
          ball.rotation += speed * 0.01;
          capSpeed(ball);
          if (ball.x - ball.radius < 0) {
            ball.x = ball.radius;
            ball.vx *= -0.9;
          }
          if (ball.x + ball.radius > canvas.width) {
            ball.x = canvas.width - ball.radius;
            ball.vx *= -0.9;
          }
          if (ball.y - ball.radius < 0) {
            ball.y = ball.radius;
            ball.vy *= -0.9;
          }
          if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius;
            ball.vy *= -0.9;
          }
        }
        ballCollisions();
      }
      function drawPop() {
        gameState.particles.forEach((p) => {
          const img = ballImages[p.ballImage - 1];
          if (img && img.complete && img.naturalWidth > 0) {
            ctx.save();
            ctx.globalAlpha = p.life / p.maxLife;
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation);
            ctx.drawImage(img, -p.size / 2, -p.size / 2, p.size, p.size);
            ctx.restore();
          }
        });
        balls.forEach((ball) => {
          ctx.save();
          ctx.globalAlpha = ball.opacity;
          if (ball.popping) {
            const sc = 1 + ball.popProgress * 0.8;
            ctx.translate(ball.x, ball.y);
            ctx.scale(sc, sc);
            ctx.rotate(ball.popProgress * 0.5);
            ctx.translate(-ball.x, -ball.y);
          }
          drawBall(ball, 1.0, ball.rotation);
          ctx.restore();
        });
      }
      function popPointerDown(x, y) {
        for (let i = balls.length - 1; i >= 0; i--) {
          if (!balls[i].popping && contains(balls[i], x, y)) {
            const ball = balls[i];
            ball.popping = true;
            addScreenShake(ball.radius * 0.08);
            const nP = Math.floor(ball.radius * 0.25);
            for (let j = 0; j < nP; j++) {
              const a = Math.random() * Math.PI * 2,
                sp = 3 + Math.random() * 5;
              gameState.particles.push({
                x: ball.x,
                y: ball.y,
                vx: Math.cos(a) * sp,
                vy: Math.sin(a) * sp - 2,
                size: 8 + Math.random() * 15,
                life: 40,
                maxLife: 40,
                rotation: Math.random() * Math.PI,
                spin: (Math.random() - 0.5) * 0.2,
                gravity: 0.15,
                ballImage: ball.ballImage,
              });
            }
            if (ball.radius > 25) {
              const cR = ball.radius * 0.55,
                nC = 2 + Math.floor(Math.random() * 2);
              for (let j = 0; j < nC; j++) {
                const a = ((Math.PI * 2) / nC) * j + Math.random() * 0.5,
                  sp = 4 + Math.random() * 4;
                balls.push({
                  x: ball.x,
                  y: ball.y,
                  vx: Math.cos(a) * sp,
                  vy: Math.sin(a) * sp,
                  radius: cR,
                  popping: false,
                  popProgress: 0,
                  opacity: 1,
                  rotation: Math.random() * Math.PI * 2,
                  ballImage: getNextBallImage(),
                });
              }
            }
            break;
          }
        }
      }

      // GAME 4: VACUUM
      function initVacuum() {
        balls = [];
        gameState = { mouseX: canvas.width / 2, mouseY: canvas.height / 2, isVacuuming: false, vacuumStrength: 0 };
        for (let i = 0; i < 30; i++)
          balls.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: (Math.random() - 0.5) * 3,
            vy: (Math.random() - 0.5) * 3,
            radius: 30 + Math.random() * 25,
            ballImage: getNextBallImage(),
            squashX: 1,
            squashY: 1,
          });
      }
      function updateVacuum() {
        if (gameState.isVacuuming) gameState.vacuumStrength = Math.min(gameState.vacuumStrength + 3, 100);
        balls.forEach((ball) => {
          if (gameState.isVacuuming) {
            const dx = gameState.mouseX - ball.x,
              dy = gameState.mouseY - ball.y,
              dist = Math.sqrt(dx * dx + dy * dy),
              force = Math.min(gameState.vacuumStrength / (dist + 20), 8);
            ball.vx += (dx / dist) * force;
            ball.vy += (dy / dist) * force;
          }
          if (ball.x < canvas.width / 2) ball.vx -= 0.15;
          else ball.vx += 0.15;
          ball.vx *= 0.98;
          ball.vy *= 0.98;
          ball.x += ball.vx;
          ball.y += ball.vy;
          capSpeed(ball);
          ball.squashX += (1 - ball.squashX) * 0.1;
          ball.squashY += (1 - ball.squashY) * 0.1;
          if (ball.x - ball.radius < 0) {
            ball.x = ball.radius;
            ball.vx *= -0.9;
            ball.squashX = 0.92;
            ball.squashY = 1.08;
          }
          if (ball.x + ball.radius > canvas.width) {
            ball.x = canvas.width - ball.radius;
            ball.vx *= -0.9;
            ball.squashX = 0.92;
            ball.squashY = 1.08;
          }
          if (ball.y - ball.radius < 0) {
            ball.y = ball.radius;
            ball.vy *= -0.9;
            ball.squashX = 1.08;
            ball.squashY = 0.92;
          }
          if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius;
            ball.vy *= -0.9;
            ball.squashX = 1.08;
            ball.squashY = 0.92;
          }
        });
        for (let i = 0; i < balls.length; i++) {
          for (let j = i + 1; j < balls.length; j++) {
            const b1 = balls[i],
              b2 = balls[j],
              dx = b2.x - b1.x,
              dy = b2.y - b1.y,
              dist = Math.sqrt(dx * dx + dy * dy),
              minDist = b1.radius + b2.radius;
            if (dist < minDist) {
              const ang = Math.atan2(dy, dx),
                ax = (minDist - dist) * Math.cos(ang) * 0.05,
                ay = (minDist - dist) * Math.sin(ang) * 0.05;
              b1.vx -= ax;
              b1.vy -= ay;
              b2.vx += ax;
              b2.vy += ay;
              b1.squashX = 0.94;
              b1.squashY = 1.06;
              b2.squashX = 0.94;
              b2.squashY = 1.06;
            }
          }
        }
      }
      function drawVacuum() {
        if (gameState.isVacuuming) {
          const maxR = 150;
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            const r = maxR * (1 - i * 0.3) * (gameState.vacuumStrength / 100);
            ctx.arc(gameState.mouseX, gameState.mouseY, r, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(100, 100, 100, " + (0.3 - i * 0.1) + ")";
            ctx.lineWidth = 3;
            ctx.stroke();
          }
          ctx.beginPath();
          ctx.arc(gameState.mouseX, gameState.mouseY, 10, 0, Math.PI * 2);
          ctx.fillStyle = "#666";
          ctx.fill();
        }
        balls.forEach((ball) => drawBallWithSquash(ball, 1, 0, ball.squashX, ball.squashY));
      }
      function vacuumPointerDown(x, y) {
        gameState.mouseX = x;
        gameState.mouseY = y;
        gameState.isVacuuming = true;
        gameState.vacuumStrength = 0;
      }
      function vacuumPointerMove(x, y) {
        gameState.mouseX = x;
        gameState.mouseY = y;
      }
      function vacuumPointerUp() {
        if (gameState.isVacuuming) {
          addScreenShake(gameState.vacuumStrength * 0.1);
          balls.forEach((ball) => {
            const dx = ball.x - gameState.mouseX,
              dy = ball.y - gameState.mouseY,
              dist = Math.sqrt(dx * dx + dy * dy),
              force = Math.min(5000 / (dist + 50), 20);
            ball.vx += (dx / dist) * force;
            ball.vy += (dy / dist) * force;
            ball.squashX = 0.85;
            ball.squashY = 1.15;
            capSpeed(ball);
          });
          gameState.isVacuuming = false;
          gameState.vacuumStrength = 0;
        }
      }

      // GAME 5: GRAVITY FLIP - faster recovery
      function initGravityFlip() {
        balls = [];
        gameState = { gravityDir: 1 };
        for (let i = 0; i < 30; i++)
          balls.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2,
            radius: 25 + Math.random() * 20,
            ballImage: getNextBallImage(),
            squashX: 1,
            squashY: 1,
          });
      }
      function updateGravityFlip() {
        balls.forEach((ball) => {
          ball.vy += 0.25 * gameState.gravityDir;
          ball.vx *= 0.98;
          ball.vy *= 0.98;
          ball.x += ball.vx;
          ball.y += ball.vy;
          capSpeed(ball);
          ball.squashX += (1 - ball.squashX) * 0.25;
          ball.squashY += (1 - ball.squashY) * 0.25;
          if (ball.x - ball.radius < 0) {
            ball.x = ball.radius;
            ball.vx *= -0.75;
            ball.squashX = 0.85;
            ball.squashY = 1.15;
          }
          if (ball.x + ball.radius > canvas.width) {
            ball.x = canvas.width - ball.radius;
            ball.vx *= -0.75;
            ball.squashX = 0.85;
            ball.squashY = 1.15;
          }
          if (ball.y - ball.radius < 0) {
            ball.y = ball.radius;
            ball.vy *= -0.75;
            ball.squashX = 1.15;
            ball.squashY = 0.85;
          }
          if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius;
            ball.vy *= -0.75;
            ball.squashX = 1.15;
            ball.squashY = 0.85;
          }
        });
        for (let i = 0; i < balls.length; i++) {
          for (let j = i + 1; j < balls.length; j++) {
            const b1 = balls[i],
              b2 = balls[j],
              dx = b2.x - b1.x,
              dy = b2.y - b1.y,
              dist = Math.sqrt(dx * dx + dy * dy),
              minDist = b1.radius + b2.radius;
            if (dist < minDist) {
              const ang = Math.atan2(dy, dx),
                ax = (minDist - dist) * Math.cos(ang) * 0.05,
                ay = (minDist - dist) * Math.sin(ang) * 0.05;
              b1.vx -= ax;
              b1.vy -= ay;
              b2.vx += ax;
              b2.vy += ay;
              b1.squashX = 0.9;
              b1.squashY = 1.1;
              b2.squashX = 0.9;
              b2.squashY = 1.1;
            }
          }
        }
      }
      function drawGravityFlip() {
        balls.forEach((ball) => drawBallWithSquash(ball, 1, 0, ball.squashX, ball.squashY));
        const aY = gameState.gravityDir === 1 ? canvas.height - 30 : 30;
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.font = "bold 24px Arial";
        ctx.textAlign = "center";
        ctx.fillText(gameState.gravityDir === 1 ? "â†“" : "â†‘", canvas.width / 2, aY);
      }
      function gravityFlipPointerDown() {
        gameState.gravityDir *= -1;
        addScreenShake(4);
      }

      // GAME 6: BOUNCE - with star target, squish, and splat death
      function initBounce() {
        balls = [];
        gameState = {
          barriers: [],
          drawing: false,
          drawStart: null,
          drawEnd: null,
          maxBarriers: 3,
          maxLineLength: 200,
          barrierLifetime: 8000,
          particles: [],
          splats: [],
          score: 0,
          target: {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 50,
            pulse: 0,
            rotation: 0,
          },
        };
        spawnBounceBall();
      }

      function spawnBounceBall() {
        balls.push({
          x: 100 + Math.random() * (canvas.width - 200),
          y: 100,
          vx: (Math.random() - 0.5) * 2,
          vy: 1,
          radius: 30,
          ballImage: getNextBallImage(),
          growScale: 1,
          squishX: 1,
          squishY: 1,
          squishRecovery: 0.15,
          dying: false,
          deathProgress: 0,
        });
      }

      function updateBounce() {
        gameState.barriers = gameState.barriers.filter((b) => Date.now() - b.created < gameState.barrierLifetime);
        gameState.splats = gameState.splats.filter((s) => s.life > 0);
        gameState.splats.forEach((s) => s.life--);
        gameState.particles = gameState.particles.filter((p) => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += p.gravity || 0;
          p.life--;
          p.rotation += p.spin || 0;
          return p.life > 0;
        });
        gameState.target.pulse += 0.08;
        gameState.target.rotation += 0.02;

        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];

          // Handle dying animation
          if (ball.dying) {
            ball.deathProgress += 0.08;
            if (ball.deathProgress >= 1) {
              balls.splice(i, 1);
              setTimeout(spawnBounceBall, 500);
            }
            continue;
          }

          ball.vy += 0.08;
          ball.vx *= 0.995;
          ball.vy *= 0.995;
          ball.x += ball.vx;
          ball.y += ball.vy;
          ball.squishX += (1 - ball.squishX) * ball.squishRecovery;
          ball.squishY += (1 - ball.squishY) * ball.squishRecovery;
          capSpeed(ball);

          const dx = ball.x - gameState.target.x,
            dy = ball.y - gameState.target.y,
            dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < ball.radius * ball.growScale + gameState.target.radius) {
            gameState.score++;
            ball.growScale += 0.15;
            addScreenShake(12);
            for (let k = 0; k < 12; k++) {
              const a = Math.random() * Math.PI * 2;
              gameState.particles.push({
                x: gameState.target.x,
                y: gameState.target.y,
                vx: Math.cos(a) * (3 + Math.random() * 5),
                vy: Math.sin(a) * (3 + Math.random() * 5) - 4,
                life: 50,
                rotation: Math.random() * Math.PI * 2,
                spin: (Math.random() - 0.5) * 0.3,
                gravity: 0.12,
                isStar: true,
                starIndex: Math.floor(Math.random() * 3),
                size: 30 + Math.random() * 25,
              });
            }
            gameState.target.x = 150 + Math.random() * (canvas.width - 300);
            gameState.target.y = 250 + Math.random() * (canvas.height - 400);
            const ang = Math.atan2(dy, dx);
            ball.vx = Math.cos(ang) * 5;
            ball.vy = Math.sin(ang) * 5;
          }

          // Ground collision - SPLAT AND DIE
          if (ball.y + ball.radius * ball.growScale >= canvas.height - 5 && !ball.dying) {
            ball.dying = true;
            ball.deathProgress = 0;
            addScreenShake(5);
            gameState.splats.push({
              x: ball.x,
              y: canvas.height,
              radius: ball.radius * ball.growScale,
              life: 120,
              color: "hsl(" + Math.random() * 360 + ", 60%, 50%)",
            });
            continue;
          }

          // Wall collisions with squish
          if (ball.x - ball.radius * ball.growScale < 0) {
            ball.x = ball.radius * ball.growScale;
            ball.vx *= -0.9;
            ball.squishX = 0.7;
            ball.squishY = 1.3;
          }
          if (ball.x + ball.radius * ball.growScale > canvas.width) {
            ball.x = canvas.width - ball.radius * ball.growScale;
            ball.vx *= -0.9;
            ball.squishX = 0.7;
            ball.squishY = 1.3;
          }
          if (ball.y - ball.radius * ball.growScale < 0) {
            ball.y = ball.radius * ball.growScale;
            ball.vy *= -0.9;
            ball.squishX = 1.4;
            ball.squishY = 0.6;
          }

          // Barrier collisions with squish
          gameState.barriers.forEach((barrier) => {
            const result = lineCircleCollision(barrier.x1, barrier.y1, barrier.x2, barrier.y2, ball.x, ball.y, ball.radius * ball.growScale);
            if (result.collides) {
              ball.x = result.newX;
              ball.y = result.newY;
              const ang = Math.atan2(barrier.y2 - barrier.y1, barrier.x2 - barrier.x1),
                nAng = ang + Math.PI / 2,
                dot = ball.vx * Math.cos(nAng) + ball.vy * Math.sin(nAng);
              ball.vx -= 2 * dot * Math.cos(nAng) * 1.1;
              ball.vy -= 2 * dot * Math.sin(nAng) * 1.1;
              ball.squishX = 0.75;
              ball.squishY = 1.25;
              capSpeed(ball);
            }
          });
        }
      }

      function drawBounce() {
        const t = gameState.target,
          pulseScale = 1 + Math.sin(t.pulse) * 0.15;
        const glowGrad = ctx.createRadialGradient(t.x, t.y, t.radius * 0.3, t.x, t.y, t.radius * 2.5);
        glowGrad.addColorStop(0, "rgba(255, 220, 100, 0.6)");
        glowGrad.addColorStop(1, "rgba(255, 180, 50, 0)");
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.radius * 2.5 * pulseScale, 0, Math.PI * 2);
        ctx.fillStyle = glowGrad;
        ctx.fill();

        const size = t.radius * 2.5 * pulseScale;
        const starImg = starImages[0];
        if (starImg && starImg.complete && starImg.naturalWidth > 0) {
          ctx.save();
          ctx.translate(t.x, t.y);
          ctx.rotate(t.rotation);
          ctx.drawImage(starImg, -size / 2, -size / 2, size, size);
          ctx.restore();
        }

        // Draw star particles
        gameState.particles.forEach((p) => {
          if (p.isStar) {
            const starParticleImg = starImages[p.starIndex];
            if (starParticleImg && starParticleImg.complete && starParticleImg.naturalWidth > 0) {
              ctx.save();
              ctx.globalAlpha = p.life / 50;
              ctx.translate(p.x, p.y);
              ctx.rotate(p.rotation);
              ctx.drawImage(starParticleImg, -p.size / 2, -p.size / 2, p.size, p.size);
              ctx.restore();
            }
          }
        });

        // Draw splats
        gameState.splats.forEach((splat) => {
          const a = splat.life / 120,
            sq = 1 + (1 - a) * 2;
          ctx.save();
          ctx.globalAlpha = a * 0.6;
          ctx.translate(splat.x, splat.y);
          ctx.scale(sq, 0.3);
          ctx.beginPath();
          ctx.arc(0, 0, splat.radius, 0, Math.PI * 2);
          ctx.fillStyle = splat.color;
          ctx.fill();
          ctx.restore();
        });

        // Draw balls with squish (and dying animation)
        balls.forEach((ball) => {
          const img = ballImages[ball.ballImage - 1],
            r = ball.radius * ball.growScale;
          if (img && img.complete && img.naturalWidth > 0) {
            if (ball.dying) {
              // Dying squish animation
              ctx.save();
              const sqY = 1 - ball.deathProgress * 0.8;
              const sqX = 1 + ball.deathProgress * 0.5;
              ctx.translate(ball.x, canvas.height);
              ctx.scale(sqX, sqY);
              ctx.globalAlpha = 1 - ball.deathProgress;
              ctx.drawImage(img, -r, -r * 2, r * 2, r * 2);
              ctx.restore();
            } else {
              // Normal with squish
              ctx.save();
              ctx.translate(ball.x, ball.y);
              ctx.scale(ball.squishX, ball.squishY);
              ctx.drawImage(img, -r, -r, r * 2, r * 2);
              ctx.restore();
            }
          }
        });

        // Draw barriers
        gameState.barriers.forEach((barrier) => {
          const age = Date.now() - barrier.created,
            op = Math.max(0, 1 - age / gameState.barrierLifetime);
          ctx.save();
          ctx.shadowColor = "rgba(100, 180, 255, 0.8)";
          ctx.shadowBlur = 15 * op;
          ctx.beginPath();
          ctx.moveTo(barrier.x1, barrier.y1);
          ctx.lineTo(barrier.x2, barrier.y2);
          ctx.strokeStyle = "rgba(80, 150, 220, " + op + ")";
          ctx.lineWidth = 8;
          ctx.lineCap = "round";
          ctx.stroke();
          ctx.restore();
          ctx.beginPath();
          ctx.moveTo(barrier.x1, barrier.y1);
          ctx.lineTo(barrier.x2, barrier.y2);
          ctx.strokeStyle = "rgba(255, 255, 255, " + op * 0.9 + ")";
          ctx.lineWidth = 4;
          ctx.lineCap = "round";
          ctx.stroke();
        });

        // Draw line preview
        if (gameState.drawing && gameState.drawStart) {
          let dx = gameState.drawEnd.x - gameState.drawStart.x,
            dy = gameState.drawEnd.y - gameState.drawStart.y,
            len = Math.sqrt(dx * dx + dy * dy);
          if (len > gameState.maxLineLength) {
            dx = (dx / len) * gameState.maxLineLength;
            dy = (dy / len) * gameState.maxLineLength;
          }
          const endX = gameState.drawStart.x + dx,
            endY = gameState.drawStart.y + dy;
          ctx.save();
          ctx.shadowColor = "rgba(100, 180, 255, 0.5)";
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.moveTo(gameState.drawStart.x, gameState.drawStart.y);
          ctx.lineTo(endX, endY);
          ctx.strokeStyle = len > gameState.maxLineLength ? "rgba(255, 100, 100, 0.5)" : "rgba(80, 150, 220, 0.5)";
          ctx.lineWidth = 8;
          ctx.lineCap = "round";
          ctx.stroke();
          ctx.restore();
        }
      }

      function bouncePointerDown(x, y) {
        if (gameState.barriers.length >= gameState.maxBarriers) return;
        gameState.drawing = true;
        gameState.drawStart = { x, y };
        gameState.drawEnd = { x, y };
      }
      function bouncePointerMove(x, y) {
        if (gameState.drawing) gameState.drawEnd = { x, y };
      }
      function bouncePointerUp() {
        if (gameState.drawing && gameState.drawStart && gameState.drawEnd) {
          let dx = gameState.drawEnd.x - gameState.drawStart.x,
            dy = gameState.drawEnd.y - gameState.drawStart.y,
            len = Math.sqrt(dx * dx + dy * dy);
          if (len > 20) {
            if (len > gameState.maxLineLength) {
              dx = (dx / len) * gameState.maxLineLength;
              dy = (dy / len) * gameState.maxLineLength;
            }
            gameState.barriers.push({
              x1: gameState.drawStart.x,
              y1: gameState.drawStart.y,
              x2: gameState.drawStart.x + dx,
              y2: gameState.drawStart.y + dy,
              created: Date.now(),
            });
          }
        }
        gameState.drawing = false;
        gameState.drawStart = null;
        gameState.drawEnd = null;
      }

      // GAME 7: MAGNET ZONES
      function initMagnetZones() {
        balls = [];
        gameState = { magnets: [], shiftPressed: false };
        for (let i = 0; i < 20; i++)
          balls.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: (Math.random() - 0.5) * 3,
            vy: (Math.random() - 0.5) * 3,
            radius: 18 + Math.random() * 15,
            ballImage: getNextBallImage(),
          });
      }
      function updateMagnetZones() {
        gameState.magnets = gameState.magnets.filter((m) => Date.now() - m.created < 10000);
        balls.forEach((ball) => {
          ball.vy += 0.15;
          gameState.magnets.forEach((magnet) => {
            const dx = magnet.x - ball.x,
              dy = magnet.y - ball.y,
              dist = Math.sqrt(dx * dx + dy * dy),
              force = (magnet.type === "attract" ? 1 : -1) * Math.min(200 / (dist + 20), 4);
            ball.vx += (dx / dist) * force;
            ball.vy += (dy / dist) * force;
          });
          ball.vx *= 0.98;
          ball.vy *= 0.98;
          ball.x += ball.vx;
          ball.y += ball.vy;
          capSpeed(ball);
          if (ball.x - ball.radius < 0) {
            ball.x = ball.radius;
            ball.vx *= -0.7;
          }
          if (ball.x + ball.radius > canvas.width) {
            ball.x = canvas.width - ball.radius;
            ball.vx *= -0.7;
          }
          if (ball.y - ball.radius < 0) {
            ball.y = ball.radius;
            ball.vy *= -0.7;
          }
          if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius;
            ball.vy *= -0.7;
          }
        });
        ballCollisions();
      }
      function drawMagnetZones() {
        gameState.magnets.forEach((magnet) => {
          const age = Date.now() - magnet.created,
            op = Math.max(0, 1 - age / 10000),
            isAttr = magnet.type === "attract",
            time = Date.now() * 0.0015;
          if (isAttr) {
            for (let i = 0; i < 4; i++) {
              const bR = 100 - ((time * 30 + i * 25) % 100);
              ctx.beginPath();
              ctx.arc(magnet.x, magnet.y, bR, 0, Math.PI * 2);
              ctx.strokeStyle = "rgba(50, 150, 255, " + op * (0.5 - i * 0.1) + ")";
              ctx.lineWidth = 3;
              ctx.stroke();
            }
            const g = ctx.createRadialGradient(magnet.x, magnet.y, 0, magnet.x, magnet.y, 60);
            g.addColorStop(0, "rgba(50, 150, 255, " + op * 0.4 + ")");
            g.addColorStop(1, "rgba(50, 150, 255, 0)");
            ctx.beginPath();
            ctx.arc(magnet.x, magnet.y, 60, 0, Math.PI * 2);
            ctx.fillStyle = g;
            ctx.fill();
          } else {
            for (let i = 0; i < 4; i++) {
              const bR = 20 + ((time * 30 + i * 25) % 100);
              ctx.beginPath();
              ctx.arc(magnet.x, magnet.y, bR, 0, Math.PI * 2);
              ctx.strokeStyle = "rgba(255, 80, 80, " + op * (0.5 - i * 0.1) + ")";
              ctx.lineWidth = 3;
              ctx.stroke();
            }
            const g = ctx.createRadialGradient(magnet.x, magnet.y, 0, magnet.x, magnet.y, 60);
            g.addColorStop(0, "rgba(255, 80, 80, " + op * 0.4 + ")");
            g.addColorStop(1, "rgba(255, 80, 80, 0)");
            ctx.beginPath();
            ctx.arc(magnet.x, magnet.y, 60, 0, Math.PI * 2);
            ctx.fillStyle = g;
            ctx.fill();
          }
          drawPerson(magnet.x, magnet.y + 80, 55, magnet.personIndex, op);
          ctx.font = "bold 28px Arial";
          ctx.textAlign = "center";
          ctx.fillStyle = isAttr ? "rgba(50, 150, 255, " + op + ")" : "rgba(255, 80, 80, " + op + ")";
          ctx.fillText(isAttr ? "âŠ•" : "âŠ–", magnet.x, magnet.y - 5);
        });
        balls.forEach((ball) => drawBall(ball));
        ctx.fillStyle = "#666";
        ctx.font = "14px Arial";
        ctx.textAlign = "left";
        ctx.fillText(gameState.shiftPressed ? "Mode: REPEL" : "Mode: ATTRACT [hold SHIFT]", 20, canvas.height - 80);
      }
      function magnetPointerDown(x, y) {
        gameState.magnets.push({ x, y, type: gameState.shiftPressed ? "repel" : "attract", created: Date.now(), personIndex: getNextPersonImage() });
      }

      // GAME 8: EXPLODE - no counter
      function initExplode() {
        balls = [];
        gameState = { chargeStart: 0, charging: false, chargeX: 0, chargeY: 0 };
      }
      function updateExplode() {
        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          ball.vy += 0.2;
          ball.vx *= 0.99;
          ball.vy *= 0.99;
          ball.x += ball.vx;
          ball.y += ball.vy;
          capSpeed(ball);
          ball.life--;
          ball.opacity = Math.min(1, ball.life / 60);
          if (ball.life <= 0 || ball.y > canvas.height + 50) {
            balls.splice(i, 1);
            continue;
          }
          if (ball.x - ball.radius < 0) {
            ball.x = ball.radius;
            ball.vx *= -0.7;
          }
          if (ball.x + ball.radius > canvas.width) {
            ball.x = canvas.width - ball.radius;
            ball.vx *= -0.7;
          }
          if (ball.y - ball.radius < 0) {
            ball.y = ball.radius;
            ball.vy *= -0.7;
          }
          if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius;
            ball.vy *= -0.7;
          }
        }
        ballCollisions();
      }
      function drawExplode() {
        if (gameState.charging) {
          const cT = Date.now() - gameState.chargeStart,
            cA = Math.min(cT / 1000, 1),
            r = 20 + cA * 60,
            pulse = Math.sin(Date.now() * 0.02) * 5;
          ctx.beginPath();
          ctx.arc(gameState.chargeX, gameState.chargeY, r + pulse, 0, Math.PI * 2);
          ctx.strokeStyle = "rgba(100, 100, 100, " + (0.3 + cA * 0.4) + ")";
          ctx.lineWidth = 3 + cA * 3;
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(gameState.chargeX, gameState.chargeY, r * 0.3, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(80, 80, 80, " + (0.3 + cA * 0.5) + ")";
          ctx.fill();
          ctx.fillStyle = "#666";
          ctx.font = "bold 16px Arial";
          ctx.textAlign = "center";
          ctx.fillText(Math.floor(cA * 100) + "%", gameState.chargeX, gameState.chargeY + r + 25);
        }
        balls.forEach((ball) => {
          ctx.save();
          ctx.globalAlpha = ball.opacity;
          drawBall(ball);
          ctx.restore();
        });
      }
      function explodePointerDown(x, y) {
        gameState.charging = true;
        gameState.chargeStart = Date.now();
        gameState.chargeX = x;
        gameState.chargeY = y;
      }
      function explodePointerUp() {
        if (!gameState.charging) return;
        const cT = Date.now() - gameState.chargeStart,
          cA = Math.min(cT / 1000, 1),
          power = 5 + cA * 12,
          numBalls = Math.floor(8 + cA * 27);
        addScreenShake(cA * 10);
        for (let i = 0; i < numBalls; i++) {
          const ang = ((Math.PI * 2) / numBalls) * i + Math.random() * 0.2,
            sV = 0.7 + Math.random() * 0.6;
          balls.push({
            x: gameState.chargeX,
            y: gameState.chargeY,
            vx: Math.cos(ang) * power * sV,
            vy: Math.sin(ang) * power * sV,
            radius: 12 + Math.random() * 29,
            life: 150 + Math.random() * 100,
            opacity: 1,
            ballImage: getNextBallImage(),
          });
        }
        gameState.charging = false;
      }

      // GAME 9: ORBITAL
      function initOrbital() {
        balls = [];
        gameState = { mouseX: canvas.width / 2, mouseY: canvas.height / 2 };
        for (let i = 0; i < 40; i++) {
          const ang = ((Math.PI * 2) / 40) * i,
            dist = 60 + Math.random() * 180;
          balls.push({
            angle: ang,
            distance: dist,
            angleSpeed: (0.02 + Math.random() * 0.04) * (Math.random() > 0.5 ? 1 : -1),
            radius: 15 + Math.random() * 18,
            orbiting: true,
            vx: 0,
            vy: 0,
            x: 0,
            y: 0,
            ballImage: getNextBallImage(),
          });
        }
      }
      function updateOrbital() {
        balls.forEach((ball) => {
          if (ball.orbiting) {
            ball.angle += ball.angleSpeed;
            ball.x = gameState.mouseX + Math.cos(ball.angle) * ball.distance;
            ball.y = gameState.mouseY + Math.sin(ball.angle) * ball.distance;
          } else {
            ball.vy += 0.2;
            ball.vx *= 0.98;
            ball.vy *= 0.98;
            ball.x += ball.vx;
            ball.y += ball.vy;
            capSpeed(ball);
            if (ball.x - ball.radius < 0) {
              ball.x = ball.radius;
              ball.vx *= -0.7;
            }
            if (ball.x + ball.radius > canvas.width) {
              ball.x = canvas.width - ball.radius;
              ball.vx *= -0.7;
            }
            if (ball.y - ball.radius < 0) {
              ball.y = ball.radius;
              ball.vy *= -0.7;
            }
            if (ball.y + ball.radius > canvas.height) {
              ball.y = canvas.height - ball.radius;
              ball.vy *= -0.7;
            }
          }
        });
        const freeBalls = balls.filter((b) => !b.orbiting);
        for (let i = 0; i < freeBalls.length; i++) {
          for (let j = i + 1; j < freeBalls.length; j++) {
            const b1 = freeBalls[i],
              b2 = freeBalls[j],
              dx = b2.x - b1.x,
              dy = b2.y - b1.y,
              dist = Math.sqrt(dx * dx + dy * dy),
              minDist = b1.radius + b2.radius;
            if (dist < minDist) {
              const ang = Math.atan2(dy, dx),
                ax = (minDist - dist) * Math.cos(ang) * 0.05,
                ay = (minDist - dist) * Math.sin(ang) * 0.05;
              b1.vx -= ax;
              b1.vy -= ay;
              b2.vx += ax;
              b2.vy += ay;
            }
          }
        }
      }
      function drawOrbital() {
        balls
          .filter((b) => b.orbiting)
          .forEach((ball) => {
            ctx.beginPath();
            ctx.arc(gameState.mouseX, gameState.mouseY, ball.distance, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(200, 200, 200, 0.2)";
            ctx.lineWidth = 1;
            ctx.stroke();
          });
        balls.forEach((ball) => drawBall(ball, ball.orbiting ? 0.8 : 1.0));
        ctx.beginPath();
        ctx.arc(gameState.mouseX, gameState.mouseY, 5, 0, Math.PI * 2);
        ctx.fillStyle = "#999";
        ctx.fill();
      }
      function orbitalPointerMove(x, y) {
        gameState.mouseX = x;
        gameState.mouseY = y;
      }
      function orbitalPointerDown() {
        balls.forEach((ball) => {
          if (ball.orbiting) {
            ball.orbiting = false;
            const tS = Math.abs(ball.angleSpeed) * ball.distance * 2;
            ball.vx = Math.cos(ball.angle + Math.PI / 2) * tS + Math.cos(ball.angle) * 8;
            ball.vy = Math.sin(ball.angle + Math.PI / 2) * tS + Math.sin(ball.angle) * 8;
            capSpeed(ball);
          }
        });
      }

      // GAME 10: DEFEND
      function initDefend() {
        balls = [];
        gameState = {
          centerRadius: 80, // Start much smaller
          centerX: canvas.width / 2,
          centerY: canvas.height / 2,
          spawnTimer: 0,
          spawnDelay: 80,
          blackCircleImg: new Image(),
          pulse: 0,
          targetRadius: 40, // For smooth growth animation
        };
        gameState.blackCircleImg.src = "special/black-circle.png";
        for (let i = 0; i < 3; i++) spawnDefendBall();
      }

      function spawnDefendBall() {
        const side = Math.floor(Math.random() * 4);
        let x, y, vx, vy;
        switch (side) {
          case 0:
            x = Math.random() * canvas.width;
            y = -30;
            vx = (Math.random() - 0.5) * 1.5;
            vy = 0.8 + Math.random() * 0.5;
            break;
          case 1:
            x = canvas.width + 30;
            y = Math.random() * canvas.height;
            vx = -0.8 - Math.random() * 0.5;
            vy = (Math.random() - 0.5) * 1.5;
            break;
          case 2:
            x = Math.random() * canvas.width;
            y = canvas.height + 30;
            vx = (Math.random() - 0.5) * 1.5;
            vy = -0.8 - Math.random() * 0.5;
            break;
          case 3:
            x = -30;
            y = Math.random() * canvas.height;
            vx = 0.8 + Math.random() * 0.5;
            vy = (Math.random() - 0.5) * 1.5;
            break;
        }
        balls.push({
          x,
          y,
          vx,
          vy,
          radius: 25 + Math.random() * 15,
          ballImage: getNextBallImage(),
          personImage: getNextPersonImage(),
          isGuard: false,
          breached: false,
          breachProgress: 0,
          originalRadius: 0,
          originalX: 0,
          originalY: 0,
          stretchAngle: 0,
        });
      }

      function updateDefend() {
        gameState.spawnTimer++;
        gameState.pulse += 0.03;

        // Smooth radius growth animation
        if (gameState.centerRadius < gameState.targetRadius) {
          gameState.centerRadius += (gameState.targetRadius - gameState.centerRadius) * 0.08;
        }

        // Check if black hole has consumed the screen
        const maxRadius = Math.min(canvas.width, canvas.height) * 0.48;
        if (gameState.centerRadius >= maxRadius) {
          initDefend();
          return;
        }

        if (balls.length < 12 && gameState.spawnTimer >= gameState.spawnDelay) {
          spawnDefendBall();
          gameState.spawnTimer = 0;
        }

        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          const dx = gameState.centerX - ball.x;
          const dy = gameState.centerY - ball.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (ball.isGuard) {
            const patrolDist = gameState.centerRadius + 50;
            if (dist < patrolDist - 10) {
              ball.vx -= (dx / dist) * 0.15;
              ball.vy -= (dy / dist) * 0.15;
            } else if (dist > patrolDist + 10) {
              ball.vx += (dx / dist) * 0.15;
              ball.vy += (dy / dist) * 0.15;
            }
            // Orbit around center
            const perpX = -dy / dist,
              perpY = dx / dist;
            ball.vx += perpX * 0.08;
            ball.vy += perpY * 0.08;
            ball.vx *= 0.96;
            ball.vy *= 0.96;
            ball.x += ball.vx;
            ball.y += ball.vy;

            // Check for deflections
            for (let j = balls.length - 1; j >= 0; j--) {
              if (i === j || balls[j].isGuard || balls[j].breached) continue;
              const enemy = balls[j];
              const edx = enemy.x - ball.x;
              const edy = enemy.y - ball.y;
              const eDist = Math.sqrt(edx * edx + edy * edy);
              const hitDist = ball.radius + enemy.radius + 8;

              if (eDist < hitDist) {
                const ang = Math.atan2(edy, edx);
                const enemyDistToCenter = Math.sqrt(Math.pow(enemy.x - gameState.centerX, 2) + Math.pow(enemy.y - gameState.centerY, 2));
                // Closer to center = more dramatic save = bigger deflection
                const urgency = Math.max(1, 3 - enemyDistToCenter / gameState.centerRadius);
                const deflectPower = 6 * urgency;
                enemy.vx = Math.cos(ang) * deflectPower;
                enemy.vy = Math.sin(ang) * deflectPower;
                addScreenShake(4 * urgency);
              }
            }
          } else if (ball.breached) {
            // Being consumed - accelerate the pull and stretch toward center
            ball.breachProgress += 0.025;
            const ease = ball.breachProgress * ball.breachProgress; // Accelerate
            ball.radius = ball.originalRadius * (1 - ease * 0.95);

            // Yank toward center with increasing speed
            const pullStrength = 0.05 + ball.breachProgress * 0.15;
            ball.x += (gameState.centerX - ball.x) * pullStrength;
            ball.y += (gameState.centerY - ball.y) * pullStrength;

            if (ball.breachProgress >= 1) {
              // BLACK HOLE GROWS when consuming a ball!
              const growthAmount = ball.originalRadius * 0.8;
              gameState.targetRadius += growthAmount;
              addScreenShake(8);

              balls.splice(i, 1);
              continue;
            }
          } else {
            // GRAVITY: intensifies as ball gets closer
            const maxDist = 400;
            const normalizedDist = Math.min(dist, maxDist) / maxDist;
            const gravityStrength = 0.01 + (1 - normalizedDist) * 0.04; // Gets stronger near center

            ball.vx += (dx / dist) * gravityStrength;
            ball.vy += (dy / dist) * gravityStrength;

            // Add slight spiral (perpendicular force)
            const spiralStrength = (1 - normalizedDist) * 0.008;
            ball.vx += (-dy / dist) * spiralStrength;
            ball.vy += (dx / dist) * spiralStrength;

            ball.vx *= 0.995;
            ball.vy *= 0.995;
            ball.x += ball.vx;
            ball.y += ball.vy;

            // Breach check
            if (dist < gameState.centerRadius) {
              ball.breached = true;
              ball.breachProgress = 0;
              ball.originalRadius = ball.radius;
              ball.originalX = ball.x;
              ball.originalY = ball.y;
              ball.stretchAngle = Math.atan2(dy, dx);
              addScreenShake(10);
              continue;
            }

            if (ball.x < -100 || ball.x > canvas.width + 100 || ball.y < -100 || ball.y > canvas.height + 100) {
              balls.splice(i, 1);
              continue;
            }
          }

          // Wall bounces (not for breached balls)
          if (!ball.breached) {
            if (ball.x - ball.radius < 0) {
              ball.x = ball.radius;
              ball.vx *= -0.7;
            }
            if (ball.x + ball.radius > canvas.width) {
              ball.x = canvas.width - ball.radius;
              ball.vx *= -0.7;
            }
            if (ball.y - ball.radius < 0) {
              ball.y = ball.radius;
              ball.vy *= -0.7;
            }
            if (ball.y + ball.radius > canvas.height) {
              ball.y = canvas.height - ball.radius;
              ball.vy *= -0.7;
            }
          }
        }
      }

      function drawDefend() {
        // Subtle pulsing glow
        const pulseSize = Math.sin(gameState.pulse) * 5;
        const centerSize = gameState.centerRadius * 2.5 + pulseSize;

        // Outer ominous glow
        const gradient = ctx.createRadialGradient(
          gameState.centerX,
          gameState.centerY,
          gameState.centerRadius * 0.5,
          gameState.centerX,
          gameState.centerY,
          gameState.centerRadius * 1.8,
        );
        gradient.addColorStop(0, "rgba(0, 0, 0, 0.3)");
        gradient.addColorStop(0.7, "rgba(20, 0, 30, 0.1)");
        gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
        ctx.beginPath();
        ctx.arc(gameState.centerX, gameState.centerY, gameState.centerRadius * 1.8, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Black circle image
        safeDrawImage(
          gameState.blackCircleImg,
          gameState.centerX - centerSize / 2,
          gameState.centerY - centerSize / 2,
          centerSize,
          centerSize,
          0.85,
          0,
        );

        // Draw balls
        balls.forEach((ball) => {
          if (ball.isGuard) {
            drawPerson(ball.x, ball.y + ball.radius * 0.8, ball.radius * 2.2, ball.personImage);
            // Guard aura
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius + 12, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(100, 220, 120, 0.6)";
            ctx.lineWidth = 2;
            ctx.stroke();
          } else if (ball.breached) {
            // Spaghettification - stretch toward center
            ctx.save();
            ctx.translate(ball.x, ball.y);
            ctx.rotate(ball.stretchAngle + Math.PI);

            // Stretch increases as it's consumed
            const stretch = 1 + ball.breachProgress * 1.5;
            const squash = 1 / Math.sqrt(stretch);
            ctx.scale(squash, stretch);

            ctx.filter = `grayscale(${ball.breachProgress * 100}%) brightness(${1 - ball.breachProgress * 0.5})`;
            ctx.globalAlpha = 1 - ball.breachProgress * 0.8;

            ctx.translate(-ball.x, -ball.y);
            drawBall(ball, 1.0);
            ctx.restore();
          } else {
            // Slight red tint as balls get closer to danger
            const distToCenter = Math.sqrt(Math.pow(ball.x - gameState.centerX, 2) + Math.pow(ball.y - gameState.centerY, 2));
            const dangerZone = gameState.centerRadius * 2;
            if (distToCenter < dangerZone) {
              const danger = 1 - distToCenter / dangerZone;
              ctx.save();
              ctx.filter = `saturate(${1 + danger * 0.5})`;
              drawBall(ball, 1.0);
              ctx.restore();
            } else {
              drawBall(ball, 1.0);
            }
          }
        });
      }

      function defendPointerDown(x, y) {
        for (let i = balls.length - 1; i >= 0; i--) {
          if (!balls[i].breached && contains(balls[i], x, y)) {
            balls[i].isGuard = !balls[i].isGuard;
            break;
          }
        }
      }

      // GAME 11: CONNECTIONS - KO for bad, hearts for good (IMPROVED)

      function initConnections() {
        balls = [];
        gameState = {
          connections: [],
          firstEntity: null,
          hoveredEntity: null,
          score: 0,
          exploded: 0,
          particles: [],
          dyingEntities: [], // Track entities in death animation
        };

        for (let i = 0; i < 8; i++) {
          const a = Math.random() * Math.PI * 2,
            s = 1.5 + Math.random() * 1.5;
          balls.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: Math.cos(a) * s,
            vy: Math.sin(a) * s,
            radius: 25 + Math.random() * 15,
            ballImage: getNextBallImage(),
            type: "ball",
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.03,
            scale: 1,
            targetScale: 1,
          });
        }

        for (let i = 0; i < 8; i++) {
          const a = Math.random() * Math.PI * 2,
            s = 1 + Math.random();
          balls.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: Math.cos(a) * s,
            vy: Math.sin(a) * s,
            radius: 35,
            clickRadius: 50,
            personImage: getNextPersonImage(),
            type: "person",
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.02,
            scale: 1,
            targetScale: 1,
          });
        }
      }

      function updateConnections() {
        // Update particles
        gameState.particles = gameState.particles.filter((p) => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.15;
          p.life--;
          p.rotation += p.spin || 0;
          p.scale *= 0.98;
          return p.life > 0;
        });

        // Update dying entities
        gameState.dyingEntities = gameState.dyingEntities.filter((dying) => {
          dying.timer--;

          if (dying.timer <= 0) {
            // Move to next phase
            if (dying.phase === "red") {
              dying.phase = "grey";
              dying.timer = 25;
            } else if (dying.phase === "grey") {
              dying.phase = "explode";
              dying.timer = 1;
            } else if (dying.phase === "explode") {
              // Spawn KO particles
              const cx = (dying.entity1.x + dying.entity2.x) / 2;
              const cy = (dying.entity1.y + dying.entity2.y) / 2;

              addScreenShake(20);

              for (let j = 0; j < 5; j++) {
                const a = -Math.PI / 2 + (Math.random() - 0.5) * 1;
                const sp = 3 + Math.random() * 4;
                gameState.particles.push({
                  x: cx,
                  y: cy,
                  vx: Math.cos(a) * sp,
                  vy: Math.sin(a) * sp - 3,
                  size: 50 + Math.random() * 30,
                  life: 60,
                  maxLife: 60,
                  rotation: (Math.random() - 0.5) * 0.3,
                  spin: 0,
                  scale: 1,
                  type: "ko",
                });
              }

              // Remove connections involving these entities
              gameState.connections = gameState.connections.filter(
                (c) => c.entity1 !== dying.entity1 && c.entity2 !== dying.entity1 && c.entity1 !== dying.entity2 && c.entity2 !== dying.entity2,
              );

              // Remove the entities from balls array
              const idx1 = balls.indexOf(dying.entity1);
              const idx2 = balls.indexOf(dying.entity2);
              if (idx1 > idx2) {
                balls.splice(idx1, 1);
                balls.splice(idx2, 1);
              } else {
                balls.splice(idx2, 1);
                balls.splice(idx1, 1);
              }

              // Spawn replacements after delay
              setTimeout(() => {
                const a1 = Math.random() * Math.PI * 2;
                const a2 = Math.random() * Math.PI * 2;
                balls.push({
                  x: Math.random() * canvas.width,
                  y: Math.random() * canvas.height,
                  vx: Math.cos(a1) * 2,
                  vy: Math.sin(a1) * 2,
                  radius: 25 + Math.random() * 15,
                  ballImage: getNextBallImage(),
                  type: "ball",
                  rotation: Math.random() * Math.PI * 2,
                  rotationSpeed: (Math.random() - 0.5) * 0.03,
                  scale: 1,
                  targetScale: 1,
                });
                balls.push({
                  x: Math.random() * canvas.width,
                  y: Math.random() * canvas.height,
                  vx: Math.cos(a2) * 1.5,
                  vy: Math.sin(a2) * 1.5,
                  radius: 35,
                  clickRadius: 50,
                  personImage: getNextPersonImage(),
                  type: "person",
                  rotation: Math.random() * Math.PI * 2,
                  rotationSpeed: (Math.random() - 0.5) * 0.02,
                  scale: 1,
                  targetScale: 1,
                });
              }, 500);

              return false; // Remove from dyingEntities
            }
          }
          return true;
        });

        // Apply connection forces
        gameState.connections.forEach((conn) => {
          const b1 = conn.entity1,
            b2 = conn.entity2;
          if (!balls.includes(b1) || !balls.includes(b2)) return;

          const dx = b2.x - b1.x,
            dy = b2.y - b1.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const stretch = dist - conn.restLength;
          const force = stretch * 0.02;
          const fx = (dx / dist) * force,
            fy = (dy / dist) * force;

          b1.vx += fx;
          b1.vy += fy;
          b2.vx -= fx;
          b2.vy -= fy;
        });

        // Update ball positions and rotation
        balls.forEach((ball) => {
          // Check if this ball is dying
          const isDying = gameState.dyingEntities.some((d) => d.entity1 === ball || d.entity2 === ball);

          if (!isDying) {
            // Smooth scale interpolation for hover effect
            ball.scale += (ball.targetScale - ball.scale) * 0.15;

            // Always rotate
            ball.rotation += ball.rotationSpeed;
          }

          const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
          if (speed < 0.3) {
            const a = Math.atan2(ball.vy, ball.vx);
            ball.vx = Math.cos(a) * 0.8;
            ball.vy = Math.sin(a) * 0.8;
          }

          ball.vx *= 0.98;
          ball.vy *= 0.98;
          ball.x += ball.vx;
          ball.y += ball.vy;

          capSpeed(ball);

          // Boundary collision
          if (ball.x - ball.radius < 0) {
            ball.x = ball.radius;
            ball.vx *= -0.8;
          }
          if (ball.x + ball.radius > canvas.width) {
            ball.x = canvas.width - ball.radius;
            ball.vx *= -0.8;
          }
          if (ball.y - ball.radius < 0) {
            ball.y = ball.radius;
            ball.vy *= -0.8;
          }
          if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius;
            ball.vy *= -0.8;
          }
        });

        // Ball-to-ball collision
        for (let i = 0; i < balls.length; i++) {
          for (let j = i + 1; j < balls.length; j++) {
            const b1 = balls[i],
              b2 = balls[j];
            const dx = b2.x - b1.x,
              dy = b2.y - b1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const minDist = b1.radius + b2.radius;

            if (dist < minDist && dist > 0) {
              const ang = Math.atan2(dy, dx);
              const ax = (minDist - dist) * Math.cos(ang) * 0.05;
              const ay = (minDist - dist) * Math.sin(ang) * 0.05;
              b1.vx -= ax;
              b1.vy -= ay;
              b2.vx += ax;
              b2.vy += ay;
            }
          }
        }
      }

      function getEntityDeathState(entity) {
        for (const dying of gameState.dyingEntities) {
          if (dying.entity1 === entity || dying.entity2 === entity) {
            return dying;
          }
        }
        return null;
      }

      function drawConnections() {
        // Draw particles
        gameState.particles.forEach((p) => {
          ctx.save();
          ctx.globalAlpha = p.life / p.maxLife;
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rotation);
          ctx.scale(p.scale, p.scale);
          if (p.type === "heart") {
            safeDrawImage(heartImg, -p.size / 2, -p.size / 2, p.size, p.size, 1, 0);
          } else if (p.type === "ko") {
            safeDrawImage(koImg, -p.size / 2, -p.size / 2, p.size, p.size, 1, 0);
          }
          ctx.restore();
        });

        // Draw connection lines
        gameState.connections.forEach((conn) => {
          if (!balls.includes(conn.entity1) || !balls.includes(conn.entity2)) return;
          ctx.beginPath();
          ctx.moveTo(conn.entity1.x, conn.entity1.y);
          ctx.lineTo(conn.entity2.x, conn.entity2.y);
          ctx.strokeStyle = "rgba(100, 200, 100, 0.6)";
          ctx.lineWidth = 3;
          ctx.stroke();
        });

        // Draw entities
        balls.forEach((entity) => {
          const isSel = gameState.firstEntity === entity;
          const deathState = getEntityDeathState(entity);

          ctx.save();

          // Apply death effects via filter
          if (deathState) {
            if (deathState.phase === "red") {
              const pulse = Math.sin(deathState.timer * 0.3) * 0.3 + 0.7;
              ctx.filter = `saturate(2) sepia(1) hue-rotate(-50deg) brightness(${pulse})`;
            } else if (deathState.phase === "grey") {
              const fadeProgress = 1 - deathState.timer / 25;
              ctx.filter = `grayscale(1) opacity(${1 - fadeProgress * 0.7})`;
            }
          }

          // Apply scale transform around entity center
          const scale = entity.scale || 1;
          ctx.translate(entity.x, entity.y);
          ctx.scale(scale, scale);
          if (deathState && deathState.phase === "grey") {
            const fadeProgress = 1 - deathState.timer / 25;
            ctx.scale(1 - fadeProgress * 0.3, 1 - fadeProgress * 0.3);
          }
          ctx.translate(-entity.x, -entity.y);

          // Draw selection glow
          if (isSel && !deathState) {
            ctx.shadowColor = "rgba(100, 200, 255, 0.8)";
            ctx.shadowBlur = 20;
          }

          if (entity.type === "person") {
            drawPerson(entity.x, entity.y + 10, 55, entity.personImage);
          } else {
            drawBall(entity);
          }

          ctx.restore();
        });
      }

      function connectionsPointerMove(x, y) {
        mouseX = x;
        mouseY = y;

        // Reset all target scales
        balls.forEach((entity) => {
          entity.targetScale = 1;
        });

        gameState.hoveredEntity = null;

        for (let i = balls.length - 1; i >= 0; i--) {
          const entity = balls[i];

          // Skip dying entities
          if (getEntityDeathState(entity)) continue;

          const clickR = entity.clickRadius || entity.radius;
          const dx = x - entity.x,
            dy = y - entity.y;

          if (Math.sqrt(dx * dx + dy * dy) < clickR + 10) {
            gameState.hoveredEntity = entity;
            // Scale up on hover
            entity.targetScale = 1.25;
            break;
          }
        }
      }

      function connectionsPointerDown(x, y) {
        for (let i = balls.length - 1; i >= 0; i--) {
          const entity = balls[i];

          // Skip dying entities
          if (getEntityDeathState(entity)) continue;

          const clickR = entity.clickRadius || entity.radius;
          const dx = x - entity.x,
            dy = y - entity.y;

          if (Math.sqrt(dx * dx + dy * dy) < clickR + 10) {
            const clicked = entity;

            if (!gameState.firstEntity) {
              gameState.firstEntity = clicked;
              // Bump scale on select
              clicked.targetScale = 1.3;
            } else if (gameState.firstEntity !== clicked) {
              // Check if same type (BAD - trigger death animation)
              if (gameState.firstEntity.type === clicked.type) {
                gameState.exploded++;

                // Start death animation instead of immediate removal
                gameState.dyingEntities.push({
                  entity1: gameState.firstEntity,
                  entity2: clicked,
                  phase: "red",
                  timer: 30, // frames for red phase
                });
              } else {
                // Different types - create connection (GOOD)
                const existingConn = gameState.connections.find(
                  (c) =>
                    (c.entity1 === gameState.firstEntity && c.entity2 === clicked) || (c.entity2 === gameState.firstEntity && c.entity1 === clicked),
                );

                if (!existingConn) {
                  const dx = clicked.x - gameState.firstEntity.x;
                  const dy = clicked.y - gameState.firstEntity.y;
                  const dist = Math.sqrt(dx * dx + dy * dy);

                  gameState.connections.push({
                    entity1: gameState.firstEntity,
                    entity2: clicked,
                    restLength: Math.min(dist, 150),
                  });

                  gameState.score++;

                  // Heart particles
                  const cx = (gameState.firstEntity.x + clicked.x) / 2;
                  const cy = (gameState.firstEntity.y + clicked.y) / 2;

                  for (let j = 0; j < 8; j++) {
                    const a = Math.random() * Math.PI * 2;
                    const sp = 2 + Math.random() * 4;
                    gameState.particles.push({
                      x: cx,
                      y: cy,
                      vx: Math.cos(a) * sp,
                      vy: Math.sin(a) * sp - 2,
                      size: 30 + Math.random() * 20,
                      life: 50,
                      maxLife: 50,
                      rotation: Math.random() * Math.PI * 2,
                      spin: (Math.random() - 0.5) * 0.2,
                      scale: 1,
                      type: "heart",
                    });
                  }
                }
              }

              gameState.firstEntity = null;
            }
            return;
          }
        }

        gameState.firstEntity = null;
      }

      // GAME 12: MERGE & SPLIT (Modified)

      // Particle system for merge/split effects
      let mergeParticles = [];

      function spawnMergeParticles(x, y, count, isMerge) {
        for (let i = 0; i < count; i++) {
          const angle = ((Math.PI * 2) / count) * i + Math.random() * 0.5;
          const speed = 2 + Math.random() * 4;
          mergeParticles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            decay: 0.02 + Math.random() * 0.02,
            size: 8 + Math.random() * 12,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.2,
            image: starImages[Math.floor(Math.random() * starImages.length)],
          });
        }
      }

      function updateMergeParticles() {
        for (let i = mergeParticles.length - 1; i >= 0; i--) {
          const p = mergeParticles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.96;
          p.vy *= 0.96;
          p.vy += 0.05; // slight gravity
          p.life -= p.decay;
          p.rotation += p.rotationSpeed;
          if (p.life <= 0) {
            mergeParticles.splice(i, 1);
          }
        }
      }

      function drawMergeParticles() {
        mergeParticles.forEach((p) => {
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rotation);
          ctx.globalAlpha = p.life;
          ctx.drawImage(p.image, -p.size / 2, -p.size / 2, p.size, p.size);
          ctx.restore();
        });
        ctx.globalAlpha = 1;
      }

      function initMergeSplit() {
        balls = [];
        gameState = { mergingPairs: [], victory: false };
        mergeParticles = [];

        // Increased from 12 to 25 balls
        for (let i = 0; i < 25; i++) {
          const a = Math.random() * Math.PI * 2,
            s = 1 + Math.random() * 1.5,
            ball = {
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              vx: Math.cos(a) * s,
              vy: Math.sin(a) * s,
              radius: 30 + Math.random() * 12, // slightly smaller to fit more
              mass: 1,
              id: Date.now() + Math.random(),
              ballImage: getNextBallImage(),
              spinAngle: 0,
              merging: false,
              walkers: [],
            };
          ball.walkers.push({
            angle: Math.random() * Math.PI * 2,
            walkSpeed: 0.015 + Math.random() * 0.015,
            direction: Math.random() > 0.5 ? 1 : -1,
            personIndex: getNextPersonImage(),
          });
          balls.push(ball);
        }
      }

      function updateMergeSplit() {
        if (balls.length === 1 && !gameState.victory) {
          gameState.victory = true;
          addScreenShake(15);
          spawnMergeParticles(balls[0].x, balls[0].y, 30, true); // big celebration
        }

        // Update particles
        updateMergeParticles();

        for (let p = gameState.mergingPairs.length - 1; p >= 0; p--) {
          const pair = gameState.mergingPairs[p];
          pair.progress += 0.025;
          const b1 = pair.ball1,
            b2 = pair.ball2;
          if (!balls.includes(b1) || !balls.includes(b2)) {
            gameState.mergingPairs.splice(p, 1);
            continue;
          }
          const dx = b2.x - b1.x,
            dy = b2.y - b1.y,
            dist = Math.sqrt(dx * dx + dy * dy),
            pullF = 0.4;
          b1.vx += (dx / dist) * pullF;
          b1.vy += (dy / dist) * pullF;
          b2.vx -= (dx / dist) * pullF;
          b2.vy -= (dy / dist) * pullF;
          b1.spinAngle += 0.15;
          b2.spinAngle -= 0.15;
          if (pair.progress >= 1 || dist < 20) {
            const tM = b1.mass + b2.mass,
              nR = Math.sqrt(b1.radius * b1.radius + b2.radius * b2.radius),
              cW = [...b1.walkers, ...b2.walkers];
            cW.forEach((w, idx) => {
              w.angle = ((Math.PI * 2) / cW.length) * idx;
            });
            const mergeX = (b1.x * b1.mass + b2.x * b2.mass) / tM;
            const mergeY = (b1.y * b1.mass + b2.y * b2.mass) / tM;
            const newBall = {
              x: mergeX,
              y: mergeY,
              vx: (b1.vx * b1.mass + b2.vx * b2.mass) / tM,
              vy: (b1.vy * b1.mass + b2.vy * b2.mass) / tM,
              radius: nR,
              mass: tM,
              id: Date.now() + Math.random(),
              ballImage: getNextBallImage(),
              spinAngle: 0,
              merging: false,
              walkers: cW,
            };
            const i1 = balls.indexOf(b1),
              i2 = balls.indexOf(b2);
            if (i1 > i2) {
              balls.splice(i1, 1);
              balls.splice(i2, 1);
            } else {
              balls.splice(i2, 1);
              balls.splice(i1, 1);
            }
            balls.push(newBall);

            // Spawn particles on merge
            spawnMergeParticles(mergeX, mergeY, 12, true);

            addScreenShake(6);
            gameState.mergingPairs.splice(p, 1);
          }
        }
        balls.forEach((ball) => {
          if (ball.merging) return;
          ball.walkers.forEach((w) => {
            w.angle += w.walkSpeed * w.direction;
          });
          const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
          if (speed < 0.4) {
            const a = Math.atan2(ball.vy, ball.vx);
            ball.vx = Math.cos(a) * 0.8;
            ball.vy = Math.sin(a) * 0.8;
          }
          ball.vx *= 0.99;
          ball.vy *= 0.99;
          ball.x += ball.vx;
          ball.y += ball.vy;
          capSpeed(ball);
          if (ball.x - ball.radius < 0) {
            ball.x = ball.radius;
            ball.vx *= -0.8;
          }
          if (ball.x + ball.radius > canvas.width) {
            ball.x = canvas.width - ball.radius;
            ball.vx *= -0.8;
          }
          if (ball.y - ball.radius < 0) {
            ball.y = ball.radius;
            ball.vy *= -0.8;
          }
          if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius;
            ball.vy *= -0.8;
          }
        });
        for (let i = balls.length - 1; i >= 0; i--) {
          for (let j = i - 1; j >= 0; j--) {
            const b1 = balls[i],
              b2 = balls[j];
            if (b1.merging || b2.merging) continue;
            const dx = b2.x - b1.x,
              dy = b2.y - b1.y,
              dist = Math.sqrt(dx * dx + dy * dy),
              minDist = b1.radius + b2.radius;
            if (dist < minDist * 0.9) {
              const rVx = b2.vx - b1.vx,
                rVy = b2.vy - b1.vy,
                rS = Math.sqrt(rVx * rVx + rVy * rVy);
              if (rS < 2.5) {
                b1.merging = true;
                b2.merging = true;
                gameState.mergingPairs.push({
                  ball1: b1,
                  ball2: b2,
                  progress: 0,
                });
              } else {
                const ang = Math.atan2(dy, dx),
                  ax = (minDist - dist) * Math.cos(ang) * 0.1,
                  ay = (minDist - dist) * Math.sin(ang) * 0.1;
                b1.vx -= ax;
                b1.vy -= ay;
                b2.vx += ax;
                b2.vy += ay;
              }
            }
          }
        }
      }

      function drawMergeSplit() {
        balls.forEach((ball) => {
          ctx.save();
          if (ball.merging) {
            ctx.translate(ball.x, ball.y);
            ctx.rotate(ball.spinAngle);
            ctx.translate(-ball.x, -ball.y);
          }
          drawBall(ball);
          ctx.restore();
          const basePersonH = 40,
            sF = Math.sqrt(ball.mass),
            pH = Math.min(basePersonH * sF, ball.radius * 0.7);
          ball.walkers.forEach((w) => {
            const wX = ball.x + Math.cos(w.angle) * ball.radius,
              wY = ball.y + Math.sin(w.angle) * ball.radius,
              rot = w.angle + Math.PI / 2;
            drawPerson(wX, wY, pH, w.personIndex, 1.0, rot);
          });
          // Removed mass number display
        });

        // Draw particles
        drawMergeParticles();

        // Removed "Worlds: X" UI text

        if (gameState.victory) {
          ctx.fillStyle = "#4A4";
          ctx.font = "bold 32px Arial";
          ctx.textAlign = "center";
          ctx.fillText("together!", canvas.width / 2, 160);
        }
      }

      function mergeSplitPointerDown(x, y) {
        for (let i = balls.length - 1; i >= 0; i--) {
          if (contains(balls[i], x, y) && balls[i].mass > 1 && !balls[i].merging) {
            const ball = balls[i],
              numS = Math.min(ball.mass, 4),
              wPN = Math.floor(ball.walkers.length / numS);

            // Spawn particles on split
            spawnMergeParticles(ball.x, ball.y, 15, false);

            for (let j = 0; j < numS; j++) {
              const ang = ((Math.PI * 2) / numS) * j,
                sp = 3 + Math.random() * 2,
                nB = {
                  x: ball.x,
                  y: ball.y,
                  vx: Math.cos(ang) * sp,
                  vy: Math.sin(ang) * sp,
                  radius: ball.radius / Math.sqrt(numS),
                  mass: 1,
                  id: Date.now() + Math.random() + j,
                  ballImage: getNextBallImage(),
                  spinAngle: 0,
                  merging: false,
                  walkers: ball.walkers.slice(j * wPN, (j + 1) * wPN),
                };
              if (nB.walkers.length === 0)
                nB.walkers.push({
                  angle: Math.random() * Math.PI * 2,
                  walkSpeed: 0.015 + Math.random() * 0.015,
                  direction: Math.random() > 0.5 ? 1 : -1,
                  personIndex: getNextPersonImage(),
                });
              balls.push(nB);
            }
            balls.splice(i, 1);
            gameState.victory = false;
            addScreenShake(5);
            break;
          }
        }
      }

      // GAME 13: INFLATE/POP - better packing
      function initInflate() {
        balls = [];
        gameState = { popEffects: [], particles: [] };
        for (let i = 0; i < 30; i++)
          balls.push({
            x: 100 + Math.random() * (canvas.width - 200),
            y: 100 + Math.random() * (canvas.height - 200),
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            radius: 35,
            baseRadius: 35,
            maxRadius: 180,
            inflateProgress: 0,
            inflateSpeed: 0.8 + Math.random() * 0.08,
            ballImage: getNextBallImage(),
          });
      }
      function updateInflate() {
        gameState.popEffects = gameState.popEffects.filter((e) => {
          e.progress += 0.06;
          e.rotation += e.spinSpeed;
          return e.progress < 1;
        });
        gameState.particles = gameState.particles.filter((p) => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.12;
          p.life--;
          p.rotation += p.spin;
          return p.life > 0;
        });

        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          ball.inflateProgress += ball.inflateSpeed * 0.001;
          const tR = ball.baseRadius + ball.inflateProgress * (ball.maxRadius - ball.baseRadius);
          ball.radius = Math.min(tR, ball.maxRadius);
          ball.vx *= 0.85;
          ball.vy *= 0.85;
          ball.x += ball.vx;
          ball.y += ball.vy;
          if (ball.x - ball.radius < 0) {
            ball.x = ball.radius;
            ball.vx = 0;
          }
          if (ball.x + ball.radius > canvas.width) {
            ball.x = canvas.width - ball.radius;
            ball.vx = 0;
          }
          if (ball.y - ball.radius < 0) {
            ball.y = ball.radius;
            ball.vy = 0;
          }
          if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius;
            ball.vy = 0;
          }
        }

        // Gentler collision - limit max push per ball per frame
        for (let iter = 0; iter < 6; iter++) {
          for (let i = 0; i < balls.length; i++) {
            let totalDx = 0,
              totalDy = 0;
            for (let j = 0; j < balls.length; j++) {
              if (i === j) continue;
              const b1 = balls[i],
                b2 = balls[j],
                dx = b1.x - b2.x,
                dy = b1.y - b2.y,
                dist = Math.sqrt(dx * dx + dy * dy),
                minDist = b1.radius + b2.radius;
              if (dist < minDist && dist > 0) {
                const overlap = minDist - dist;
                const pushF = overlap * 0.15; // Much gentler
                totalDx += (dx / dist) * pushF;
                totalDy += (dy / dist) * pushF;
              }
            }
            // Cap maximum displacement per frame
            const maxMove = 3;
            const moveDist = Math.sqrt(totalDx * totalDx + totalDy * totalDy);
            if (moveDist > maxMove) {
              totalDx = (totalDx / moveDist) * maxMove;
              totalDy = (totalDy / moveDist) * maxMove;
            }
            balls[i].x += totalDx;
            balls[i].y += totalDy;
          }
        }

        // Re-clamp to walls after collision resolution
        for (let i = 0; i < balls.length; i++) {
          const ball = balls[i];
          if (ball.x - ball.radius < 0) ball.x = ball.radius;
          if (ball.x + ball.radius > canvas.width) ball.x = canvas.width - ball.radius;
          if (ball.y - ball.radius < 0) ball.y = ball.radius;
          if (ball.y + ball.radius > canvas.height) ball.y = canvas.height - ball.radius;
        }

        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          if (ball.radius >= ball.maxRadius * 0.5) {
            let severeOverlap = false;
            for (let j = 0; j < balls.length; j++) {
              if (i === j) continue;
              const b2 = balls[j],
                dx = b2.x - ball.x,
                dy = b2.y - ball.y,
                dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < (ball.radius + b2.radius) * 0.9) {
                severeOverlap = true;
                break;
              }
            }
            if (
              ball.x < ball.radius * 0.5 ||
              ball.x > canvas.width - ball.radius * 0.5 ||
              ball.y < ball.radius * 0.5 ||
              ball.y > canvas.height - ball.radius * 0.5
            ) {
              severeOverlap = true;
            }
            if (severeOverlap) {
              spawnInflatePopParticles(ball.x, ball.y, ball.radius);
              gameState.popEffects.push({
                x: ball.x,
                y: ball.y,
                radius: ball.radius,
                ballImage: ball.ballImage,
                progress: 0,
                rotation: 0,
                spinSpeed: (Math.random() - 0.5) * 0.5,
              });
              ball.radius = ball.baseRadius;
              ball.inflateProgress = 0;
              ball.x = 100 + Math.random() * (canvas.width - 200);
              ball.y = 100 + Math.random() * (canvas.height - 200);
              addScreenShake(8);
            }
          }
        }
      }
      function spawnInflatePopParticles(x, y, r) {
        for (let k = 0; k < 12; k++) {
          const a = Math.random() * Math.PI * 2;
          gameState.particles.push({
            x: x,
            y: y,
            vx: Math.cos(a) * (4 + Math.random() * 5),
            vy: Math.sin(a) * (4 + Math.random() * 5) - 3,
            life: 45,
            rotation: Math.random() * Math.PI * 2,
            spin: (Math.random() - 0.5) * 0.4,
            starImg: starImages[Math.floor(Math.random() * 3)],
            size: 20 + Math.random() * 15,
          });
        }
        for (let k = 0; k < 5; k++) {
          const a = Math.random() * Math.PI * 2;
          gameState.particles.push({
            x: x,
            y: y,
            vx: Math.cos(a) * (3 + Math.random() * 4),
            vy: Math.sin(a) * (3 + Math.random() * 4) - 4,
            life: 50,
            rotation: Math.random() * Math.PI * 2,
            spin: (Math.random() - 0.5) * 0.2,
            heartImg: true,
            size: 25 + Math.random() * 15,
          });
        }
      }
      function drawInflate() {
        gameState.particles.forEach((p) => {
          if (p.starImg) {
            safeDrawImage(p.starImg, p.x - p.size / 2, p.y - p.size / 2, p.size, p.size, p.life / 45, p.rotation);
          } else if (p.heartImg) {
            safeDrawImage(heartImg, p.x - p.size / 2, p.y - p.size / 2, p.size, p.size, p.life / 50, p.rotation);
          }
        });
        gameState.popEffects.forEach((e) => {
          const img = ballImages[e.ballImage - 1];
          if (img && img.complete && img.naturalWidth > 0) {
            ctx.save();
            ctx.globalAlpha = (1 - e.progress) * 0.8;
            ctx.translate(e.x, e.y);
            ctx.rotate(e.rotation * 3);
            const scale = 1 + e.progress * 2;
            ctx.scale(scale, scale * (1 - e.progress * 0.5));
            ctx.drawImage(img, -e.radius / 2, -e.radius / 2, e.radius, e.radius);
            ctx.restore();
          }
        });
        balls.forEach((ball) => {
          const pr = ball.radius / ball.maxRadius,
            wobble = pr > 0.8 ? Math.sin(Date.now() * 0.02) * (pr - 0.8) * 10 : 0;
          ctx.save();
          ctx.translate(ball.x, ball.y);
          ctx.scale(1 + wobble * 0.02, 1 - wobble * 0.02);
          ctx.translate(-ball.x, -ball.y);
          drawBall(ball);
          ctx.restore();
        });
      }
      function inflatePointerDown(x, y) {
        for (let i = balls.length - 1; i >= 0; i--) {
          if (contains(balls[i], x, y)) {
            const ball = balls[i];
            spawnInflatePopParticles(ball.x, ball.y, ball.radius);
            gameState.popEffects.push({
              x: ball.x,
              y: ball.y,
              radius: ball.radius,
              ballImage: ball.ballImage,
              progress: 0,
              rotation: 0,
              spinSpeed: (Math.random() - 0.5) * 0.6,
            });
            ball.radius = ball.baseRadius;
            ball.inflateProgress = 0;
            ball.x = 100 + Math.random() * (canvas.width - 200);
            ball.y = 100 + Math.random() * (canvas.height - 200);
            addScreenShake(6);
            break;
          }
        }
      }

      // GAME 14: BRUSH - very slow drift, slower on lines
      function initBrush() {
        balls = [];
        gameState = { paths: [], drawing: false, currentPath: [] };
        for (let i = 0; i < 20; i++)
          balls.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: (Math.random() - 0.5) * 0.1,
            vy: (Math.random() - 0.5) * 0.1,
            radius: 20 + Math.random() * 15,
            ballImage: getNextBallImage(),
            followingPath: null,
            pathProgress: 0,
            pathDirection: 1,
            driftAngle: Math.random() * Math.PI * 2,
            rotation: Math.random() * Math.PI * 2,
            pathSpeed: 0.003 + Math.random() * 0.001,
            speedPhase: Math.random() * Math.PI * 2,
          });
      }

      function updateBrush() {
        gameState.paths = gameState.paths.filter((path) => Date.now() - path.created < 8000);
        balls.forEach((ball) => {
          if (ball.followingPath && ball.followingPath.points) {
            const path = ball.followingPath;
            if (!gameState.paths.includes(path)) {
              ball.followingPath = null;
              ball.pathProgress = 0;
              return;
            }

            // Dynamic speed: base speed + oscillation + curve-based variation
            ball.speedPhase += 0.05;
            const oscillation = Math.sin(ball.speedPhase) * 0.003;

            // Calculate upcoming curvature to slow down on turns
            const totalPoints = path.isLoop ? path.points.length : path.points.length - 1;
            const lookAheadIdx = Math.floor(ball.pathProgress * totalPoints);
            const clampedLookAhead = Math.max(0, Math.min(path.points.length - 3, lookAheadIdx));
            let curveFactor = 1.0;
            if (clampedLookAhead < path.points.length - 2) {
              const p1 = path.points[clampedLookAhead];
              const p2 = path.points[clampedLookAhead + 1];
              const p3 = path.points[clampedLookAhead + 2];
              const angle1 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
              const angle2 = Math.atan2(p3.y - p2.y, p3.x - p2.x);
              let angleDiff = Math.abs(angle2 - angle1);
              if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
              curveFactor = 1.0 - angleDiff * 0.5; // Slow down on sharp turns
              curveFactor = Math.max(0.4, curveFactor);
            }

            const dynamicSpeed = (ball.pathSpeed + oscillation) * curveFactor;
            ball.pathProgress += dynamicSpeed * ball.pathDirection;

            if (path.isLoop) {
              // For looped paths, wrap around continuously
              if (ball.pathProgress >= 1) {
                ball.pathProgress -= 1;
              } else if (ball.pathProgress < 0) {
                ball.pathProgress += 1;
              }
            } else {
              // For non-looped paths, bounce back and forth
              if (ball.pathProgress >= 1) {
                ball.pathProgress = 1;
                ball.pathDirection = -1;
              } else if (ball.pathProgress <= 0) {
                ball.pathProgress = 0;
                ball.pathDirection = 1;
              }
            }

            const idx = Math.floor(ball.pathProgress * totalPoints);
            const clampedIdx = Math.max(0, Math.min(path.points.length - 1, idx));
            const nextIdx = path.isLoop ? (clampedIdx + 1) % path.points.length : Math.min(clampedIdx + 1, path.points.length - 1);
            const t = ball.pathProgress * totalPoints - idx;
            const targetX = path.points[clampedIdx].x + (path.points[nextIdx].x - path.points[clampedIdx].x) * t;
            const targetY = path.points[clampedIdx].y + (path.points[nextIdx].y - path.points[clampedIdx].y) * t;

            // Directly set position to be exactly on the path
            ball.x = targetX;
            ball.y = targetY;

            // Calculate rotation based on path direction and actual movement
            const dx = path.points[nextIdx].x - path.points[clampedIdx].x;
            const dy = path.points[nextIdx].y - path.points[clampedIdx].y;
            const targetRotation = Math.atan2(dy, dx);
            ball.rotation += (ball.pathDirection > 0 ? 1 : -1) * dynamicSpeed * 8;
            ball.vx = dx * 0.01 * ball.pathDirection;
            ball.vy = dy * 0.01 * ball.pathDirection;
          } else {
            for (const path of gameState.paths) {
              if (path.points.length < 2) continue;
              for (let i = 0; i < path.points.length; i++) {
                const pt = path.points[i],
                  dx = ball.x - pt.x,
                  dy = ball.y - pt.y,
                  dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < ball.radius + 20) {
                  ball.followingPath = path;
                  ball.pathProgress = i / (path.points.length - 1);
                  ball.pathDirection = 1;
                  ball.speedPhase = Math.random() * Math.PI * 2;
                  break;
                }
              }
              if (ball.followingPath) break;
            }
            if (!ball.followingPath) {
              ball.driftAngle += (Math.random() - 0.5) * 0.02;
              ball.vx += Math.cos(ball.driftAngle) * 0.003;
              ball.vy += Math.sin(ball.driftAngle) * 0.003;
              const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
              if (speed > 0.2) {
                ball.vx *= 0.2 / speed;
                ball.vy *= 0.2 / speed;
              }
              ball.rotation += 0.002;
            }
            ball.vx *= 0.99;
            ball.vy *= 0.99;
            ball.x += ball.vx;
            ball.y += ball.vy;
            capSpeed(ball);
            if (ball.x - ball.radius < 0) {
              ball.x = ball.radius;
              ball.vx *= -0.8;
              ball.driftAngle = Math.PI - ball.driftAngle;
            }
            if (ball.x + ball.radius > canvas.width) {
              ball.x = canvas.width - ball.radius;
              ball.vx *= -0.8;
              ball.driftAngle = Math.PI - ball.driftAngle;
            }
            if (ball.y - ball.radius < 0) {
              ball.y = ball.radius;
              ball.vy *= -0.8;
              ball.driftAngle = -ball.driftAngle;
            }
            if (ball.y + ball.radius > canvas.height) {
              ball.y = canvas.height - ball.radius;
              ball.vy *= -0.8;
              ball.driftAngle = -ball.driftAngle;
            }
          }
        });
        ballCollisions();
      }

      function drawBrush() {
        gameState.paths.forEach((path) => {
          if (path.points.length < 2) return;
          const age = Date.now() - path.created,
            op = Math.max(0, 1 - age / 8000);
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(path.points[0].x, path.points[0].y);
          for (let i = 1; i < path.points.length; i++) ctx.lineTo(path.points[i].x, path.points[i].y);
          // If it's a loop, close the path visually
          if (path.isLoop) ctx.closePath();
          ctx.strokeStyle = "rgba(100, 180, 255, " + op * 0.6 + ")";
          ctx.lineWidth = 8;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.stroke();
          ctx.restore();
        });
        if (gameState.drawing && gameState.currentPath.length > 1) {
          ctx.save();
          ctx.globalAlpha = 0.7;
          ctx.beginPath();
          ctx.moveTo(gameState.currentPath[0].x, gameState.currentPath[0].y);
          for (let i = 1; i < gameState.currentPath.length; i++) ctx.lineTo(gameState.currentPath[i].x, gameState.currentPath[i].y);
          ctx.strokeStyle = "rgba(100, 180, 255, 0.9)";
          ctx.lineWidth = 6;
          ctx.lineCap = "round";
          ctx.stroke();
          ctx.restore();
        }
        balls.forEach((ball) => {
          // No outline - just draw the ball directly
          drawBall(ball, 1.0, ball.rotation);
        });
      }

      function brushPointerDown(x, y) {
        gameState.drawing = true;
        gameState.currentPath = [{ x, y }];
      }
      function brushPointerMove(x, y) {
        if (gameState.drawing) {
          const lastPt = gameState.currentPath[gameState.currentPath.length - 1];
          if (Math.abs(x - lastPt.x) > 5 || Math.abs(y - lastPt.y) > 5) gameState.currentPath.push({ x, y });
        }
      }

      function brushPointerUp() {
        if (gameState.drawing && gameState.currentPath.length > 3) {
          // Check if path forms a loop (end point close to start point)
          const startPt = gameState.currentPath[0];
          const endPt = gameState.currentPath[gameState.currentPath.length - 1];
          const dx = endPt.x - startPt.x;
          const dy = endPt.y - startPt.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const isLoop = dist < 50; // If end is within 50px of start, it's a loop

          gameState.paths.push({
            points: [...gameState.currentPath],
            created: Date.now(),
            isLoop: isLoop,
          });
        }
        gameState.drawing = false;
        gameState.currentPath = [];
      }
      // GAME 15: PORTALS - Moving circle safe zone
      function initPortals() {
        balls = [];
        gameState = {
          portals: [],
          // Moving circle safe zone
          safeZone: {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 150,
            jumpTimer: 0,
            jumpInterval: 900, // Start at 15 seconds
            minJumpInterval: 300, // Speed up to 5 seconds minimum
            speedUpRate: 0.98, // Each jump gets slightly faster
          },
          // Ball spawning
          spawnTimer: 0,
          spawnInterval: 300,
        };

        // Start with 6 balls
        for (let i = 0; i < 6; i++) {
          spawnBall();
        }
      }

      function spawnBall() {
        // Spawn randomly across the canvas
        const padding = 50;
        balls.push({
          x: padding + Math.random() * (canvas.width - padding * 2),
          y: padding + Math.random() * (canvas.height - padding * 2),
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          radius: 25 + Math.random() * 15,
          ballImage: getNextBallImage(),
          portalCooldown: 0,
          grayscale: 0,
          scale: 1,
        });
      }

      function isInSafeZone(ball) {
        const sz = gameState.safeZone;
        const dx = ball.x - sz.x;
        const dy = ball.y - sz.y;
        return Math.sqrt(dx * dx + dy * dy) < sz.radius - ball.radius;
      }

      function isPointInSafeZone(x, y) {
        const sz = gameState.safeZone;
        const dx = x - sz.x;
        const dy = y - sz.y;
        return Math.sqrt(dx * dx + dy * dy) < sz.radius;
      }

      function updatePortals() {
        const sz = gameState.safeZone;

        // Jump to new position every X seconds (speeds up over time)
        sz.jumpTimer++;
        if (sz.jumpTimer >= sz.jumpInterval) {
          sz.jumpTimer = 0;
          // Jump to random position (with padding from edges)
          const padding = sz.radius + 50;
          sz.x = padding + Math.random() * (canvas.width - padding * 2);
          sz.y = padding + Math.random() * (canvas.height - padding * 2);
          addScreenShake(8);
          // Speed up for next time
          sz.jumpInterval = Math.max(sz.minJumpInterval, sz.jumpInterval * sz.speedUpRate);
        }

        // Spawn new balls occasionally
        gameState.spawnTimer++;
        if (gameState.spawnTimer >= gameState.spawnInterval && balls.length < 10) {
          spawnBall();
          gameState.spawnTimer = 0;
        }

        // Update balls
        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          const inZone = isInSafeZone(ball);

          // Apply movement
          ball.vx *= 0.99;
          ball.vy *= 0.99;

          // Minimum speed
          const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
          if (speed < 0.5) {
            const a = Math.atan2(ball.vy, ball.vx);
            ball.vx = Math.cos(a) * 1;
            ball.vy = Math.sin(a) * 1;
          }

          ball.x += ball.vx;
          ball.y += ball.vy;
          capSpeed(ball);

          // If in zone, constrain to safe zone (can't escape)
          if (inZone) {
            const dx = ball.x - sz.x;
            const dy = ball.y - sz.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const maxDist = sz.radius - ball.radius - 5;

            if (dist > maxDist) {
              // Push back inside and bounce
              const nx = dx / dist;
              const ny = dy / dist;
              ball.x = sz.x + nx * maxDist;
              ball.y = sz.y + ny * maxDist;

              // Reflect velocity
              const dot = ball.vx * nx + ball.vy * ny;
              ball.vx -= 2 * dot * nx;
              ball.vy -= 2 * dot * ny;
              ball.vx *= 0.8;
              ball.vy *= 0.8;
            }
            // Balls do NOT move with the circle - they stay put!
          }

          // Canvas boundary collision
          if (ball.x - ball.radius < 0) {
            ball.x = ball.radius;
            ball.vx *= -0.9;
          }
          if (ball.x + ball.radius > canvas.width) {
            ball.x = canvas.width - ball.radius;
            ball.vx *= -0.9;
          }
          if (ball.y - ball.radius < 0) {
            ball.y = ball.radius;
            ball.vy *= -0.9;
          }
          if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius;
            ball.vy *= -0.9;
          }

          if (ball.portalCooldown > 0) ball.portalCooldown--;

          // Grayscale and scale based on zone
          if (inZone) {
            ball.grayscale = Math.max(0, ball.grayscale - 0.05);
            ball.scale = Math.min(1, ball.scale + 0.03);
          } else {
            ball.grayscale = Math.min(1, ball.grayscale + 0.0015);
            ball.scale = Math.max(0, ball.scale - 0.0008);
          }

          // Remove ball if fully faded
          if (ball.scale <= 0.1 && ball.grayscale >= 0.95) {
            balls.splice(i, 1);
            continue;
          }

          // Portal teleportation
          gameState.portals.forEach((portal) => {
            if (!portal.exit) return;
            const dx = ball.x - portal.entrance.x;
            const dy = ball.y - portal.entrance.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 45 && ball.portalCooldown === 0) {
              ball.x = portal.exit.x;
              ball.y = portal.exit.y;
              ball.portalCooldown = 60;
              addScreenShake(3);
            }
          });
        }

        ballCollisions();
      }

      function drawPortals() {
        const sz = gameState.safeZone;
        const time = Date.now() * 0.002;

        // Calculate warning state (last 2 seconds before jump)
        const warningTime = 120; // 2 seconds
        const timeUntilJump = sz.jumpInterval - sz.jumpTimer;
        const isWarning = timeUntilJump < warningTime;
        const warningIntensity = isWarning ? 1 - timeUntilJump / warningTime : 0;

        // Draw safe zone circle
        const grad = ctx.createRadialGradient(sz.x, sz.y, 0, sz.x, sz.y, sz.radius);

        if (isWarning) {
          // Flashing warning - more red as jump approaches
          const flash = Math.sin(time * 10 * (1 + warningIntensity)) * 0.5 + 0.5;
          const r = 255;
          const g = Math.floor(215 - warningIntensity * 150);
          const b = Math.floor(warningIntensity * 100 * flash);
          grad.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${0.3 + warningIntensity * 0.2})`);
          grad.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, 0.15)`);
          grad.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.05)`);
        } else {
          grad.addColorStop(0, "rgba(255, 215, 0, 0.3)");
          grad.addColorStop(0.7, "rgba(255, 215, 0, 0.15)");
          grad.addColorStop(1, "rgba(255, 215, 0, 0.05)");
        }

        ctx.beginPath();
        ctx.arc(sz.x, sz.y, sz.radius, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();

        // Glowing border
        ctx.strokeStyle = isWarning ? `rgba(255, ${150 - warningIntensity * 100}, 0, ${0.6 + warningIntensity * 0.4})` : "rgba(255, 200, 0, 0.6)";
        ctx.lineWidth = isWarning ? 4 + warningIntensity * 4 : 4;
        ctx.stroke();

        // Pulsing inner ring
        const pulse = 1 + Math.sin(time * 2) * 0.05;
        ctx.beginPath();
        ctx.arc(sz.x, sz.y, sz.radius * 0.8 * pulse, 0, Math.PI * 2);
        ctx.strokeStyle = isWarning ? `rgba(255, ${200 - warningIntensity * 150}, 100, ${0.2 + warningIntensity * 0.3})` : "rgba(255, 220, 100, 0.2)";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw portals (both as stars)
        gameState.portals.forEach((portal) => {
          const ent = portal.entrance;
          const pulse = 1 + Math.sin(time) * 0.1;
          const size = 70 * pulse;

          // Entrance (star, outside zone - reddish tint)
          const entranceGrad = ctx.createRadialGradient(ent.x, ent.y, 0, ent.x, ent.y, size);
          entranceGrad.addColorStop(0, "rgba(255, 150, 100, 0.4)");
          entranceGrad.addColorStop(1, "rgba(255, 150, 100, 0)");
          ctx.beginPath();
          ctx.arc(ent.x, ent.y, size, 0, Math.PI * 2);
          ctx.fillStyle = entranceGrad;
          ctx.fill();
          safeDrawImage(starImages[1] || starImages[0], ent.x - size / 2, ent.y - size / 2, size, size, 1, time * 0.5);

          // Exit (star, inside zone - golden)
          if (portal.exit) {
            const exit = portal.exit;
            const exitGrad = ctx.createRadialGradient(exit.x, exit.y, 0, exit.x, exit.y, size);
            exitGrad.addColorStop(0, "rgba(255, 215, 0, 0.4)");
            exitGrad.addColorStop(1, "rgba(255, 215, 0, 0)");
            ctx.beginPath();
            ctx.arc(exit.x, exit.y, size, 0, Math.PI * 2);
            ctx.fillStyle = exitGrad;
            ctx.fill();
            safeDrawImage(starImages[0], exit.x - size / 2, exit.y - size / 2, size, size, 1, -time * 0.5);

            // Draw connecting line between portals
            ctx.beginPath();
            ctx.moveTo(ent.x, ent.y);
            ctx.lineTo(exit.x, exit.y);
            ctx.strokeStyle = "rgba(255, 200, 100, 0.2)";
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);
            ctx.stroke();
            ctx.setLineDash([]);
          }
        });

        // Draw balls
        balls.forEach((ball) => {
          const inZone = isInSafeZone(ball);
          ctx.save();
          if (ball.grayscale > 0) {
            ctx.filter = `grayscale(${ball.grayscale * 100}%) brightness(${1 - ball.grayscale * 0.3})`;
          }
          ctx.globalAlpha = Math.max(0.1, ball.scale);
          ctx.translate(ball.x, ball.y);
          ctx.scale(ball.scale, ball.scale);
          ctx.translate(-ball.x, -ball.y);
          drawBall(ball, inZone ? 1.0 : 0.7);
          ctx.filter = "none";
          ctx.globalAlpha = 1;
          ctx.restore();
        });
      }

      function portalPointerDown(x, y) {
        const inZone = isPointInSafeZone(x, y);

        // Check if click is too close to any ball
        const tooCloseToball = balls.some((ball) => {
          const dx = x - ball.x;
          const dy = y - ball.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          return dist < ball.radius + 20; // Must be at least 60px away from any ball
        });

        if (!inZone) {
          // Placing entrance - can't be too close to balls
          if (tooCloseToball) {
            return; // Too close to a ball, do nothing
          }
          // Create new portal entrance
          gameState.portals = [];
          gameState.portals.push({ entrance: { x, y }, exit: null });
        } else {
          // Clicking inside = set exit for existing portal
          const lastP = gameState.portals[gameState.portals.length - 1];
          if (lastP && !lastP.exit) {
            lastP.exit = { x, y };
          }
        }
      }

      //  WHEELBALL - Click to Grow Wheels
      function initWheelball() {
        balls = [];

        gameState = {
          wheels: [],
          voids: [],
          stars: [],

          gravity: 0.12,
          score: 0,
          highScore: 0,
          particles: [],
          starImages: [],
          spawnTimer: 0,

          // Track which wheel is being held
          activeWheel: null,
        };

        // Load star images
        gameState.starImages = [new Image(), new Image(), new Image()];
        gameState.starImages[0].src = "particles/stars/star_1.png";
        gameState.starImages[1].src = "particles/stars/star_2.png";
        gameState.starImages[2].src = "particles/stars/star_3.png";

        createWheels();
        createVoids();
        createStars();
      }

      function createWheels() {
        const configs = [
          { x: 0.15, y: 0.2, baseSize: 45, spinDir: 1 },
          { x: 0.85, y: 0.2, baseSize: 45, spinDir: -1 },
          { x: 0.1, y: 0.48, baseSize: 42, spinDir: -1 },
          { x: 0.9, y: 0.48, baseSize: 42, spinDir: 1 },
          { x: 0.25, y: 0.68, baseSize: 50, spinDir: 1 },
          { x: 0.75, y: 0.68, baseSize: 50, spinDir: -1 },
          { x: 0.5, y: 0.35, baseSize: 55, spinDir: 1 },
          { x: 0.5, y: 0.58, baseSize: 48, spinDir: -1 },
        ];

        configs.forEach((cfg) => {
          gameState.wheels.push({
            x: canvas.width * cfg.x,
            y: canvas.height * cfg.y,
            baseSize: cfg.baseSize,
            size: cfg.baseSize,
            maxSize: cfg.baseSize * 2.2,
            rotation: Math.random() * Math.PI * 2,
            spinDir: cfg.spinDir, // 1 = clockwise, -1 = counter-clockwise
            spinSpeed: 0.015 * cfg.spinDir,
            ballImage: getNextBallImage(),
            vx: (Math.random() - 0.5) * 0.2,
            vy: (Math.random() - 0.5) * 0.2,
            baseX: cfg.x,
            baseY: cfg.y,
            hitFlash: 0,
            isHeld: false,
          });
        });
      }

      function createVoids() {
        const voidPositions = [
          { x: 0.06, y: 0.08, r: 35, moves: true, speed: 0.25 },
          { x: 0.94, y: 0.08, r: 35, moves: true, speed: 0.3 },
          { x: 0.1, y: 0.92, r: 40, moves: false },
          { x: 0.5, y: 0.94, r: 35, moves: false },
          { x: 0.9, y: 0.92, r: 40, moves: false },
        ];

        voidPositions.forEach((v) => {
          gameState.voids.push({
            x: canvas.width * v.x,
            y: canvas.height * v.y,
            radius: v.r,
            baseX: canvas.width * v.x,
            baseY: canvas.height * v.y,
            moves: v.moves,
            speed: v.speed || 0,
            phase: Math.random() * Math.PI * 2,
            pulsePhase: Math.random() * Math.PI * 2,
          });
        });
      }

      function createStars() {
        const starPositions = [
          { x: 0.35, y: 0.15 },
          { x: 0.65, y: 0.15 },
          { x: 0.18, y: 0.35 },
          { x: 0.82, y: 0.35 },
          { x: 0.35, y: 0.5 },
          { x: 0.65, y: 0.5 },
          { x: 0.3, y: 0.8 },
          { x: 0.7, y: 0.8 },
        ];

        starPositions.forEach((s) => {
          gameState.stars.push({
            x: canvas.width * s.x,
            y: canvas.height * s.y,
            baseX: canvas.width * s.x,
            baseY: canvas.height * s.y,
            radius: 26,
            starType: Math.floor(Math.random() * 3),
            pulse: Math.random() * Math.PI * 2,
            collected: false,
            respawnTimer: 0,
          });
        });
      }

      function resizeWheelball() {
        if (!gameState) return;

        const wheelPositions = [
          { x: 0.15, y: 0.2 },
          { x: 0.85, y: 0.2 },
          { x: 0.1, y: 0.48 },
          { x: 0.9, y: 0.48 },
          { x: 0.25, y: 0.68 },
          { x: 0.75, y: 0.68 },
          { x: 0.5, y: 0.35 },
          { x: 0.5, y: 0.58 },
        ];
        gameState.wheels.forEach((w, i) => {
          if (wheelPositions[i]) {
            w.x = canvas.width * wheelPositions[i].x;
            w.y = canvas.height * wheelPositions[i].y;
            w.baseX = wheelPositions[i].x;
            w.baseY = wheelPositions[i].y;
          }
        });

        const voidPositions = [
          { x: 0.06, y: 0.08 },
          { x: 0.94, y: 0.08 },
          { x: 0.1, y: 0.92 },
          { x: 0.5, y: 0.94 },
          { x: 0.9, y: 0.92 },
        ];
        gameState.voids.forEach((v, i) => {
          if (voidPositions[i]) {
            v.baseX = canvas.width * voidPositions[i].x;
            v.baseY = canvas.height * voidPositions[i].y;
            if (!v.moves) {
              v.x = v.baseX;
              v.y = v.baseY;
            }
          }
        });

        const starPositions = [
          { x: 0.35, y: 0.15 },
          { x: 0.65, y: 0.15 },
          { x: 0.18, y: 0.35 },
          { x: 0.82, y: 0.35 },
          { x: 0.35, y: 0.5 },
          { x: 0.65, y: 0.5 },
          { x: 0.3, y: 0.8 },
          { x: 0.7, y: 0.8 },
        ];
        gameState.stars.forEach((s, i) => {
          if (starPositions[i]) {
            s.baseX = canvas.width * starPositions[i].x;
            s.baseY = canvas.height * starPositions[i].y;
            s.x = s.baseX;
            s.y = s.baseY;
          }
        });
      }

      // ============================================================================
      // PARTICLES
      // ============================================================================

      function spawnStarBurst(x, y, count) {
        for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i) / count + Math.random() * 0.3;
          const speed = 5 + Math.random() * 6;
          gameState.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 50 + Math.random() * 20,
            maxLife: 70,
            type: "star",
            starImg: gameState.starImages[Math.floor(Math.random() * 3)],
            size: 18 + Math.random() * 22,
            rotation: Math.random() * Math.PI * 2,
            spin: (Math.random() - 0.5) * 0.2,
          });
        }
      }

      function spawnHitParticles(x, y, count) {
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 3 + Math.random() * 5;
          gameState.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 25 + Math.random() * 15,
            maxLife: 40,
            type: "dot",
            size: 3 + Math.random() * 4,
          });
        }
      }

      function spawnScorePopup(x, y, text, big) {
        gameState.particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 2,
          vy: -2.5,
          life: big ? 75 : 50,
          maxLife: big ? 75 : 50,
          type: "score",
          text: text,
          big: big,
        });
      }

      // ============================================================================
      // WHEEL COLLISION
      // ============================================================================

      function collideBallWithWheel(ball, wheel) {
        const dx = ball.x - wheel.x;
        const dy = ball.y - wheel.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const collisionDist = ball.radius + wheel.size * 0.55;

        if (dist < collisionDist && dist > 0) {
          const nx = dx / dist;
          const ny = dy / dist;

          // Push ball out
          ball.x = wheel.x + nx * (collisionDist + 2);
          ball.y = wheel.y + ny * (collisionDist + 2);

          // Tangent based on wheel's fixed spin direction
          const tangentX = -ny * wheel.spinDir;
          const tangentY = nx * wheel.spinDir;

          // Push strength scales with wheel size!
          const sizeRatio = wheel.size / wheel.baseSize;
          const spinPower = Math.abs(wheel.spinSpeed) * 300 * sizeRatio;
          const basePush = 6 + sizeRatio * 4;

          ball.vx = nx * basePush + tangentX * spinPower;
          ball.vy = ny * basePush + tangentY * spinPower;

          // Visual feedback
          wheel.hitFlash = 1;
          spawnHitParticles(wheel.x + nx * wheel.size * 0.5, wheel.y + ny * wheel.size * 0.5, 8);

          // More points for bigger wheels
          const points = Math.round(5 + (sizeRatio - 1) * 15);
          gameState.score += points;
          spawnScorePopup(wheel.x, wheel.y - wheel.size * 0.7, "+" + points, sizeRatio > 1.5);
          addScreenShake(2 + sizeRatio * 2);

          capSpeed(ball);
          return true;
        }
        return false;
      }

      // ============================================================================
      // UPDATE
      // ============================================================================

      function updateWheelball() {
        // Spawn ball
        if (balls.length === 0) {
          gameState.spawnTimer++;
          if (gameState.spawnTimer > 50) {
            balls.push({
              x: canvas.width / 2 + (Math.random() - 0.5) * 120,
              y: canvas.height * 0.12,
              vx: (Math.random() - 0.5) * 4,
              vy: 2,
              radius: 32,
              ballImage: getNextBallImage(),
            });
            gameState.spawnTimer = 0;
          }
        }

        // Update particles
        gameState.particles = gameState.particles.filter((p) => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.12;
          p.life--;
          if (p.rotation !== undefined) p.rotation += p.spin || 0;
          return p.life > 0;
        });

        // Update wheels
        gameState.wheels.forEach((wheel) => {
          // Grow if held, shrink if not
          if (wheel.isHeld) {
            wheel.size = Math.min(wheel.maxSize, wheel.size + 5);
            // Spin faster when held
            wheel.spinSpeed = 0.08 * wheel.spinDir;
          } else {
            wheel.size = Math.max(wheel.baseSize, wheel.size - 0.8);
            // Normal spin speed
            wheel.spinSpeed += (0.015 * wheel.spinDir - wheel.spinSpeed) * 0.05;
          }

          // Rotate
          wheel.rotation += wheel.spinSpeed;

          // Hit flash decay
          if (wheel.hitFlash > 0) wheel.hitFlash -= 0.06;

          // Gentle drift
          wheel.x += wheel.vx;
          wheel.y += wheel.vy;

          // Bounce off walls
          const margin = wheel.maxSize * 0.8;
          if (wheel.x < margin) {
            wheel.x = margin;
            wheel.vx = Math.abs(wheel.vx);
          }
          if (wheel.x > canvas.width - margin) {
            wheel.x = canvas.width - margin;
            wheel.vx = -Math.abs(wheel.vx);
          }
          if (wheel.y < margin) {
            wheel.y = margin;
            wheel.vy = Math.abs(wheel.vy);
          }
          if (wheel.y > canvas.height - margin) {
            wheel.y = canvas.height - margin;
            wheel.vy = -Math.abs(wheel.vy);
          }

          // Random drift
          if (Math.random() < 0.01) {
            wheel.vx += (Math.random() - 0.5) * 0.06;
            wheel.vy += (Math.random() - 0.5) * 0.06;
            wheel.vx = Math.max(-0.3, Math.min(0.3, wheel.vx));
            wheel.vy = Math.max(-0.3, Math.min(0.3, wheel.vy));
          }
        });

        // Update voids
        gameState.voids.forEach((v) => {
          v.pulsePhase += 0.04;
          if (v.moves) {
            v.phase += 0.012 * v.speed;
            v.x = v.baseX + Math.sin(v.phase) * 55;
            v.y = v.baseY + Math.cos(v.phase * 0.7) * 30;
          }
        });

        // Update stars
        gameState.stars.forEach((s) => {
          s.pulse += 0.07;
          if (s.collected) {
            s.respawnTimer--;
            if (s.respawnTimer <= 0) {
              s.collected = false;
              s.starType = Math.floor(Math.random() * 3);
            }
          }
        });

        // Update balls
        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];

          ball.vy += gameState.gravity;

          const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
          const substeps = Math.max(1, Math.ceil(speed / 12));

          for (let s = 0; s < substeps; s++) {
            ball.x += ball.vx / substeps;
            ball.y += ball.vy / substeps;

            gameState.wheels.forEach((wheel) => {
              collideBallWithWheel(ball, wheel);
            });
          }

          ball.vx *= 0.997;
          ball.vy *= 0.997;
          capSpeed(ball);

          // Wall bounces
          const wallBounce = 0.65;
          const wallPush = 1.5;

          if (ball.x - ball.radius < 0) {
            ball.x = ball.radius + 1;
            ball.vx = Math.abs(ball.vx) * wallBounce + wallPush;
          }
          if (ball.x + ball.radius > canvas.width) {
            ball.x = canvas.width - ball.radius - 1;
            ball.vx = -Math.abs(ball.vx) * wallBounce - wallPush;
          }
          if (ball.y - ball.radius < 0) {
            ball.y = ball.radius + 1;
            ball.vy = Math.abs(ball.vy) * wallBounce + wallPush;
          }
          if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius - 1;
            ball.vy = -Math.abs(ball.vy) * wallBounce - wallPush;
          }

          // Star collection
          gameState.stars.forEach((star) => {
            if (star.collected) return;
            const dx = ball.x - star.x;
            const dy = ball.y - star.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < ball.radius + star.radius) {
              star.collected = true;
              star.respawnTimer = 150;

              gameState.score += 50;
              spawnScorePopup(star.x, star.y - 30, "+50", true);
              spawnStarBurst(star.x, star.y, 12);
              addScreenShake(6);
            }
          });

          // VOID COLLISION - DEATH
          for (const v of gameState.voids) {
            const dx = ball.x - v.x;
            const dy = ball.y - v.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const pulseRadius = v.radius + Math.sin(v.pulsePhase) * 4;

            if (dist < pulseRadius + ball.radius * 0.4) {
              balls.splice(i, 1);

              if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
              }
              gameState.score = 0;

              for (let j = 0; j < 18; j++) {
                const angle = (Math.PI * 2 * j) / 18;
                gameState.particles.push({
                  x: v.x,
                  y: v.y,
                  vx: Math.cos(angle) * (4 + Math.random() * 4),
                  vy: Math.sin(angle) * (4 + Math.random() * 4),
                  life: 40,
                  maxLife: 40,
                  type: "dot",
                  size: 5,
                });
              }

              addScreenShake(12);
              break;
            }

            // Suction
            if (dist < pulseRadius * 2.5 && dist > 0) {
              const suctionStrength = 0.6 * (1 - dist / (pulseRadius * 2.5));
              ball.vx -= (dx / dist) * suctionStrength;
              ball.vy -= (dy / dist) * suctionStrength;
            }
          }
        }
      }

      // ============================================================================
      // DRAW
      // ============================================================================

      function drawWheelball() {
        // Clean white background
        ctx.fillStyle = "#FAFAFA";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Voids - dark holes
        gameState.voids.forEach((v) => {
          const pulseRadius = v.radius + Math.sin(v.pulsePhase) * 4;

          // Outer danger ring
          ctx.strokeStyle = "rgba(0, 0, 0, 0.15)";
          ctx.lineWidth = 1;
          ctx.setLineDash([4, 8]);
          ctx.beginPath();
          ctx.arc(v.x, v.y, pulseRadius * 2, 0, Math.PI * 2);
          ctx.stroke();
          ctx.setLineDash([]);

          // The void
          ctx.fillStyle = "#111";
          ctx.beginPath();
          ctx.arc(v.x, v.y, pulseRadius, 0, Math.PI * 2);
          ctx.fill();

          // Inner ring
          ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(v.x, v.y, pulseRadius * 0.4, 0, Math.PI * 2);
          ctx.stroke();
        });

        // Stars
        gameState.stars.forEach((star) => {
          if (star.collected) return;

          const pulseScale = 1 + Math.sin(star.pulse) * 0.15;
          const size = star.radius * 2 * pulseScale;

          // Subtle glow
          const glow = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, size);
          glow.addColorStop(0, "rgba(255, 220, 100, 0.3)");
          glow.addColorStop(1, "rgba(255, 220, 100, 0)");
          ctx.fillStyle = glow;
          ctx.beginPath();
          ctx.arc(star.x, star.y, size, 0, Math.PI * 2);
          ctx.fill();

          const img = gameState.starImages[star.starType];
          if (img && img.complete && img.naturalWidth > 0) {
            ctx.save();
            ctx.translate(star.x, star.y);
            ctx.rotate(star.pulse * 0.15);
            ctx.drawImage(img, -size / 2, -size / 2, size, size);
            ctx.restore();
          }
        });

        // Wheels
        gameState.wheels.forEach((wheel) => {
          const sizeRatio = wheel.size / wheel.baseSize;

          ctx.save();
          ctx.translate(wheel.x, wheel.y);

          // Outer ring - thicker when bigger
          ctx.strokeStyle = wheel.isHeld ? "rgba(0, 0, 0, 0.7)" : "rgba(0, 0, 0, 0.3)";
          ctx.lineWidth = 2 + sizeRatio;
          ctx.beginPath();
          ctx.arc(0, 0, wheel.size * 0.55, 0, Math.PI * 2);
          ctx.stroke();

          // Hit flash
          if (wheel.hitFlash > 0) {
            ctx.strokeStyle = `rgba(0, 0, 0, ${wheel.hitFlash * 0.5})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, wheel.size * 0.65, 0, Math.PI * 2);
            ctx.stroke();
          }

          // Rotating spokes
          ctx.rotate(wheel.rotation);
          ctx.strokeStyle = wheel.isHeld ? "rgba(0, 0, 0, 0.5)" : "rgba(0, 0, 0, 0.25)";
          ctx.lineWidth = 2 + sizeRatio;
          for (let i = 0; i < 4; i++) {
            const angle = (Math.PI * 2 * i) / 4;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(angle) * wheel.size * 0.5, Math.sin(angle) * wheel.size * 0.5);
            ctx.stroke();
          }

          // Direction indicator arrows at spoke ends
          ctx.fillStyle = wheel.isHeld ? "rgba(0, 0, 0, 0.6)" : "rgba(0, 0, 0, 0.3)";
          for (let i = 0; i < 4; i++) {
            const angle = (Math.PI * 2 * i) / 4;
            ctx.save();
            ctx.rotate(angle);
            ctx.translate(wheel.size * 0.45, 0);
            ctx.rotate(wheel.spinDir > 0 ? Math.PI / 2 : -Math.PI / 2);
            ctx.beginPath();
            ctx.moveTo(0, -4 * sizeRatio);
            ctx.lineTo(4 * sizeRatio, 3 * sizeRatio);
            ctx.lineTo(-4 * sizeRatio, 3 * sizeRatio);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }

          ctx.restore();

          // Ball image as center hub (doesn't rotate)
          const img = ballImages[wheel.ballImage - 1];
          const hubSize = wheel.size * 0.7;
          if (img && img.complete && img.naturalWidth > 0) {
            ctx.drawImage(img, wheel.x - hubSize / 2, wheel.y - hubSize / 2, hubSize, hubSize);
          }
        });

        // Particles
        gameState.particles.forEach((p) => {
          const alpha = p.life / p.maxLife;

          if (p.type === "star" && p.starImg) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation);
            ctx.drawImage(p.starImg, -p.size / 2, -p.size / 2, p.size, p.size);
            ctx.restore();
          } else if (p.type === "score") {
            const size = p.big ? 26 : 18;
            ctx.font = `bold ${size}px monospace`;
            ctx.textAlign = "center";
            ctx.fillStyle = p.big ? `rgba(200, 150, 0, ${alpha})` : `rgba(0, 0, 0, ${alpha * 0.7})`;
            ctx.fillText(p.text, p.x, p.y);
          } else {
            ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.6})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
            ctx.fill();
          }
        });

        // Ball
        balls.forEach((ball) => {
          drawBall(ball);
        });

        // Score
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.font = "bold 24px monospace";
        ctx.textAlign = "right";
        ctx.fillText(`${gameState.score}`, canvas.width - 20, 35);

        ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
        ctx.font = "14px monospace";
        ctx.fillText(`best ${gameState.highScore}`, canvas.width - 20, 55);

        // Hint
        ctx.fillStyle = "rgba(0, 0, 0, 0.25)";
        ctx.font = "12px monospace";
        ctx.textAlign = "center";
        ctx.fillText("hold a wheel to grow it", canvas.width / 2, canvas.height - 15);
      }

      // ============================================================================
      // INPUT - Click directly on wheels!
      // ============================================================================

      function WheelballPointerDown(x, y) {
        // Check if clicking on any wheel
        for (const wheel of gameState.wheels) {
          const dx = x - wheel.x;
          const dy = y - wheel.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          // Generous hit area
          if (dist < wheel.maxSize * 0.8) {
            wheel.size = wheel.maxSize;
            gameState.activeWheel = wheel;
            return;
          }
        }
      }

      function WheelballPointerUp() {
        // Release all wheels
        gameState.wheels.forEach((w) => {
          w.isHeld = false;
        });
        gameState.activeWheel = null;
      }

      // HELPERS
      function contains(ball, x, y) {
        const dx = x - ball.x,
          dy = y - ball.y;
        return Math.sqrt(dx * dx + dy * dy) < ball.radius;
      }
      function ballCollisions() {
        for (let i = 0; i < balls.length; i++) {
          for (let j = i + 1; j < balls.length; j++) {
            const b1 = balls[i],
              b2 = balls[j];
            if (b1.popping || b2.popping || b1.orbiting || b2.orbiting || b1.frozen || b2.frozen || b1.merging || b2.merging) continue;
            const dx = b2.x - b1.x,
              dy = b2.y - b1.y,
              dist = Math.sqrt(dx * dx + dy * dy),
              minDist = b1.radius + b2.radius;
            if (dist < minDist) {
              const ang = Math.atan2(dy, dx),
                ax = (minDist - dist) * Math.cos(ang) * 0.05,
                ay = (minDist - dist) * Math.sin(ang) * 0.05;
              b1.vx -= ax;
              b1.vy -= ay;
              b2.vx += ax;
              b2.vy += ay;
            }
          }
        }
      }
      function lineCircleCollision(x1, y1, x2, y2, cx, cy, radius) {
        const dx = x2 - x1,
          dy = y2 - y1,
          fx = x1 - cx,
          fy = y1 - cy,
          a = dx * dx + dy * dy,
          b = 2 * (fx * dx + fy * dy),
          c = fx * fx + fy * fy - radius * radius;
        let disc = b * b - 4 * a * c;
        if (disc < 0) return { collides: false };
        disc = Math.sqrt(disc);
        const t1 = (-b - disc) / (2 * a),
          t2 = (-b + disc) / (2 * a);
        if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {
          const t = Math.max(0, Math.min(1, -b / (2 * a))),
            closestX = x1 + t * dx,
            closestY = y1 + t * dy,
            distX = cx - closestX,
            distY = cy - closestY,
            dist = Math.sqrt(distX * distX + distY * distY);
          if (dist < radius) {
            const pushDist = radius - dist;
            return { collides: true, newX: cx + (distX / dist) * pushDist, newY: cy + (distY / dist) * pushDist };
          }
        }
        return { collides: false };
      }

      // GAME MANAGEMENT
      function switchGame(gameNum) {
        if (gameNum < 1 || gameNum > 16) return;
        currentGame = gameNum;
        screenShake = { x: 0, y: 0, intensity: 0 };
        document.querySelectorAll(".nav-item").forEach((item) => {
          item.classList.remove("active");
          if (parseInt(item.dataset.game) === currentGame) item.classList.add("active");
        });
        games[currentGame].init();
      }
      document.querySelectorAll(".nav-item").forEach((item) => {
        item.addEventListener("click", () => {
          switchGame(parseInt(item.dataset.game));
        });
      });

      // INPUT
      function getPointer(e) {
        const touch = e.touches ? e.touches[0] : e;
        return { x: touch.clientX, y: touch.clientY };
      }
      canvas.addEventListener("mousedown", (e) => {
        e.preventDefault();
        isMouseDown = true;
        const { x, y } = getPointer(e),
          game = games[currentGame];
        if (game.onPointerDown) game.onPointerDown(x, y);
      });
      canvas.addEventListener("mousemove", (e) => {
        const { x, y } = getPointer(e);
        mouseX = x;
        mouseY = y;
        const game = games[currentGame];
        if (game.onPointerMove) game.onPointerMove(x, y);
      });
      canvas.addEventListener("mouseup", (e) => {
        e.preventDefault();
        isMouseDown = false;
        const game = games[currentGame];
        if (game.onPointerUp) game.onPointerUp();
      });
      canvas.addEventListener("mouseleave", (e) => {
        if (isMouseDown) {
          const game = games[currentGame];
          if (game.onPointerUp) game.onPointerUp();
        }
      });
      window.addEventListener("mouseup", (e) => {
        if (isMouseDown) {
          isMouseDown = false;
          const game = games[currentGame];
          if (game.onPointerUp) game.onPointerUp();
        }
      });
      window.addEventListener("blur", () => {
        if (isMouseDown) {
          isMouseDown = false;
          const game = games[currentGame];
          if (game.onPointerUp) game.onPointerUp();
        }
      });
      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        const { x, y } = getPointer(e),
          game = games[currentGame];
        if (game.onPointerDown) game.onPointerDown(x, y);
      });
      canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();
        const { x, y } = getPointer(e);
        mouseX = x;
        mouseY = y;
        const game = games[currentGame];
        if (game.onPointerMove) game.onPointerMove(x, y);
      });
      canvas.addEventListener("touchend", (e) => {
        e.preventDefault();
        const game = games[currentGame];
        if (game.onPointerUp) game.onPointerUp();
      });
      document.addEventListener("keydown", (e) => {
        const num = parseInt(e.key);
        if (num >= 1 && num <= 9) switchGame(num);
        if (e.key === "0") switchGame(10);
        if (e.key === "Shift" && gameState && gameState.shiftPressed !== undefined) gameState.shiftPressed = true;
      });
      document.addEventListener("keyup", (e) => {
        if (e.key === "Shift" && gameState && gameState.shiftPressed !== undefined) gameState.shiftPressed = false;
      });
      window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });

      // LOOP
      function animate() {
        updateScreenShake();
        ctx.save();
        ctx.translate(screenShake.x, screenShake.y);
        ctx.clearRect(-10, -10, canvas.width + 20, canvas.height + 20);
        const game = games[currentGame];
        game.update();
        game.draw();
        ctx.restore();
        requestAnimationFrame(animate);
      }
      switchGame(1);
      animate();
    </script>
  </body>
</html>
